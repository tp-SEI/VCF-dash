import dash
from dash import Dash, dcc, html, dash_table
from dash.dependencies import Input, Output, State
import dash_bootstrap_components as dbc
import numpy as np
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
import openpyxl
from plotly.subplots import make_subplots
import os
import matplotlib.pyplot as plt
from dash.exceptions import PreventUpdate
import base64
import io
import time
import itertools
import warnings
pd.options.mode.chained_assignment = None  # default='warn'
import plotly.subplots as sp
import xlsxwriter


FONT_AWESOME = ["//assets//fontAwesome//all.min.css"]

#change working directory to script location path
abspath = os.path.abspath(__file__)
dname = os.path.dirname(abspath)
os.chdir(dname)
os.chdir('assets/data')

#import data and set Country as index
cities_cntrs = pd.read_excel('NZC-cities-countries.xlsx')
cities_cntrs.set_index(cities_cntrs['Country'], inplace = True)
countries = sorted(cities_cntrs['Country'].unique())

#app = Dash(__name__, external_stylesheets = [dbc.themes.VAPOR])
#Other cool themes
app = Dash(__name__, external_stylesheets = [dbc.themes.SUPERHERO, FONT_AWESOME])
#app = Dash(__name__, external_stylesheets = [dbc.themes.SOLAR])
#app = Dash(__name__, external_stylesheets = [dbc.themes.DARKLY])
#app = Dash(__name__, external_stylesheets = [dbc.themes.QUARTZ])
server = app.server

regions_län = pd.read_excel("regions_municipalities.xlsx")
regions_län.set_index("Län", inplace = True)
cbe_emissions = pd.read_excel("CBE_emissions.xlsx")
cbe_emissions.set_index("Municipality", inplace = True)
wb = openpyxl.load_workbook("SE_data.xlsx")
cars = pd.DataFrame(wb["Ownership_cars"].values, columns=next(wb["Ownership_cars"].values)[0:])
buses = pd.DataFrame(wb["Public_buses"].values, columns=next(wb["Public_buses"].values)[0:])
pop = pd.DataFrame(wb["Population"].values, columns=next(wb["Population"].values)[0:])
dwellings_ratio = pd.DataFrame(wb["Dwellings_ratios"].values, columns=next(wb["Dwellings_ratios"].values)[0:])
dh_ef = pd.DataFrame(wb["DH-EF"].values, columns=next(wb["DH-EF"].values)[0:])
dh = pd.DataFrame(wb["DH"].values, columns=next(wb["DH"].values)[0:])
el_shares = pd.DataFrame(wb["EL-DH ratios"].values, columns=next(wb["EL-DH ratios"].values)[0:])
dwellings_ownership = pd.DataFrame(wb["Ownership_dwelling"].values, columns=next(wb["Ownership_dwelling"].values)[0:])
dwellings_tenureship = pd.DataFrame(wb["Dwellings_tenureship"].values, columns=next(wb["Dwellings_tenureship"].values)[0:])
dwellings_stock = pd.DataFrame(wb["Housing_stock"].values, columns=next(wb["Housing_stock"].values)[0:])
dwellings_size = pd.DataFrame(wb["Dwellings_total_size"].values, columns=next(wb["Dwellings_total_size"].values)[0:])
distance = pd.DataFrame(wb["Average_driven_cars"].values, columns=next(wb["Average_driven_cars"].values)[0:])
elpriser = pd.DataFrame(wb["Elpriser"].values, columns=next(wb["Elpriser"].values)[0:]) ############################ Added a new sheet in SE data which is connected with assumptions 
pt_cost = pd.DataFrame(wb["Public_transport_cost"].values, columns=next(wb["Public_transport_cost"].values)[0:])
pt_cost.set_index("Län", inplace=True)
regions = pd.read_excel("regions_municipalities1.xlsx")
regions.set_index("Municipality",inplace =True)
offered_pt = pd.DataFrame(wb["Offered_public_transport"].values, columns=next(wb["Offered_public_transport"].values)[0:])
offered_pt.set_index("Municipality", inplace = True)
reg_pop = pd.DataFrame(wb["Region_population"].values, columns=next(wb["Region_population"].values)[0:])
reg_pop.set_index("Region", inplace=True)

dh_ef.set_index(dh_ef.columns[0], inplace=True)
dwellings_tenureship.set_index("Municipality", inplace = True)

for df in [cars, buses, pop, dwellings_ratio, dh, el_shares, dwellings_ownership, dwellings_stock,
           dwellings_size, distance, elpriser]:
    df.set_index("Municipality", inplace=True)

tbe_emissions = pd.read_excel("TBE_emissions.xlsx")
tbe_emissions.set_index("Municipality", inplace=True)

app.title = "Viable Cities Finance"
app.config["suppress_callback_exceptions"] = True
percentages = list(range(0, 101))
percentages_5 = list(range(0, 101, 20))
percentages1 = list(range(-20, 21))
percentages_10 = list(range(-20,21,5))

countries1 = ["Stockholms län", "Uppsala län", "Södermanlands län", "Östergötlands län", "Jönköpings län", "Kronobergs län", "Kalmar län", "Gotlands län", "Blekinge län", "Skåne län", "Hallands län", "Västra Götalands län", "Värmlands län", "Örebro län", "Västmanlands län", "Dalarnas län", "Gävleborgs län", "Västernorrlands län", "Jämtlands län", "Västerbottens län", "Norrbottens län"]

municipalities = ['Ale', 'Alingsås', 'Älmhult', 'Älvdalen', 'Alvesta', 'Älvkarleby',
       'Älvsbyn', 'Åmål', 'Aneby', 'Ånge', 'Ängelholm', 'Arboga', 'Åre',
       'Årjäng', 'Arjeplog', 'Arvidsjaur', 'Arvika', 'Åsele', 'Askersund',
       'Åstorp', 'Åtvidaberg', 'Avesta', 'Båstad', 'Bengtsfors', 'Berg',
       'Bjurholm', 'Bjuv', 'Boden', 'Bollebygd', 'Bollnäs', 'Borås',
       'Borgholm', 'Borlänge', 'Botkyrka', 'Boxholm', 'Bräcke',
       'Bromölla', 'Burlöv', 'Dals-Ed', 'Danderyd', 'Degerfors',
       'Dorotea', 'Eda', 'Ekerö', 'Eksjö', 'Emmaboda', 'Enköping',
       'Eskilstuna', 'Eslöv', 'Essunga', 'Fagersta', 'Falkenberg',
       'Falköping', 'Falun', 'Färgelanda', 'Filipstad', 'Finspång',
       'Flen', 'Forshaga', 'Gagnef', 'Gällivare', 'Gävle', 'Gislaved',
       'Gnesta', 'Gnosjö', 'Göteborg', 'Götene', 'Gotland', 'Grästorp',
       'Grums', 'Gullspång', 'Habo', 'Håbo', 'Hagfors', 'Hällefors',
       'Hallsberg', 'Hallstahammar', 'Halmstad', 'Hammarö', 'Haninge',
       'Haparanda', 'Härjedalen', 'Härnösand', 'Härryda', 'Hässleholm',
       'Heby', 'Hedemora', 'Helsingborg', 'Herrljunga', 'Hjo', 'Hofors',
       'Höganäs', 'Högsby', 'Höör', 'Hörby', 'Huddinge', 'Hudiksvall',
       'Hultsfred', 'Hylte', 'Järfälla', 'Jokkmokk', 'Jönköping', 'Kalix',
       'Kalmar', 'Karlsborg', 'Karlshamn', 'Karlskoga', 'Karlskrona',
       'Karlstad', 'Katrineholm', 'Kävlinge', 'Kil', 'Kinda', 'Kiruna',
       'Klippan', 'Knivsta', 'Köping', 'Kramfors', 'Kristianstad',
       'Kristinehamn', 'Krokom', 'Kumla', 'Kungälv', 'Kungsbacka',
       'Kungsör', 'Laholm', 'Landskrona', 'Laxå', 'Lekeberg', 'Leksand',
       'Lerum', 'Lessebo', 'Lidingö', 'Lidköping', 'Lilla Edet',
       'Lindesberg', 'Linköping', 'Ljungby', 'Ljusdal', 'Ljusnarsberg',
       'Lomma', 'Ludvika', 'Luleå', 'Lund', 'Lycksele', 'Lysekil', 'Malå',
       'Malmö', 'Malung-Sälen', 'Mariestad', 'Mark', 'Markaryd',
       'Mellerud', 'Mjölby', 'Mölndal', 'Mönsterås', 'Mora', 'Mörbylånga',
       'Motala', 'Mullsjö', 'Munkedal', 'Munkfors', 'Nacka', 'Nässjö',
       'Nora', 'Norberg', 'Nordanstig', 'Nordmaling', 'Norrköping',
       'Norrtälje', 'Norsjö', 'Nybro', 'Nyköping', 'Nykvarn', 'Nynäshamn',
       'Ockelbo', 'Öckerö', 'Ödeshög', 'Olofström', 'Örebro',
       'Örkelljunga', 'Örnsköldsvik', 'Orsa', 'Orust', 'Osby',
       'Oskarshamn', 'Österåker', 'Östersund', 'Östhammar',
       'Östra Göinge', 'Ovanåker', 'Överkalix', 'Övertorneå', 'Oxelösund',
       'Pajala', 'Partille', 'Perstorp', 'Piteå', 'Ragunda', 'Rättvik',
       'Robertsfors', 'Ronneby', 'Säffle', 'Sala', 'Salem', 'Sandviken',
       'Säter', 'Sävsjö', 'Sigtuna', 'Simrishamn', 'Sjöbo', 'Skara',
       'Skellefteå', 'Skinnskatteberg', 'Skövde', 'Skurup',
       'Smedjebacken', 'Söderhamn', 'Söderköping', 'Södertälje',
       'Sollefteå', 'Sollentuna', 'Solna', 'Sölvesborg', 'Sorsele',
       'Sotenäs', 'Staffanstorp', 'Stenungsund', 'Stockholm', 'Storfors',
       'Storuman', 'Strängnäs', 'Strömstad', 'Strömsund', 'Sundbyberg',
       'Sundsvall', 'Sunne', 'Surahammar', 'Svalöv', 'Svedala',
       'Svenljunga', 'Täby', 'Tanum', 'Tibro', 'Tidaholm', 'Tierp',
       'Timrå', 'Tingsryd', 'Tjörn', 'Tomelilla', 'Töreboda', 'Torsås',
       'Torsby', 'Tranås', 'Tranemo', 'Trelleborg', 'Trollhättan',
       'Trosa', 'Tyresö', 'Uddevalla', 'Ulricehamn', 'Umeå',
       'Upplands Väsby', 'Upplands-Bro', 'Uppsala', 'Uppvidinge',
       'Vadstena', 'Vaggeryd', 'Valdemarsvik', 'Vallentuna', 'Vänersborg',
       'Vännäs', 'Vansbro', 'Vara', 'Varberg', 'Vårgårda', 'Värmdö',
       'Värnamo', 'Västerås', 'Västervik', 'Vaxholm', 'Växjö', 'Vellinge',
       'Vetlanda', 'Vilhelmina', 'Vimmerby', 'Vindeln', 'Vingåker',
       'Ydre', 'Ystad']


def build_banner():
    return html.Div(        
        id="banner",
        className = "banner",
        children = [
            html.Div(
                id="VCF-logo-div",
                children = [
                    html.Img(id="VCF-logo",
                    src="assets/VCF_logo.png")],
            ),
            html.Div(
                id = "banner-text",
                children = [
                    html.H3("Viable Cities Finance Dashboard"),
                    html.H4("Emissions Reduction Cost Assessment - Beta"),
                    ]
                ),
            html.Div(
                id = "learn-more-button",
                children=[
                    dbc.Button("Learn More", id = "modal-opener"),
                    dbc.Modal(
                        [
                            dbc.ModalHeader("INFO BOX"),
                            dbc.ModalBody("""
                                        Want to know more? Please visit our websites (links below) or email us: Fedra Vanhuyse (fedra.vanhuyse@sei.org, fedra.vanhuyse@viablecities.se), Marcus Lindeberg Goñi (marcus.lindeberg.goni@sei.org), Gowtham Muthukumaran (gowtham.muthukumaran@sei.org) and Tommaso Piseddu (tommaso.piseddu@sei.org)
                                            """),
                            dbc.ModalFooter(
                                [
                                dbc.Button("Financing urban transitions", id = "sei-button", href = "https://www.sei.org/projects-and-tools/projects/viable-cities-finance/#overview", target="_blank"),
                                dbc.Button("Viable Cities Program", id = "VC-button", href = "https://en.viablecities.se/", target="_blank"),
                                dbc.Button("Close", id = "modal-closer")]
                                )
                            ],
                        id="info-modal"),
                    dbc.Button("Glossary", id="glossary-button"),
                    dbc.Modal(
                        [
                            dbc.ModalHeader("Glossary"),
                            dbc.ModalBody([
                                html.H5("Consumption-based emissions"),
                                html.P("The emissions resulting from the economic activity required to meet a nation's demand for goods and services."),
                                html.H5("Territorial emissions"),
                                html.P("Emissions that take place within a municipality's territorial boundaries and include exports but omit imports."),
                                html.H5("CAPEX"),
                                html.P("Capital Expenditure. The sum an organization, a corporate entity or a private citizen spends to buy, maintain, or improve its fixed assets (real estate assets, cars, buses, etc.)"),
                                html.H5("OPEX"),
                                html.P("Operational Expenditure. The ongoing cost for running a product, business, or system."),
                                html.H5("Savings"),
                                html.P( "Quantifiable reduction in costs or expenses achieved through taking proper mitigation measures."),
                                html.H5("Income"),
                                html.P( "Total amount of money or value received by relevant actors within a specified time period.")


                            ])
                        ],
                    id="glossary-modal"),
                    dbc.Button("Methodology", id="methodology-button"),
                    dbc.Modal(
                        [
                            dbc.ModalHeader("Methodology"),
                            dbc.ModalBody([
                                html.H5("The model and the data"),
                                html.P("""To calculate the financial investments needed for climate neutral cities, we
                                developed a model consisting of a series of databases and calculations. We make use of
                                four main databases in our model: 1) greenhouse gas emissions at the municipal level (SEI's
                                Konsumtionskompassen project and Naturvårdsverket), 2) Population growth forecasts up to
                                2030 (SCB), 3) Socio-economic data at city level (Trafikverket, SCB and others),
                                4) mitigation measures and costs (literature review)."""),
                                html.H5("The scenarios"),
                                html.P("""Three alternatives scenarios were designed to forecast emissions by 2030 at the municipal
                                level: 1) Business as usual (BAU); 2) an increase in emissions; and 3) a reduction in
                                emissions."""),
                                html.P("""For detailed methodology of the dashboard please download the following user guide by clicking the download link."""),
                                html.Div([
                                    html.A('Download User guide', id='download-link-1', href=user_guide(), target='_blank', style={'display': 'block', 'margin-bottom': '10px',  'margin-left': '10px'}),
                                ], style={'margin-top': '20px'}),
                            ])
                        ],
                    id="methodology-modal")
                    ]
                )
            ]
        )

def collapse():
  return  html.Div(
        [
#Emissions accounting methodology, municipality selection and parameters settings
        html.Div(
            id="welcome-banner",
            children=[
                html.H2("Welcome!",id="welcome-text"),
                html.P("""
                        Sweden aims to achieve net zero emissions by 2045, which equals to less than 1 tonne of greenhouse gas emissions per person (Swedish Climate Policy Framework, 2017).
                        The purpose of this dashboard is to support Swedish municipalities with their climate action and investment planning.
                        It provides 1) insight into the current emissions in the cities, from a territorial emissions perspective and a consumption-based perspective (household level data only); 2) some forecasts to 2030 using population growth and other socio-economic data; 3) a tool to see the effects of different climate actions, and their associated costs. The necessary investments are computed for different types of stakeholders, and emission profiles broken into different categories. Please note that the consumption-based emissions do not incorporate emissions from the government sector.""", id = "welcome-subtext"),
                html.Ul(id="bullet-list",
                        children=[html.Li("1. Please select a municipality", id="Li-1"), html.Li("2. Design your own climate action strategy, looking at territorial or consumption based emissions", id="Li-2"), html.Li("3. Assess the consequences of the climate action strategy mix, in terms of future emissions and costs", id="Li-3")]),
                html.Div(
                    [dcc.Dropdown(
                        id="region-dropdown",
                        options=countries1,
                        searchable=True,
                        placeholder="Select a Region")],
                    id="region-dropdown-div"),
                html.Div(
                    [dcc.Dropdown(
                        id="municipality-dropdown",
                        options= municipalities,
                        searchable=True,
                        placeholder="Select a Municipality")],
                    id="municipality-dropdown-div"),
                ])
        ], id="div-1")

def assumptions_tab1():
    data = [
        ["Diesel price per 10KM", "13", "SEK in 2022", "Cars"],
        ["Petrol price per 10KM", "15.2", "SEK in 2022", "Cars"],
        ["Electric price per 10KM", "5.5", "SEK in 2022", "Cars"],
        ["Hydrogen price per 10KM", "9", "SEK in 2022", "Cars"],
        ["Average driving distance per year of a car 10KM", "1,112", "10KM", "Cars"],
        ["Plug in hybrid emissions vs diesel or petrol car", "30%", "", "Cars"],
        ["Share of petrol over (petrol and diesel cars)", "61%", "", "Cars"],
        ["OPEX trucks biogas extra cost compared to diesel", "0.13", "SEK/Km", "Trucks"],
        ["OPEX trucks biogas extra cost compared to diesel", "0.50", "SEK/Km", "Trucks"],
        ["OPEX trucks biogas extra cost compared to diesel", "0.30", "SEK/Km", "Trucks"],
        ["OPEX trucks biogas extra cost compared to diesel", "0.55", "SEK/Km", "Trucks"],
        ["OPEX trucks biogas extra cost compared to diesel", "0.35", "SEK/Km", "Trucks"],
        ["OPEX trucks biogas extra cost compared to diesel", "3.65", "SEK/mil", "Trucks"],
        ["Consumptiom per KM", "3.72", "2015", "Bus"],
        ["OPEX Diesel consumption per 10 Km", "2.40", "Liter/mil", "Trucks"],
        ["Diesel price per liter", "21.00", "SEK/liter", "Trucks"],
        ["OPEX Diesel consumption per 10 Km", "50.40", "SEK/mil", "Trucks"],
        ["Congestion tax revenue in 2020", "2400000000", "SEK/år", ""],
        ["Waste share of EH and DH emissions", "73%", "2021", ""],
        ["Electricity used in housing and services", "58%", "2019", ""],
        ["Electricity used in industry", "37%", "2019", ""],
        ["Emission factor from heat production Malmö", "122", "g/KWH", ""],
        ["Emission factor from electricity production Malmö", "48", "g/KWH", ""],
        ["Average ETS price in 2022", "80", "euros", ""],
        ["Price electricity Sweden 2022", "1.07", "SEK/KWh", ""],
        ["From petrol to plug in hybrid - remaining emissions", "28.00%", "", ""],
        ["From diesel to plug in hybrid - remaining emissions", "39.00%", "", ""],
        ["Lifetime of a car", "16", "years", ""],
        ["Wind power production in Sweden in 2022", "27.1", "TWh", ""],
        ["GW to GWh conversion Wind", "2,747", "GWh/GW", ""],
        ["Wind power estimate by 2030 need capacity", "29.6", "GW", "Assuming we need to triple production"],
        ["Solar power production in Sweden in 2022", "1.1", "TWh", ""],
        ["GW to GWh conversion solar", "986.1495845", "GWh/GW", ""],
        ["Solar power estimate by 2030 need capacity", "3.3", "GW", "Assuming we need to triple production"],
        ["Bus emissions left from switching to HVO/RME/biogas fuel", "10%", "", ""],
        ["Electric cars share of Swedish market", "35%", "2022", "Based on newly registered vehicles in Sweden"],
        ["Plug in hybrid share of Swedish market", "23%", "2022", ""],
        ["HVO use in buses today", "38%", "Sweden 2019", ""],
        ["Share of Electricity and DH emissions from electricity", "40%", "Sweden", ""],
        ["Share of charging station for hybrid vs BEV need", "50%", "Sweden", ""],
        ["Share of district heating covered by heat pumps from air", "33%", "", "Mock value"],
        ["Share of district heating covered by heat pumps from water", "33%", "", "Mock value"],
        ["Share of district heating covered by heat pumps from geothermal", "33%", "", "Mock value"],
        ["Air heat pump emissions saving", "100%", "", ""],
        ["Air heat pump emissions saving", "100%", "", ""],
        ["Air heat pump emissions saving", "100%", "", ""],
        ["Impact from BAT appliances on energy savings", "21%", "", "Mock value"],
        ["Impact from reduced temperature to 20 degrees on energy savings", "16%", "", "City-specific!"],
        ["Impact from Savvidou Nykvist measures on energy savings", "16%", "", "City-specific!"],
        ["CCS captures share of emissions", "90%", "", ""],
        ["Share of Carbon Credits counted towards negative emissions in net zero target", "100%", "", ""],
        ["Share of bio-CCS counted towards negative emissions in net zero target", "100%", "", ""],
        ["Share of rewetting counted towards negative emissions in net zero target", "100%", "", ""],
        ["Share of agricultural emissions related to methane", "53%", "", ""],
        ["Share of city landfill site waste coming from the same city", "100%", "", ""],
        ["Share of new electric cars causing early replacement of fossil fueled cars", "0%", "", ""],
        ["Emissions from biogas heavy vehicle compared to diesel", "19%", "", ""],
        ["Share of emissions reduced by hydrogen industry", "100%", "", ""],
        ["Fossil-free share of electricity mix used in city", "96%", "", ""]
    ]

    table_rows = [html.Tr([html.Td(col) for col in row]) for row in data]
    table = html.Table([
        html.Thead([
            html.Tr([html.Th("Factor"), html.Th("Value"), html.Th("Unit"), html.Th("Comment")])
        ]),
        html.Tbody(table_rows)
    ])

    return html.Div(
        id="assumption-button",
        children=[
            dbc.Button("List of assumptions", id="TBE_assumption-button"),
            dbc.Modal(
                [
                    dbc.ModalBody([
                        html.H5("Conversion rates"),
                        html.P([
                            "EUR to SEK: 11.34", html.Br(),
                            "USD to SEK: 10.39", html.Br(),
                            "GBP to SEK: 12.96", html.Br(),
                            "", html.Br(),
                            "USD 2008 to USD 2023: 1.4", html.Br(),
                            "1997 USD to USD 2023: 1.87"
                        ]),
                        html.H5("Complementary data and assumptions"),
                        table,
                    ]),
                    dbc.ModalFooter([
                        html.Div([
                            html.Button("Download Data", id="btn-download-assumptions-tbe1"),
                            dcc.Download(id="download-assumptions-tbe1-text")
                        ])
                    ])
                ],
                id="TBE_assumption-modal1"
            )
        ]
    )

def assumptions_tab2():
    data = [
        ["Diesel price per 10KM", "13", "SEK in 2022", "Cars"],
        ["Petrol price per 10KM", "15.2", "SEK in 2022", "Cars"],
        ["Electric price per 10KM", "5.5", "SEK in 2022", "Cars"],
        ["Hydrogen price per 10KM", "9", "SEK in 2022", "Cars"],
        ["Average driving distance per year of a car 10KM", "1,112", "10KM", "Cars"],
        ["Plug in hybrid emissions vs diesel or petrol car", "30%", "", "Cars"],
        ["Share of petrol over (petrol and diesel cars)", "61%", "", "Cars"],
        ["OPEX trucks biogas extra cost compared to diesel", "0.13", "SEK/Km", "Trucks"],
        ["OPEX trucks biogas extra cost compared to diesel", "0.50", "SEK/Km", "Trucks"],
        ["OPEX trucks biogas extra cost compared to diesel", "0.30", "SEK/Km", "Trucks"],
        ["OPEX trucks biogas extra cost compared to diesel", "0.55", "SEK/Km", "Trucks"],
        ["OPEX trucks biogas extra cost compared to diesel", "0.35", "SEK/Km", "Trucks"],
        ["OPEX trucks biogas extra cost compared to diesel", "3.65", "SEK/mil", "Trucks"],
        ["Consumptiom per KM", "3.72", "2015", "Bus"],
        ["OPEX Diesel consumption per 10 Km", "2.40", "Liter/mil", "Trucks"],
        ["Diesel price per liter", "21.00", "SEK/liter", "Trucks"],
        ["OPEX Diesel consumption per 10 Km", "50.40", "SEK/mil", "Trucks"],
        ["Congestion tax revenue in 2020", "2400000000", "SEK/år", ""],
        ["Waste share of EH and DH emissions", "73%", "2021", ""],
        ["Electricity used in housing and services", "58%", "2019", ""],
        ["Electricity used in industry", "37%", "2019", ""],
        ["Emission factor from heat production Malmö", "122", "g/KWH", ""],
        ["Emission factor from electricity production Malmö", "48", "g/KWH", ""],
        ["Average ETS price in 2022", "80", "euros", ""],
        ["Price electricity Sweden 2022", "1.07", "SEK/KWh", ""],
        ["From petrol to plug in hybrid - remaining emissions", "28.00%", "", ""],
        ["From diesel to plug in hybrid - remaining emissions", "39.00%", "", ""],
        ["Lifetime of a car", "16", "years", ""],
        ["Wind power production in Sweden in 2022", "27.1", "TWh", ""],
        ["GW to GWh conversion Wind", "2,747", "GWh/GW", ""],
        ["Wind power estimate by 2030 need capacity", "29.6", "GW", "Assuming we need to triple production"],
        ["Solar power production in Sweden in 2022", "1.1", "TWh", ""],
        ["GW to GWh conversion solar", "986.1495845", "GWh/GW", ""],
        ["Solar power estimate by 2030 need capacity", "3.3", "GW", "Assuming we need to triple production"],
        ["Bus emissions left from switching to HVO/RME/biogas fuel", "10%", "", ""],
        ["Electric cars share of Swedish market", "35%", "2022", "Based on newly registered vehicles in Sweden"],
        ["Plug in hybrid share of Swedish market", "23%", "2022", ""],
        ["HVO use in buses today", "38%", "Sweden 2019", ""],
        ["Share of Electricity and DH emissions from electricity", "40%", "Sweden", ""],
        ["Share of charging station for hybrid vs BEV need", "50%", "Sweden", ""],
        ["Share of district heating covered by heat pumps from air", "33%", "", "Mock value"],
        ["Share of district heating covered by heat pumps from water", "33%", "", "Mock value"],
        ["Share of district heating covered by heat pumps from geothermal", "33%", "", "Mock value"],
        ["Air heat pump emissions saving", "100%", "", ""],
        ["Air heat pump emissions saving", "100%", "", ""],
        ["Air heat pump emissions saving", "100%", "", ""],
        ["Impact from BAT appliances on energy savings", "21%", "", "Mock value"],
        ["Impact from reduced temperature to 20 degrees on energy savings", "16%", "", "City-specific!"],
        ["Impact from Savvidou Nykvist measures on energy savings", "16%", "", "City-specific!"],
        ["CCS captures share of emissions", "90%", "", ""],
        ["Share of Carbon Credits counted towards negative emissions in net zero target", "100%", "", ""],
        ["Share of bio-CCS counted towards negative emissions in net zero target", "100%", "", ""],
        ["Share of rewetting counted towards negative emissions in net zero target", "100%", "", ""],
        ["Share of agricultural emissions related to methane", "53%", "", ""],
        ["Share of city landfill site waste coming from the same city", "100%", "", ""],
        ["Share of new electric cars causing early replacement of fossil fueled cars", "0%", "", ""],
        ["Emissions from biogas heavy vehicle compared to diesel", "19%", "", ""],
        ["Share of emissions reduced by hydrogen industry", "100%", "", ""],
        ["Fossil-free share of electricity mix used in city", "96%", "", ""]
    ]

    table_rows = [html.Tr([html.Td(col) for col in row]) for row in data]
    table = html.Table([
        html.Thead([
            html.Tr([html.Th("Factor"), html.Th("Value"), html.Th("Unit"), html.Th("Comment")])
        ]),
        html.Tbody(table_rows)
    ])
    return html.Div(
                id = "assumption-button1",
                children=[
                    dbc.Button("List of assumptions", id = "CBE_assumption-button"),
                    dbc.Modal(
                        [
                            dbc.ModalBody([
                                html.H5("Conversion rates"),
                                html.P([
                                    "EUR to SEK: 11.34", html.Br(),
                                    "USD to SEK: 10.39", html.Br(),
                                    "GBP to SEK: 12.96", html.Br(),
                                    "", html.Br(),
                                    "USD 2008 to USD 2023: 1.4", html.Br(),
                                    "1997 USD to USD 2023: 1.87"
                                ]),
                                html.H5("Complementary data and assumptions"),
                                table,
                            ]),
                            dbc.ModalFooter([
                                 html.Div([
                                    html.Button("Download Data", id="btn-download-assumptions-cbe"),
                                    dcc.Download(id="download-assumptions-cbe-text")])])],
                    id="CBE_assumption-modal1")]) 

def assumptions_tab3():
    return html.Div(
                id = "assumption-button3",
                children=[
                    dbc.Button("List of assumptions", id = "TBE_assumption-button2"),
                    dbc.Modal(
                        [dbc.ModalHeader("CBE scenario assumptions"),
                            dbc.ModalBody([
                                html.H5("BAU scenario"),
                                html.P("""NEED TO FILL."""),
                                html.H5("Scenario 2"),
                                html.P("""NEED TO FILL."""),
                                html.H5("Scenario 3"),
                                html.P("""NEED TO FILL.""")]),
                            dbc.ModalFooter([
                                 html.Div([
                                    html.Button("Download Data", id="btn-download-assumptions-tbe2"),
                                    dcc.Download(id="download-assumptions-tbe2-text")])])],
                    id="TBE_assumption-modal3")])

def scenario_dropdown1():
    return html.Div([
                        html.P(
                            "Please select a scenario:"
                        ),
                        dcc.Dropdown(
                            id="scenario-dropdown-list-1",
                            options=["Scenario 1 - Business as usual Scenario", "Scenario 2 - Pessimistic Scenario", "Scenario 3 - Optimistic Scenario"],
                            value="Scenario 1 - Business as usual Scenario",
                            searchable=True,
                            placeholder="..."
                        )],
                        id="scenario-dropdown1")
def scenario_dropdown2():
    return html.Div([
                        html.P(
                            "Please select a scenario:"
                        ),
                        dcc.Dropdown(
                            id="scenario-dropdown-list-2",
                            options=["Scenario 1 - Business as usual Scenario", "Scenario 2 - Pessimistic Scenario", "Scenario 3 - Optimistic Scenario"],
                            value="Scenario 1 - Business as usual Scenario",
                            searchable=True,
                            placeholder="..."
                        )],
                        id="scenario-dropdown2")

def scenario_dropdown3():
    return html.Div([
                        html.P(
                            "Please select a scenario:"
                        ),
                        dcc.Dropdown(
                            id="scenario-dropdown-list-3",
                            options=["Scenario 1 - Business as usual Scenario", "Scenario 2 - Pessimistic Scenario", "Scenario 3 - Optimistic Scenario"],
                            value="Scenario 1 - Business as usual Scenario",
                            searchable=True,
                            placeholder="..."
                        )],
                        id="scenario-dropdown3")


Your_data = [
    {
        'Factor': 'EUR to SEK',
        'Existing assumptions': 11.34,
        'Source': '',
        'User assumptions': 11.34,
        'User source': '',
        'Units': ''
    },
    {
        'Factor': 'USD to SEK',
        'Existing assumptions': 10.39,
        'Source': '',
        'User assumptions': 10.39,
        'User source': '',
        'Units': ''
    },
    {
        'Factor': 'GBP to SEK',
        'Existing assumptions': 12.96,
        'Source': '',
        'User assumptions': 12.96,
        'User source': '',
        'Units': ''
    },
    {
        'Factor': 'Diesel price to carry average car 10 km',
        'Existing assumptions': 13,
        'Source': 'Mobility Sweden',
        'User assumptions': 13,
        'User source': '',
        'Units': 'SEK/10 km'
    },
    {
        'Factor': 'Petrol price to carry average car 10 km',
        'Existing assumptions': 15.2,
        'Source': 'Mobility Sweden',
        'User assumptions': 15.2,
        'User source': '',
        'Units': 'SEK/10 km'
    },

    {
        'Factor': 'Average driving distance per year of a car in 10 km',
        'Existing assumptions': 1112.056417,
        'Source': 'SCB',
        'User assumptions': 1112.056417,
        'User source': '',
        'Units': '10 km'
    },
    {
        'Factor': 'Average driving distance per year of a light truck in 10 km',
        'Existing assumptions': 1389.264817,
        'Source': 'SCB',
        'User assumptions': 1389.264817,
        'User source': '',
        'Units': '10 km'
    },
    {
        'Factor': 'Average driving distance per year of a heavy truck in 10 km',
        'Existing assumptions': 4196.609111,
        'Source': 'SCB',
        'User assumptions': 4196.609111,
        'User source': '',
        'Units': '10 km'
    },
    {
        'Factor': 'Average driving distance per year of a bus in 10 km',
        'Existing assumptions': 4973.194758,
        'Source': 'SCB',
        'User assumptions': 4973.194758,
        'User source': '',
        'Units': '10 km'
    },
    {
        'Factor': 'Heavy truck use of fuel compared to car',
        'Existing assumptions': 4.8,
        'Source': 'https://theicct.org/publication/comparison-of-fuel-consumption-and-emissions-for-representative-heavy-duty-vehicles-in-europe/',
        'User assumptions': 4.8,
        'User source': '',
        'Units': ''
    },
    {
        'Factor': 'Plug in hybrid emissions vs fossil fuelled car emissions',
        'Existing assumptions': 30,
        'Source': 'https://bransch.trafikverket.se/contentassets/7ce1527807fa44ff9aa195ab440d5184/pm-vagtrafikens-utslapp-220207.pdf and energimyndigheten',
        'User assumptions': 30,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'OPEX trucks biogas extra cost compared to diesel',
        'Existing assumptions': 3.65,
        'Source': 'SEIs assumption',
        'User assumptions': 3.65,
        'User source': '',
        'Units': 'SEK/10 km'
    },

    {
        'Factor': 'Bus fuel consumption per km',
        'Existing assumptions': 3.72,
        'Source': 'http://www.ecotraffic.se/media/10613/rapport_7078_-_kortversion_av_bussrapport_version_6.pdf',
        'User assumptions': 3.72,
        'User source': '',
        'Units': 'Liter/km'
    },
    {
        'Factor': 'Diesel price per liter',
        'Existing assumptions': 21,
        'Source': 'https://dieselpriset.se/',
        'User assumptions': 21,
        'User source': '',
        'Units': 'SEK/liter'
    },
    {
        'Factor': 'Lifelength of an average car',
        'Existing assumptions': 17,
        'Source': 'https://bilretur.se/sa-har-atervinns-din-bil/',
        'User assumptions': 17,
        'User source': '',
        'Units': 'years'
    },
    {
        'Factor': 'Lifelength of an average light truck',
        'Existing assumptions': 14,
        'Source': 'https://www.trafa.se/vagtrafik/hur-gamla-ar-olika-typer-av-vagfordon-11486/',
        'User assumptions': 14,
        'User source': '',
        'Units': 'years'
    },
    {
        'Factor': 'Lifelength of an average heavy truck',
        'Existing assumptions': 16,
        'Source': 'https://www.trafa.se/vagtrafik/hur-gamla-ar-olika-typer-av-vagfordon-11486/',
        'User assumptions': 16,
        'User source': '',
        'Units': 'years'
    },
    {
        'Factor': 'Lifelength of an average bus',
        'Existing assumptions': 10,
        'Source': 'https://www.trafa.se/vagtrafik/hur-gamla-ar-olika-typer-av-vagfordon-11486/',
        'User assumptions': 10,
        'User source': '',
        'Units': 'years'
    },
    {
        'Factor': 'Bus emissions left from switching to HVO/RME/biogas fuel',
        'Existing assumptions': 14.5,
        'Source': 'https://www.volvocars.com/se/edit/artikel/allt-om-hvo100',
        'User assumptions': 14.5,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Share of charging station for hybrid vs electric car need',
        'Existing assumptions': 50,
        'Source': 'https://theicct.org/publication/europe-ldv-review-of-afir-proposal-how-much-power-output-needed-for-public-charging-infrastructure-in-the-eu-mar22/',
        'User assumptions': 50,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Share of new electric cars causing early replacement of fossil fueled cars',
        'Existing assumptions': 0,
        'Source': '',
        'User assumptions': 0,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Share of new electric trucks causing early replacement of fossil fueled trucks',
        'Existing assumptions': 0,
        'Source': '',
        'User assumptions': 0,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Share of new electric buses causing early replacement of fossil fueled buses',
        'Existing assumptions': 0,
        'Source': '',
        'User assumptions': 0,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Emissions from biogas heavy vehicle compared to diesel',
        'Existing assumptions': 19,
        'Source': 'https://www.volvotrucks.com/content/dam/volvo-trucks/markets/global/our-values/environmental-care/our-trucks/Alternative_fuels_The_way_forward.pdf',
        'User assumptions': 19,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Public transport cost per month',
        'Existing assumptions': 1273,
        'Source': 'Regional websites across Sweden',
        'User assumptions': 1273,
        'User source': '',
        'Units': 'SEK/month'
    },
    {
        'Factor': 'Bicycle price (new bike)',
        'Existing assumptions': 6875,
        'Source': 'https://sverigesradio.se/artikel/6493380',
        'User assumptions': 6875,
        'User source': '',
        'Units': 'SEK'
    },
    {
        'Factor': 'Share of active transport reduction driving new cycling infrastructure needs',
        'Existing assumptions': 20,
        'Source': '',
        'User assumptions': 20,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Cycling infrastructure need for 1 person to switch car to bike',
        'Existing assumptions': 10,
        'Source': 'Cycling infrastrcuture - https://www.naturvardsverket.se/4a43bc/contentassets/9db319015c994a9d88f64fffae725765/210816-vagledning-klimatinvesteringar-cykelatgarder.pdf',
        'User assumptions': 10,
        'User source': '',
        'Units': '% Of a kilometer'
    },
    {
        'Factor': 'Electric vehicle new price in 2030 compared to today',
        'Existing assumptions': 100,
        'Source': '',
        'User assumptions': 100,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Share of region vs private operators bearing costs of greening bus fleet',
        'Existing assumptions': 50,
        'Source': '',
        'User assumptions': 50,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Businesses share of flight transport costs',
        'Existing assumptions': 75,
        'Source': 'https://www.travelnews.se/ekonomi/ett-allt-dyrare-affarsflyg-aterhamtar-sig-forst-2026/',
        'User assumptions': 75,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Aviation revenue per year in Sweden',
        'Existing assumptions': 27,
        'Source': 'https://www.statista.com/statistics/801172/market-share-of-international-airlines-in-sweden/ and page 104 of: https://www.sasgroup.net/files/Main/290/3701838/sas-annual-and-sustainability-report-fy-2022.pdf',
        'User assumptions': 27,
        'User source': '',
        'Units': 'Billion SEK'
    },
    {
        'Factor': 'Cost increase of RME/HVO/biogas compared to diesel in buses',
        'Existing assumptions': 10,
        'Source': 'https://energikontorsydost.se/l/kunskapsbank/56548?',
        'User assumptions': 10,
        'User source': '',
        'Units': '%'
    },

    {
        'Factor': 'Average purchase price of electric car in start year',
        'Existing assumptions': 479000,
        'Source': 'https://www.mynewsdesk.com/se/blocket/pressreleases/priset-paa-elbilar-fortsaetter-skena-upp-40-procent-2022-3180265',
        'User assumptions': 479000,
        'User source': '',
        'Units': 'SEK'
    },
    {
        'Factor': 'Cycle path cost per built kilometer',
        'Existing assumptions': 219500,
        'Source': 'Cycling infrastructure - https://assets.publishing.service.gov.uk/government/uploads/system/uploads/attachment_data/file/742451/typical-costings-for-ambitious-cycling-schemes.pdf',
        'User assumptions': 219500,
        'User source': '',
        'Units': 'SEK'
    },
    {
        'Factor': 'Average purchase price of plug in hybrid car',
        'Existing assumptions': 14256000,
        'Source': 'https://www.mynewsdesk.com/se/blocket/pressreleases/priset-paa-elbilar-slaar-nya-rekord-upp-55-procent-under-2022-3193436',
        'User assumptions': 14256000,
        'User source': '',
        'Units': 'SEK'
    },
    {
        'Factor': 'Residential Electric Car Charger investment cost',
        'Existing assumptions': 299000,
        'Source': 'Talluri et al 2019 and https://chargestorm.se/en/products/chargestorm-connected-2/',
        'User assumptions': 299000,
        'User source': '',
        'Units': 'SEK'
    },
    {
        'Factor': 'Average purchase price of hydrogen car',
        'Existing assumptions': 9734,
        'Source': 'https://theicct.org/publication/lca-ghg-emissions-hdv-fuels-europe-feb23/',
        'User assumptions': 9734,
        'User source': '',
        'Units': 'SEK'
    },
    {
        'Factor': 'Infrastructure per hydrogen car',
        'Existing assumptions': 556079,
        'Source': 'Hydrogen Roadmap Europe: A sustainable pathway for the european energy transition.',
        'User assumptions': 556079,
        'User source': '',
        'Units': 'SEK'
    },
    {
        'Factor': 'Average purchase price of fossil fueled light truck',
        'Existing assumptions': 45360,
        'Source': 'https://www.iea.org/data-and-statistics/data-tools/electric-vehicles-total-cost-of-ownership-tool',
        'User assumptions': 45360,
        'User source': '',
        'Units': 'SEK'
    },
    {
        'Factor': 'Average purchase price of electric light truck',
        'Existing assumptions': 275541,
        'Source': 'https://blogg.loyds.no/loydsguiden/utbutet-av-eldrivna-latta-lastbilar-2022',
        'User assumptions': 275541,
        'User source': '',
        'Units': 'SEK'
    },
    {
        'Factor': 'Average purchase price of biogas light truck',
        'Existing assumptions': 398462,
        'Source': 'https://www.iea.org/data-and-statistics/data-tools/electric-vehicles-total-cost-of-ownership-tool',
        'User assumptions': 398462,
        'User source': '',
        'Units': 'SEK'
    },
    {
        'Factor': 'Price of biogas heavy truck',
        'Existing assumptions': 275541.3821,
        'Source': 'Takman et al. (2021)',
        'User assumptions': 275541.3821,
        'User source': '',
        'Units': 'SEK'
    },
    {
        'Factor': 'Price of electric heavy truck',
        'Existing assumptions': 7620237.834,
        'Source': 'https://www.ttnews.com/articles/doe-outlines-higher-upfront-costs-green-heavy-trucks',
        'User assumptions': 7620237.834,
        'User source': '',
        'Units': 'SEK'
    },
    {
        'Factor': 'Price of fossil fueled heavy truck',
        'Existing assumptions': 2664418.823,
        'Source': 'Takman et al. (2021)',
        'User assumptions': 2664418.823,
        'User source': '',
        'Units': 'SEK'
    },
    {
        'Factor': 'Price of electric bus',
        'Existing assumptions': 5922300,
        'Source': 'Bloomberg New Energy Finance: https://assets.bbhub.io/professional/sites/24/2018/05/Electric-Buses-in-Cities-Report-BNEF-C40-Citi.pdf',
        'User assumptions': 5922300,
        'User source': '',
        'Units': 'SEK'
    },
    {
        'Factor': 'Price of renewable bus (HVO, RME, biogas)',
        'Existing assumptions': 4675500,
        'Source': 'Bloomberg New Energy Finance: https://assets.bbhub.io/professional/sites/24/2018/05/Electric-Buses-in-Cities-Report-BNEF-C40-Citi.pdf',
        'User assumptions': 4675500,
        'User source': '',
        'Units': 'SEK'
    },
    {
        'Factor': 'Price of fossil fueled bus',
        'Existing assumptions': 4675500,
        'Source': 'Bloomberg New Energy Finance: https://assets.bbhub.io/professional/sites/24/2018/05/Electric-Buses-in-Cities-Report-BNEF-C40-Citi.pdf',
        'User assumptions': 4675500,
        'User source': '',
        'Units': 'SEK'
    },
    {
        'Factor': 'Emission factor from electricity production Sweden',
        'Existing assumptions': 20,
        'Source': 'https://www.uniper.energy/sv/sverige/om-uniper-i-sverige/ett-elsystem-i-balans/el-och-klimat',
        'User assumptions': 20,
        'User source': '',
        'Units': 'g/KWh'
    },
    {
        'Factor': 'Average ETS price in 2022',
        'Existing assumptions': 80.32,
        'Source': 'https://www.umweltbundesamt.de/en/press/pressinformation/emissions-trading-rings-up-record-revenues-more',
        'User assumptions': 80.32,
        'User source': '',
        'Units': 'euros'
    },
    {
        'Factor': 'W to Wh conversion',
        'Existing assumptions': 2747.459769,
        'Source': 'Based on internal SEI clean energy MACC calculations',
        'User assumptions': 2747.459769,
        'User source': '',
        'Units': 'Wh/W'
    },
    {
        'Factor': 'W to Wh conversion solar',
        'Existing assumptions': 986.1495845,
        'Source': 'Based on internal SEI clean energy MACC calculations',
        'User assumptions': 986.1495845,
        'User source': '',
        'Units': 'Wh/W'
    },
    {
        'Factor': 'Share of district heating covered by heat pumps from air',
        'Existing assumptions': 33.33,
        'Source': '',
        'User assumptions': 33.33,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Share of district heating covered by heat pumps from water',
        'Existing assumptions': 33.33,
        'Source': '',
        'User assumptions': 33.33,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Share of district heating covered by heat pumps from geothermal',
        'Existing assumptions': 33.33,
        'Source': '',
        'User assumptions': 33.33,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Air heat pump emissions saving',
        'Existing assumptions': 100,
        'Source': 'https://värmepumpen.se/en/byta-varmepump/#1551341900387-c6b9fb75-2364',
        'User assumptions': 100,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Water heat pump emissions saving',
        'Existing assumptions': 100,
        'Source': 'https://värmepumpen.se/en/byta-varmepump/#1551341900387-c6b9fb75-2365',
        'User assumptions': 100,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Geothermal heat pump emissions saving',
        'Existing assumptions': 100,
        'Source': 'https://värmepumpen.se/en/byta-varmepump/#1551341900387-c6b9fb75-2366',
        'User assumptions': 100,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Public utility companies bearing share of green energy production costs',
        'Existing assumptions': 50,
        'Source': 'SEIs assumption',
        'User assumptions': 50,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Share of rooftop solar panels invested in by households',
        'Existing assumptions': 60,
        'Source': 'SEIs assumption',
        'User assumptions': 60,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Share of rooftop solar panels invested in by industry',
        'Existing assumptions': 20,
        'Source': 'SEIs assumption',
        'User assumptions': 20,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Share of rooftop solar panels invested in by municipal government',
        'Existing assumptions': 20,
        'Source': 'SEIs assumption',
        'User assumptions': 20,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'OPEX share of CAPEX of LCOE for wind energy',
        'Existing assumptions': 20.483871,
        'Source': 'https://www.lazard.com/research-insights/2023-levelized-cost-of-energyplus/',
        'User assumptions': 20.483871,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'OPEX share of CAPEX of LCOE for solar centralised',
        'Existing assumptions': 13.6134454,
        'Source': 'https://www.lazard.com/research-insights/2023-levelized-cost-of-energyplus/',
        'User assumptions': 13.6134454,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'OPEX share of CAPEX of LCOE for solar rooftop',
        'Existing assumptions': 67.403807,
        'Source': 'https://www.lazard.com/research-insights/2023-levelized-cost-of-energyplus/',
        'User assumptions':  67.403807,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Wind power plant cost per kWh',
        'Existing assumptions': 5.265432281,
        'Source': 'Based on internal SEI clean energy MACC calculations',
        'User assumptions': 5.265432281,
        'User source': '',
        'Units': 'SEK/kWh'
    },
    {
        'Factor': 'Central solar power plant cost per kWh',
        'Existing assumptions': 8.869326727,
        'Source': 'Based on internal SEI clean energy MACC calculations',
        'User assumptions': 8.869326727,
        'User source': '',
        'Units': 'SEK/kWh'
    },
    {
        'Factor': 'Rooftop solar power cost per kWh',
        'Existing assumptions': 18.25671754,
        'Source': 'https://www.greenmatch.se/solceller',
        'User assumptions': 18.25671754,
        'User source': '',
        'Units': 'SEK/kWh'
    },
    {
        'Factor': 'Heat pump air capex',
        'Existing assumptions': 650,
        'Source': 'Values provided by Gren Tartu (DH company in Estonia). Values used in HC project 2022, SEI Tallinn',
        'User assumptions': 650,
        'User source': '',
        'Units': 'EUR/kW'
    },
    {
        'Factor': 'Heat pump water capex',
        'Existing assumptions': 650,
        'Source': 'Values provided by Gren Tartu (DH company in Estonia). Values used in HC project 2022, SEI Tallinn',
        'User assumptions': 650,
        'User source': '',
        'Units': 'EUR/kW'
    },
    {
        'Factor': 'Heat pump geothermal capex',
        'Existing assumptions': 2300,
        'Source': 'Values provided by Gren Tartu (DH company in Estonia). Values used in HC project 2022, SEI Tallinn',
        'User assumptions': 2300,
        'User source': '',
        'Units': 'EUR/kW'
    },
    {
        'Factor': 'District heating full load hours per year',
        'Existing assumptions': 3000,
        'Source': '',
        'User assumptions': 3000,
        'User source': '',
        'Units': 'Hours'
    },
    {
        'Factor': 'Emission factor from heat production',
        'Existing assumptions': 122,
        'Source': 'Based on internal SEI internal data',
        'User assumptions': 122,
        'User source': '',
        'Units': 'g/kWh'
    },
    {
        'Factor': 'OPEX share of capex for heat pumps',
        'Existing assumptions': 1,
        'Source': '',
        'User assumptions': 1,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': '2030 price compared to current costs of solar energy',
        'Existing assumptions': 100,
        'Source': '',
        'User assumptions': 100,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': '2030 price compared to current costs of wind energy',
        'Existing assumptions': 100,
        'Source': '',
        'User assumptions': 100,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Impact from BAT appliances on energy savings',
        'Existing assumptions': 20.7483,
        'Source': '(Savvidou and Nykvist, 2020)',
        'User assumptions': 20.7483,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Impact from reduced temperature to 20 degrees on energy savings',
        'Existing assumptions': 16,
        'Source': '(Savvidou and Nykvist, 2020)',
        'User assumptions': 16,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Impact from Savvidou Nykvist measures on energy savings',
        'Existing assumptions': 17,
        'Source': '(Savvidou and Nykvist, 2020)',
        'User assumptions': 17,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'CAPEX for BAT investments',
        'Existing assumptions': 82857,
        'Source': '(Dodoo et al., 2017a), (Dodoo et al., 2017b), (Dodoo et al., 2018)',
        'User assumptions': 82857,
        'User source': '',
        'Units': 'SEK'
    },
    {
        'Factor': 'Energy consumption for apartment building',
        'Existing assumptions': 3500,
        'Source': 'https://www.energimarknadsbyran.se/el/dina-avtal-och-kostnader/elkostnader/elforbrukning/normal-elforbrukning-och-elkostnad-for-lagenhet/',
        'User assumptions': 3500,
        'User source': '',
        'Units': 'kWh/year'
    },
    {
        'Factor': 'Energy consumption for house',
        'Existing assumptions': 8000,
        'Source': 'https://www.energimarknadsbyran.se/el/dina-avtal-och-kostnader/elkostnader/elforbrukning/normal-elforbrukning-och-elkostnad-for-villa/ https://www.energimyndigheten.se/nyhetsarkiv/2020/ny-statistik-over-energianvandningen-i-smahus-flerbostadshus-och-lokaler/',
        'User assumptions': 8000,
        'User source': '',
        'Units': 'kWh/year'
    },
    {
        'Factor': 'Energy cost per year in municipality',
        'Existing assumptions': 4470,
        'Source': 'SCB',
        'User assumptions': 4470,
        'User source': '',
        'Units': 'SEK/year'
    },
    {
        'Factor': 'Single dwelling savings of energy of reduced indoor temperature below 20 degrees',
        'Existing assumptions': 21,
        'Source': '(Savvidou and Nykvist, 2020)',
        'User assumptions': 21,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Multiple dwelling savings of energy of reduced indoor temperature below 20 degrees',
        'Existing assumptions': 27,
        'Source': '(Savvidou and Nykvist, 2020)',
        'User assumptions': 27,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'CAPEX of implementing SN measures',
        'Existing assumptions': 3413,
        'Source': '(Savvidou and Nykvist, 2020)',
        'User assumptions': 3413,
        'User source': '',
        'Units': 'SEK'
    },
    {
        'Factor': 'Share of city landfill site waste coming from the same city',
        'Existing assumptions': 100,
        'Source': '',
        'User assumptions': 100,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Share of agricultural emissions related to methane',
        'Existing assumptions': 53,
        'Source': '(https://www.naturvardsverket.se/data-och-statistik/klimat/vaxthusgaser-utslapp-fran-jordbruk/)',
        'User assumptions': 53,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'CCS captures share of emissions',
        'Existing assumptions': 90,
        'Source': 'https://climate.mit.edu/ask-mit/how-efficient-carbon-capture-and-storage',
        'User assumptions': 90,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Fossil-free share of electricity mix used in city',
        'Existing assumptions': 100,
        'Source': 'https://www.scb.se/hitta-statistik/sverige-i-siffror/miljo/elektricitet-i-sverige/',
        'User assumptions': 100,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Income per collected ton of CO2e per ton',
        'Existing assumptions': 0,
        'Source': '',
        'User assumptions': 0,
        'User source': '',
        'Units': ''
    },
    {
        'Factor': 'Share of emissions reduced by hydrogen industry',
        'Existing assumptions': 100,
        'Source': '',
        'User assumptions': 100,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Abatement cost of hydrogen per ton of CO2e removed',
        'Existing assumptions': 937.5,
        'Source': 'https://ceepr.mit.edu/wp-content/uploads/2022/11/2022-017.pdf',
        'User assumptions': 937.5,
        'User source': '',
        'Units': 'Eur/ton CO2e'
    },
    {
        'Factor': 'Share of Carbon Credits counted towards negative emissions in net zero target',
        'Existing assumptions': 100,
        'Source': '',
        'User assumptions': 100,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Share of bio-CCS counted towards negative emissions in net zero target',
        'Existing assumptions': 100,
        'Source': '',
        'User assumptions': 100,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Share of rewetting counted towards negative emissions in net zero target',
        'Existing assumptions': 100,
        'Source': '',
        'User assumptions': 100,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Share of rewetting paid for by agricultural industry',
        'Existing assumptions': 50,
        'Source': 'SEIs assumption',
        'User assumptions': 50,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Share of rewetting paid for by superordinate government',
        'Existing assumptions': 25,
        'Source': 'SEIs assumption',
        'User assumptions': 25,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Share of rewetting paid for by municipal government',
        'Existing assumptions': 25,
        'Source': 'SEIs assumption',
        'User assumptions': 25,
        'User source': '',
        'Units': '%'
    },

    {
        'Factor': 'Average cost of BECCS',
        'Existing assumptions': 120.25,
        'Source': 'https://www.stockholmexergi.se/content/uploads/2022/02/BECCS-Economics-Sweden-final.pdf',
        'User assumptions': 120.25,
        'User source': '',
        'Units': 'Eur/ton CO2e removed'
    },
    {
        'Factor': 'Average cost of DACCS',
        'Existing assumptions': 398.5,
        'Source': 'https://www.stockholmexergi.se/content/uploads/2022/02/BECCS-Economics-Sweden-final.pdf',
        'User assumptions': 398.5,
        'User source': '',
        'Units': 'Eur/ton CO2e removed'
    },
    {
        'Factor': 'Share of negative emission tech related to BECCS (and not DACCS)',
        'Existing assumptions': 100,
        'Source': '',
        'User assumptions': 100,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Share of BECCS costs related to opex on annual basis',
        'Existing assumptions': 2,
        'Source': 'https://www.stockholmexergi.se/content/uploads/2022/02/BECCS-Economics-Sweden-final.pdf',
        'User assumptions': 2,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Operating cost CCS per captured ton of CO2',
        'Existing assumptions': 799.47,
        'Source': 'Skagestad et al. 2014',
        'User assumptions': 799.47,
        'User source': '',
        'Units': 'SEK'
    },
    {
        'Factor': 'Capital cost of CCS per ton',
        'Existing assumptions': 3997.35,
        'Source': 'Skagestad et al. 2014',
        'User assumptions': 3997.35,
        'User source': '',
        'Units': 'SEK'
    },
    {
        'Factor': '2030 price compared to current costs of bio-CCS',
        'Existing assumptions': 100,
        'Source': 'Conservative approach assuming no cost reduction, up to user to change',
        'User assumptions': 100,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Share of rewetting paid for by industry',
        'Existing assumptions': 20,
        'Source': 'SEIs assumption',
        'User assumptions': 20,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Share of rewetting paid for by superordinate government',
        'Existing assumptions': 25,
        'Source': 'SEIs assumption',
        'User assumptions': 25,
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Cost per ton of carbon credit compensation',
        'Existing assumptions': 623.4,
        'Source': 'https://8billiontrees.com/carbon-offsets-credits/carbon-credit-price-per-ton/',
        'User assumptions': 623.4,
        'User source': '',
        'Units': 'Eur/ton CO2e'
    },
    {
        'Factor': 'Investment cost of rewetting wetlands in lake or agricultural area',
        'Existing assumptions': 965,
        'Source': 'https://www2.jordbruksverket.se/download/18.398404781668c84d6edeac8c/1540291633301/ra18_30.pdf',
        'User assumptions': 965,
        'User source': '',
        'Units': 'SEK/tonCO2e'
    },

    {
        'Factor': 'Investment cost of rewetting wetlands in forest',
        'Existing assumptions': 698,
        'Source': 'https://www2.jordbruksverket.se/download/18.398404781668c84d6edeac8c/1540291633301/ra18_30.pdf',
        'User assumptions': 698,
        'User source': '',
        'Units': 'SEK/tonCO2e'
    },
    {
        'Factor': 'Operating cost of rewetting wetlands in lake or agricultural area',
        'Existing assumptions': 351,
        'Source': 'https://www2.jordbruksverket.se/download/18.398404781668c84d6edeac8c/1540291633301/ra18_30.pdf',
        'User assumptions': 351,
        'User source': '',
        'Units': 'SEK/tonCO2e'
    },
    {
        'Factor': 'Operating cost of rewetting wetlands in forest',
        'Existing assumptions': 508,
        'Source': 'https://www2.jordbruksverket.se/download/18.398404781668c84d6edeac8c/1540291633301/ra18_30.pdf',
        'User assumptions': 508,
        'User source': '',
        'Units': 'SEK/tonCO2e'
    },
    {
        'Factor': 'Income of rewetting wetlands in lake or agricultural area',
        'Existing assumptions': '-',
        'Source': '',
        'User assumptions': '-',
        'User source': '',
        'Units': 'SEK/tonCO2e'
    },
    {
        'Factor': 'Income of rewetting wetlands in forest',
        'Existing assumptions': '-',
        'Source': '',
        'User assumptions': '',
        'User source': '-',
        'Units': 'SEK/tonCO2e'
    },
    {
        'Factor': 'Share of rewetting in forest land (compared to all e.g. lake or agricultural land)',
        'Existing assumptions': '33',
        'Source': 'https://www2.jordbruksverket.se/download/18.398404781668c84d6edeac8c/1540291633301/ra18_30.pdf',
        'User assumptions': '33',
        'User source': '',
        'Units': '%'
    },
    {
        'Factor': 'Average investment cost of agricultural measure per reduced tCO2e',
        'Existing assumptions': 5804,
        'Source': 'https://www.naturvardsverket.se/amnesomraden/klimatomstallningen/klimatklivet/resultat-i-olika-branscher-2022/',
        'User assumptions': 5804,
        'User source': '',
        'Units': 'SEK/tonCO2e'
    },
    {
        'Factor': 'Average OPEX of agricultural measure per reduced tCO2e',
        'Existing assumptions': '-',
        'Source': '',
        'User assumptions': '-',
        'User source': '',
        'Units': 'SEK/tonCO2e'
    },
    {
        'Factor': 'Average income of agricultural measure per reduced tCO2e',
        'Existing assumptions': '-',
        'Source': '',
        'User assumptions': '-',
        'User source': '',
        'Units': 'SEK/tonCO2e'
    },
    {
        'Factor': 'Average saving of agricultural measure per reduced tCO2e',
        'Existing assumptions': '-',
        'Source': '',
        'User assumptions': '-',
        'User source': '',
        'Units': 'SEK/tonCO2e'
    },
    {
        'Factor': 'Average investment cost of work machine measure per reduced tCO2e',
        'Existing assumptions': 4831,
        'Source': 'Using vehicle numbers from Klimatklivet for now. https://www.naturvardsverket.se/499452/globalassets/amnen/klimat/klimatklivet/lagesbeskrivning-for-klimatklivet-2023-04-13.pdf',
        'User assumptions': 4831,
        'User source': '',
        'Units': 'SEK/tonCO2e'
    },
    {
        'Factor': 'Average OPEX of work machine measure per reduced tCO2e',
        'Existing assumptions': '-',
        'Source': '',
        'User assumptions': '-',
        'User source': '',
        'Units': 'SEK/tonCO2e'
    },
    {
        'Factor': 'Average income of work machine measure per reduced tCO2e',
        'Existing assumptions': '-',
        'Source': '',
        'User assumptions': '-',
        'User source': '',
        'Units': 'SEK/tonCO2e'
    },
    {
        'Factor': 'Average saving of work machine measure per reduced tCO2e',
        'Existing assumptions': '-',
        'Source': '',
        'User assumptions': '-',
        'User source': '',
        'Units': 'SEK/tonCO2e'
    }
]

def collapse_2():
    return html.Div([
        dbc.Row([
        dbc.Col([
        html.Div(
            [dbc.Button(
                "Food",
                id="food-collapse",
                n_clicks=0,
                title = "The food choices we make everyday impact our carbon footprints. Vegetarian and vegan diets can significantly contribute to reduced GHG emissions."
            ),
            dbc.Collapse(
            children=[
            html.P(
                id = "slider-text-1",
                children = "Share of people that will adopt a vegan diet (2030)"
                ),
            dcc.Slider(
                id = "slider-1",
                min = min(percentages),
                max = max(percentages),
                marks = {
                    str(perc): {
                        "label": str(perc),
                        }
                    for perc in percentages_5
                },
                tooltip = {
                    "placement": "bottom",
                    "always_visible": True}
                ),
            html.P(
                id = "slider-text-2",
                children = "Share of people that will adopt a vegetarian diet (2030)"
                ),
            dcc.Slider(
                id = "slider-2",
                min = min(percentages),
                max = max(percentages),
                marks = {
                    str(perc): {
                        "label": str(perc),
                        }
                    for perc in percentages_5
                },
                tooltip = {
                    "placement": "bottom",
                    "always_visible": True}
                ),
            html.P(
                id="slider-text-3",
                children="Share of people that will reduce meat consumption (2030)"
               ),
            dcc.Slider(
                id="slider-3",
                min=min(percentages),
                max=max(percentages),
                marks={
                    str(perc): {
                        "label": str(perc),
                    }
                    for perc in percentages_5
                },
                tooltip = {
                    "placement": "bottom",
                    "always_visible": True
                }
            ),
            html.P(
                id="slider-text-4",
                children="Share of people that will adopt a nutrition diet (according to Swedish Dietary Guidelines) (2030)"
            ),
            dcc.Slider(
                id="slider-4",
                min=min(percentages),
                max=max(percentages),
                marks={
                    str(perc): {
                        "label": str(perc),
                    }
                    for perc in percentages_5
                },
                tooltip={
                    "placement": "bottom",
                    "always_visible": True
                }
            ),
            html.P(
                id="slider-text-5",
                children="Share of people that will not change its diet (2030)"
            ),
            dcc.Slider(
                id="slider-5",
                min=min(percentages),
                max=max(percentages),
                marks={
                    str(perc): {
                        "label": str(perc),
                    }
                    for perc in percentages_5
                },
                tooltip={
                    "placement": "bottom",
                    "always_visible": True
                }
            ),
        ],
        id = "collapse-1",
        is_open = False),
        html.Div(
        [dbc.Button(
            "Clothing",
            id="clothing-collapse-button",
            n_clicks=0,
            title = "Fast fashion has led to a big increase in the quantity of clothers produced and thrown away. Clothes, footwear and hosehold textiles are responsible for water pollution, GHG emissions and landfill"),
        dbc.Collapse(
            id="clothing-collapse",
            children=[
                html.P(
                    id="slider-text-6",
                    children="Share of people that will reduce clothing consumption by 30% (2030)"
                ),
                dcc.Slider(
                    id="slider-6",
                    min=min(percentages),
                    max=max(percentages),
                    marks={
                        str(perc): {
                            "label": str(perc),
                        }
                        for perc in percentages_5
                    },
                    tooltip={
                        "placement": "bottom",
                        "always_visible": True
                    }
                ),
                html.P(
                    id="slider-text-7",
                    children="Share of people doubling the life of their garments"
                ),
                dcc.Slider(
                    id="slider-7",
                    min=min(percentages),
                    max=max(percentages),
                    marks={
                        str(perc): {
                            "label": str(perc)
                        }
                        for perc in percentages_5
                    },
                    tooltip={
                        "placement": "bottom",
                        "always_visible": True
                    }
                )
            ],
            is_open=False
        )
        ]),
        html.Div(
            [dbc.Button(
                "Housing",
                id="housing-collapse-button",
                n_clicks=0,
                title="Furniture consumption contributes to global warming due to its production processes and by reducing carbon uptake from forests"
            ),
            dbc.Collapse(
                id="housing-collapse",
                children=[
                    html.P(
                        id="slider-text-8",
                        children="Share of people that halves furniture consumption"
                    ),
                    dcc.Slider(
                        id="slider-8",
                        min=min(percentages),
                        max=max(percentages),
                        marks={
                            str(perc): {
                                "label": str(perc)
                            }
                            for perc in percentages_5
                        },
                        tooltip={
                            "placement": "bottom",
                            "always_visible": True
                        }
                    )
                ],
                is_open=False
            )]
        ),
        html.Div(
            [dbc.Button(
                "Transport services",
                id="transport-collapse-button",
                n_clicks=0,
                title="Transport services, whether of people or of goods, represent one of the main drivers of GHG emissions"
            ),
            dbc.Collapse(
                id="transport-collapse",
                children=[
                    html.P(
                        id="slider-text-9",
                        children="Share of electric public buses"
                    ),
                    dcc.Slider(
                       id="slider-9",
                       min=min(percentages),
                       max=max(percentages),
                       marks={
                            str(perc): {
                                "label": str(perc)
                            }
                            for perc in percentages_5
                        },
                       tooltip={
                            "placement": "bottom",
                            "always_visible": True
                        }
                    ),
                    html.P(
                        id="slider-text-10",
                        children="Share of public buses that runs on conventional HVO"
                    ),
                    dcc.Slider(
                        id="slider-10",
                        min=min(percentages),
                        max=max(percentages),
                        marks={
                            str(perc): {
                                "label": str(perc)
                            }
                            for perc in percentages_5
                        },
                        tooltip={
                            "placement": "bottom",
                            "always_visible": True
                        }
                    ),
                    html.P(
                        id="slider-text-11",
                        children="Share of buses that will continue to run on the current fuel mix"
                    ),
                    dcc.Slider(
                        id="slider-11",
                        min=min(percentages),
                        max=max(percentages),
                        marks={
                            str(perc): {
                                "label": str(perc)
                            }
                            for perc in percentages_5
                        },
                        tooltip={
                            "placement": "bottom",
                            "always_visible": True
                        }
                    ),
                    html.P(
                        id="slider-text-12",
                        children="Share of buses that will run on hybrid HVO"
                    ),
                    dcc.Slider(
                        id="slider-12",
                        min=min(percentages),
                        max=max(percentages),
                        marks={
                            str(perc): {
                                "label": str(perc)
                            }
                            for perc in percentages_5
                        },
                        tooltip={
                            "placement": "bottom",
                            "always_visible": True
                        }
                    )
                ]
                )
                ]
            ),
            html.Div(
                [dbc.Button(
                    "Air transport",
                    id="air-collapse-button",
                    n_clicks=0,
                    title="According to data, aviation is responsible for about 2.5% of global CO2 emissions, but its actual impact on climate change is much higher."),
                dbc.Collapse(
                    id="air-collapse",
                    children=[
                        html.P(
                            id="slider-text-13",
                            children="Reduction in air transport"
                        ),
                    dcc.Slider(
                        id="slider-13",
                        min=min(percentages),
                        max=max(percentages),
                        marks={
                            str(perc): {
                                "label": str(perc)
                            }
                            for perc in percentages_5
                        },
                        tooltip={
                            "placement": "bottom",
                            "always_visible": True
                        }
                    )
                    ]
                )]
            ),
            html.Div(
                [dbc.Button(
                    "Recreation",
                id="recreation-collapse-button",
                n_clicks=0,
                title="Recreational activities contribute, even if marginally, to GHG emissions. From a consumption-based emissions perspective, this is even more true when considering the emissions that are linked to production of the necessary equipment"),
                dbc.Collapse(
                    id="recreation-collapse",
                    children=[
                        html.P(
                            id="slider-text-14",
                            children="Share of people doubling the life of their recreation equipment"
                        ),
                    dcc.Slider(
                    id="slider-14",
                    min=min(percentages),
                    max=max(percentages),
                    marks={
                        str(perc): {
                            "label": str(perc)
                        }
                        for perc in percentages_5
                    },
                    tooltip={
                        "placement": "bottom",
                        "always_visible": True
                    }
                ),
                    html.P(
                        id="slider-text-15",
                        children="Share of people quitting using package holidays"
                    ),
                    dcc.Slider(
                        id="slider-15",
                        min=min(percentages),
                        max=max(percentages),
                        marks={
                            str(perc): {
                                "label": str(perc)
                            }
                            for perc in percentages_5
                        },
                        tooltip={
                            "placement": "bottom",
                            "always_visible": True
                        }
                    )
                    ]
                )]
            ),
            html.Div(
                [dbc.Button(
                    "Restaurants and hotels",
                    id="rh-collapse-button",
                    n_clicks=0,
                    title="Restaurants and hotels contribute to GHG emissions. In this sense, we mainly consider the emissions that can be saved by reducing food waste"
                ),
                dbc.Collapse(
                    id="rh-collapse",
                    children=[
                        html.P(
                            id="slider-text-16",
                            children="Share of catering service providers that is able to reach the potential reduction in waste that as identified by Erikkson et al. (2017)"
                        ),
                        dcc.Slider(
                            id="slider-16",
                            min=min(percentages),
                            max=max(percentages),
                            marks={
                                str(perc): {
                                    "label": str(perc)
                                }
                                for perc in percentages_5
                            },
                            tooltip={
                                "placement": "bottom",
                                "always_visible": True
                            }
                        )
                    ]
                )]
            ),
            html.Div(
                [dbc.Button(
                    "Vehicles",
                    id="vehicles-collapse-button",
                    n_clicks=0,
                    title = "Vehicles manufacturing and fuel use in private vehicles is the main sector of golobal GHG emissions"
                ),
                dbc.Collapse(
                    id="vehicles-collapse",
                    children=[
                        html.P(
                            id="slider-text-17",
                            children="Share of private cars that will be electrified"
                        ),
                    dcc.Slider(
                        id="slider-17",
                        min=min(percentages),
                        max=max(percentages),
                        marks={
                            str(perc): {
                                "label": str(perc)
                            }
                            for perc in percentages_5
                        },
                        tooltip={
                            "placement": "bottom",
                            "always_visible": True
                        }
                    ),
                        html.P(
                            id="slider-text-18",
                            children="Share of private cars that will be given up in favour of public transport"
                        ),
                    dcc.Slider(
                        id="slider-18",
                        min=min(percentages),
                        max=max(percentages),
                        marks={
                            str(perc): {
                                "label": str(perc)
                            }
                            for perc in percentages_5
                        },
                        tooltip={
                            "placement": "bottom",
                            "always_visible": True
                        }
                    ),
                        html.P(
                            id="slider-text-19",
                            children="Share of private cars that will still run on the current average fleet's fuel"
                        ),
                    dcc.Slider(
                        id="slider-19",
                        min=min(percentages),
                        max=max(percentages),
                        marks={
                            str(perc): {
                                "label": str(perc)
                            }
                            for perc in percentages_5
                        },
                        tooltip={
                            "placement": "bottom",
                            "always_visible": True
                        }
                    ),
                        html.P(
                            id="slider-text-20",
                            children="Share of plug-in-hybrid private cars"
                        ),
                    dcc.Slider(
                        id="slider-20",
                        min=min(percentages),
                        max=max(percentages),
                        marks={
                            str(perc): {
                                "label": str(perc)
                            }
                            for perc in percentages_5
                        },
                        tooltip={
                            "placement": "bottom",
                            "always_visible": True
                        }
                    ),
                        html.P(
                            id="slider-text-21",
                            children="Share of private cars that will run on hydrogen"
                        ),
                    dcc.Slider(
                        id="slider-21",
                        min=min(percentages),
                        max=max(percentages),
                        marks={
                            str(perc): {
                                "label": str(perc)
                            }
                            for perc in percentages_5
                        },
                        tooltip={
                            "placement": "bottom",
                            "always_visible": True
                        }
                    )
                    ]
                )]
            ),
            html.Div(
                [dbc.Button(
                    "Electricity",
                    id="electricity-collapse-button",
                    n_clicks=0,
                    title="The use of more energy-saving home appliances can contribute to a reduction of households' carbon footprint"
                ),
                dbc.Collapse(
                    id="electricity-collapse",
                    children=[
                        html.P(
                            id="slider-text-22",
                            children="Share of households that will be equipped with BAT major appliances"
                        ),
                    dcc.Slider(
                        id="slider-22",
                        min=min(percentages),
                        max=max(percentages),
                        marks={
                            str(perc): {
                                "label": str(perc)
                            }
                            for perc in percentages_5
                        },
                        tooltip={
                            "placement": "bottom",
                            "always_visible":  True
                        }
                    )
                    ]
                )]
            ),
            html.Div(
                [dbc.Button(
                    "District heating",
                    id="dh-collapse-button",
                    n_clicks=0,
                    title = "Reducing the share of heat that is produced using fossil fuels is the most effective way to guarantee a clear district heat supply"
                ),
                dbc.Collapse(
                    id="dh-collapse",
                    children=[
                        html.P(
                            id="slider-text-23",
                            children="Share of fossil fuel DH production that is shifted to wood pellets"
                        ),
                    dcc.Slider(
                        id="slider-23",
                        min=min(percentages),
                        max=max(percentages),
                        marks={
                            str(perc): {
                                "label": str(perc)
                            }
                            for perc in percentages_5
                        },
                        tooltip={
                            "placement": "bottom",
                            "always_visible": True
                        }
                    )
                    ]
                )]
            ),
            html.Div(
                [dbc.Button(
                    "House heating",
                    id="hh-collapse-button",
                    n_clicks=0,
                    title = "Better retrofitting and reduction of indoor temperature contribute to a lower heat demand and allow for this to be met only through sustainable fuels"
                ),
                dbc.Collapse(
                    id="hh-collapse",
                    children=[
                        html.P(
                            id="slider-text-24",
                            children="Share of households where indoor temperature is reduce to 20°C"
                        ),
                    dcc.Slider(
                        id="slider-24",
                        min=min(percentages),
                        max=max(percentages),
                        marks={
                            str(perc): {
                                "label": str(perc)
                            }
                            for perc in percentages_5
                        },
                        tooltip={
                            "placement": "bottom",
                            "always_visible": True
                        }
                    ),
                        html.P(
                            id="slider-text-25",
                            children="Share of households where no heating measure is implemented"
                        ),
                    dcc.Slider(
                        id="slider-25",
                        min=min(percentages),
                        max=max(percentages),
                        marks={
                            str(perc): {
                                "label": str(perc)
                            }
                            for perc in percentages_5
                        },
                        tooltip={
                            "placement": "bottom",
                            "always_visible": True
                        }
                    ),
                        html.P(
                            id="slider-text-26",
                            children="Share of households where the measures in Savvidou and Nykvist (2020) are implemented"
                        ),
                    dcc.Slider(
                        id="slider-26",
                        min=min(percentages),
                        max=max(percentages),
                        marks={
                            str(perc): {
                                "label": str(perc)
                            }
                            for perc in percentages_5
                        },
                        tooltip={
                            "placement": "bottom",
                            "always_visible": True
                        }
                    )
                    ]
                )]
            )], id="sliders-div")], width=2, id="col1"),
            dbc.Col([
                html.Div([
                    dcc.Tabs(value="graph-title", children=[
                    dcc.Tab(label="1. Climate Action Planning", id="graph-title", value="graph-title", className="db-titles", 
                            children=[
                    html.Div(
                        id="graph-space",
                        children=[
                    dcc.Graph(id="results-graph",
                              config={'displaylogo': False}
                              )]),
                    html.Div([
                        html.Button("Download Data", id="btn-download-emissions-cbe"),
                        dcc.Download(id="download-emissions-cbe-text"),
                        dcc.Store(id="dd-emissions-value1")], className="data-download-buttons")]),
                    dcc.Tab(label="2. Economic Model", id="investments-title-div", className="db-titles", children=[
                    html.Div(
                        id="cost-CBE-graph-div",
                        children=[
                            dcc.Graph(id="cost-CBE-graph", config={'displaylogo': False})]
                    ),
                html.Div(
                    id = "opex-CBE-graph-div",
                    children =[
                    dcc.Graph(id="opex-CBE-graph", config={'displaylogo': False})]
                ),
                html.Div(
                id="benefit1-CBE-graph-div",
                children=[
                dcc.Graph(id="benefit1-CBE-graph", config={'displaylogo': False})]
                ),
                html.Div(
                id="NPV-CBE-graph-div",
                children=[
                dcc.Graph(id="NPV-CBE-graph", config={'displaylogo': False})]
                ),
                html.Div(
                id="MACC-CBE-graph-div",
                children=[
                dcc.Graph(id="MACC", config={'displaylogo': False})]
                ),
                html.Br()]), 
                dcc.Tab(
                    label="3. Investment Scenarios", className="db-titles", id="db3", children=[
                    html.Div([
                    html.P(
                    "Please select a stakeholder:"
                    ),
                    dcc.Dropdown(
                    id="stakeholder1-dropdown-list",
                    options=["Citizens", "Public",
                    "Private sector", "Public utility companies", "Total"],
                    searchable=True,
                    placeholder="..."
                    )
                    ],id="Stakeholders1-dropdown"),
                    html.Div(
                    id="fundingcap-CBE-graph-div",
                    children=[
                    dcc.Graph(id="fundingcap-CBE-graph", config={'displaylogo': False})]
                    ),
                    html.Div(
                    id="fundingopp-CBE-graph-div",
                    children=[
                    dcc.Graph(id="fundingopp-CBE-graph", config={'displaylogo': False})]
                    ),
                    html.Br()]),
                    ]
                )],id="sidebar")], style={'width': '100%'} , id="col2")], id= "fig-row"),
                html.Hr(id="graphs-break"),
                html.Div([html.Img(
                            id="funders-img",
                            src="assets/funders-logo.png")], id="funders-space-1")
                            ], id="CBE-row-div")


def collapse_3():
    return dbc.Row([
        dbc.Col([
            html.Div(children=[
                dbc.Button(
                    "Agriculture (including food and land use)",
                    id="Agriculture-collapse-button",
                    n_clicks=0
                ),
                dbc.Collapse(
                    id="Agriculture-collapse",
                    is_open=False,
                    children=[
                        html.P(
                            id="slider-text-27",
                            children="Share of current emissions reduced in agriculture"
                        ),
                        dcc.Slider(
                            id="slider-27",
                            min=min(percentages),
                            max=max(percentages),
                            marks={
                                str(perc): {
                                    "label": str(perc)
                                }
                                for perc in percentages_5
                            },
                            tooltip={
                                "placement": "bottom",
                                "always_visible": True
                            }
                        ),

                        # Add more sliders for transport service if needed
                    ]
                ),

                html.Div(
                    children=
                    [dbc.Button(
                        "Consumption and Material use",
                        id="CMU-collapse-button",
                        n_clicks=0
                    ),
                        dbc.Collapse(
                            id="CMU-collapse",
                            is_open=False,
                            children=[
                                html.P(
                                    id="slider-text-28",
                                    children="Share of waste reduced by increased recycling and reuse"
                                ),
                                dcc.Slider(
                                    id="slider-28",
                                    min=min(percentages),
                                    max=max(percentages),
                                    marks={
                                        str(perc): {
                                            "label": str(perc)
                                        }
                                        for perc in percentages_5
                                    },
                                    tooltip={
                                        "placement": "bottom",
                                        "always_visible": True
                                    }
                                )]
                        )]),

                html.Div(children=[
                    dbc.Button(
                        "Transport",
                        id="Transport-collapse-TBE-button",
                        n_clicks=0
                    ),
                    dbc.Collapse(
                        id="Transport-collapse-TBE",
                        is_open=False,
                        children=[
                            dbc.Button(
                                "Buses",
                                id="transport-service-collapse-button",
                                n_clicks=0
                            ),
                            dbc.Collapse(
                                id="transport-service-collapse",
                                is_open=False,
                                children=[
                                    html.P(
                                        id="slider-text-29",
                                        children="Share of bus fleet in 2030 being electric"
                                    ),
                                    dcc.Slider(
                                        id="slider-29",
                                        min=min(percentages),
                                        max=max(percentages),
                                        marks={
                                            str(perc): {
                                                "label": str(perc)
                                            }
                                            for perc in percentages_5
                                        },
                                        tooltip={
                                            "placement": "bottom",
                                            "always_visible": True
                                        }
                                    ),

                                    html.P(
                                        id="slider-text-30",
                                        children="Share of bus fleet in 2030 being (e.g. HVO, RME, biogas)"
                                    ),
                                    html.Div([
                                        html.Label(('Start year of implementation'),
                                                   style={'font-size': '12px', 'color': 'white', 'text-align': 'right',
                                                          'margin-right': '10px', 'margin-left': '10px'}),
                                        dcc.Dropdown(
                                            id='RENB-input',
                                            options=[
                                                {'label': str(year), 'value': year} for year in range(2021, 2030)
                                            ],
                                            value=2021,  # Set the default year
                                            placeholder='Select a year',
                                            style={'font-size': '12px'}
                                        )
                                    ]),
                                    dcc.Slider(
                                        id="slider-30",
                                        min=min(percentages),
                                        max=max(percentages),
                                        marks={
                                            str(perc): {
                                                "label": str(perc)
                                            }
                                            for perc in percentages_5
                                        },
                                        tooltip={
                                            "placement": "bottom",
                                            "always_visible": True
                                        }
                                    ),
                                    html.P(
                                        id="slider-text-31",
                                        children="Share of buses in the current mix"
                                    ),
                                    dcc.Slider(
                                        id="slider-31",
                                        min=min(percentages),
                                        max=max(percentages),
                                        marks={
                                            str(perc): {
                                                "label": str(perc)
                                            }
                                            for perc in percentages_5
                                        },
                                        tooltip={
                                            "placement": "bottom",
                                            "always_visible": True
                                        }
                                    ),
                                    # Add more sliders for transport service if needed
                                ]
                            ),
                            html.Div(children=[
                                dbc.Button(
                                    "Air transport",
                                    id="air-transport-collapse-button",
                                    n_clicks=0
                                ),
                                dbc.Collapse(
                                    id="air-transport-collapse",
                                    is_open=False,
                                    children=[
                                        html.P(
                                            id="slider-text-32",
                                            children="Reduction in air travel consumption within city"
                                        ),
                                        html.Div([
                                            html.Label(('Start year of implementation'),
                                                       style={'font-size': '12px', 'color': 'white',
                                                              'text-align': 'right', 'margin-right': '10px',
                                                              'margin-left': '10px'}),
                                            dcc.Dropdown(
                                                id='AIT-input',
                                                options=[
                                                    {'label': str(year), 'value': year} for year in range(2021, 2030)
                                                ],
                                                value=2021,  # Set the default year
                                                placeholder='Select a year',
                                                style={'font-size': '12px'}
                                            )
                                        ]),
                                        dcc.Slider(
                                            id="slider-32",
                                            min=min(percentages),
                                            max=max(percentages),
                                            marks={
                                                str(perc): {
                                                    "label": str(perc)
                                                }
                                                for perc in percentages_5
                                            },
                                            tooltip={
                                                "placement": "bottom",
                                                "always_visible": True
                                            }
                                        ),
                                        # Add more sliders for air transport if needed
                                    ]
                                )
                            ]),
                            html.Div(
                                children=
                                [dbc.Button(
                                    "Cars",
                                    id="vehicles-cars-collapse-button",
                                    n_clicks=0
                                ),
                                    dbc.Collapse(
                                        id="vehicles-cars-collapse",
                                        is_open=False,
                                        children=[
                                            html.P(
                                                id="slider-text-33",
                                                children="Share of car fleet in 2030 being electric"
                                            ),
                                            dcc.Slider(
                                                id="slider-33",
                                                min=min(percentages),
                                                max=max(percentages),
                                                marks={
                                                    str(perc): {
                                                        "label": str(perc)
                                                    }
                                                    for perc in percentages_5
                                                },
                                                tooltip={
                                                    "placement": "bottom",
                                                    "always_visible": True
                                                }
                                            ),
                                            html.P(
                                                id="slider-text-34",
                                                children="Share of cars (current fleet) that will be given up for active transport (e.g. Walking and cycling)"
                                            ),
                                            html.Div([
                                                html.Label(('Start year of implementation'),
                                                           style={'font-size': '12px', 'color': 'white',
                                                                  'text-align': 'right', 'margin-right': '10px',
                                                                  'margin-left': '10px'}),
                                                dcc.Dropdown(
                                                    id='AT-input',
                                                    options=[
                                                        {'label': str(year), 'value': year} for year in
                                                        range(2021, 2030)
                                                    ],
                                                    value=2021,  # Set the default year
                                                    placeholder='Select a year',
                                                    style={'font-size': '12px'}
                                                )
                                            ]),
                                            dcc.Slider(
                                                id="slider-34",
                                                min=min(percentages),
                                                max=max(percentages),
                                                marks={
                                                    str(perc): {
                                                        "label": str(perc)
                                                    }
                                                    for perc in percentages_5
                                                },
                                                tooltip={
                                                    "placement": "bottom",
                                                    "always_visible": True
                                                }
                                            ),
                                            html.P(
                                                id="slider-text-35",
                                                children="Share of cars (current fleet) that will be given up in favour of public transport"
                                            ),
                                            html.Div([
                                                html.Label(('Start year of implementation'),
                                                           style={'font-size': '12px', 'color': 'white',
                                                                  'text-align': 'right', 'margin-right': '10px',
                                                                  'margin-left': '10px'}),
                                                dcc.Dropdown(
                                                    id='RC-input',
                                                    options=[
                                                        {'label': str(year), 'value': year} for year in
                                                        range(2021, 2030)
                                                    ],
                                                    value=2021,  # Set the default year
                                                    placeholder='Select a year',
                                                    style={'font-size': '12px'}
                                                )
                                            ]),
                                            dcc.Slider(
                                                id="slider-35",
                                                min=min(percentages),
                                                max=max(percentages),
                                                marks={
                                                    str(perc): {
                                                        "label": str(perc)
                                                    }
                                                    for perc in percentages_5
                                                },
                                                tooltip={
                                                    "placement": "bottom",
                                                    "always_visible": True
                                                }
                                            ),
                                            html.P(
                                                id="slider-text-36",
                                                children="Share of cars that will remain to the current private car fleet"
                                            ),
                                            dcc.Slider(
                                                id="slider-36",
                                                min=min(percentages),
                                                max=max(percentages),
                                                marks={
                                                    str(perc): {
                                                        "label": str(perc)
                                                    }
                                                    for perc in percentages_5
                                                },
                                                tooltip={
                                                    "placement": "bottom",
                                                    "always_visible": True
                                                }
                                            ),
                                            html.P(
                                                id="slider-text-37",
                                                children="Share of car fleet in 2030 being plug in hybrid electric"
                                            ),
                                            dcc.Slider(
                                                id="slider-37",
                                                min=min(percentages),
                                                max=max(percentages),
                                                marks={
                                                    str(perc): {
                                                        "label": str(perc)
                                                    }
                                                    for perc in percentages_5
                                                },
                                                tooltip={
                                                    "placement": "bottom",
                                                    "always_visible": True
                                                }
                                            ),
                                            html.P(
                                                id="slider-text-38",
                                                children="Share of car fleet in 2030 being hydrogen based"
                                            ),
                                            dcc.Slider(
                                                id="slider-38",
                                                min=min(percentages),
                                                max=max(percentages),
                                                marks={
                                                    str(perc): {
                                                        "label": str(perc)
                                                    }
                                                    for perc in percentages_5
                                                },
                                                tooltip={
                                                    "placement": "bottom",
                                                    "always_visible": True
                                                }
                                            )
                                        ]),
                                    html.Div(
                                        children=[
                                            dbc.Button(
                                                "Heavy trucks",
                                                id="heavy-collapse-button",
                                            ),
                                            dbc.Collapse(
                                                id="heavy-collapse",
                                                is_open=False,
                                                children=[
                                                    html.P(
                                                        id="slider-text-39",
                                                        children="Share of heavy truck fleet in 2030 being biogas driven"
                                                    ),
                                                    dcc.Slider(
                                                        id="slider-39",
                                                        min=min(percentages),
                                                        max=max(percentages),
                                                        marks={
                                                            str(perc): {
                                                                "label": str(perc)
                                                            }
                                                            for perc in percentages_5
                                                        },
                                                        tooltip={
                                                            "placement": "bottom",
                                                            "always_visible": True
                                                        }
                                                    ),
                                                    html.P(
                                                        id="slider-text-40",
                                                        children="Share of heavy truck fleet in 2030 being electric"
                                                    ),
                                                    dcc.Slider(
                                                        id="slider-40",
                                                        min=min(percentages),
                                                        max=max(percentages),
                                                        marks={
                                                            str(perc): {
                                                                "label": str(perc)
                                                            }
                                                            for perc in percentages_5
                                                        },
                                                        tooltip={
                                                            "placement": "bottom",
                                                            "always_visible": True
                                                        }
                                                    )
                                                ])]
                                    ),
                                    html.Div(
                                        children=[
                                            dbc.Button(
                                                "Light trucks",
                                                id="LT-collapse-button",
                                            ),
                                            dbc.Collapse(
                                                id="LT-collapse",
                                                is_open=False,
                                                children=[
                                                    html.P(
                                                        id="slider-text-41",
                                                        children="Share of light truck fleet in 2030 being biogas driven"
                                                    ),
                                                    dcc.Slider(
                                                        id="slider-41",
                                                        min=min(percentages),
                                                        max=max(percentages),
                                                        marks={
                                                            str(perc): {
                                                                "label": str(perc)
                                                            }
                                                            for perc in percentages_5
                                                        },
                                                        tooltip={
                                                            "placement": "bottom",
                                                            "always_visible": True
                                                        }
                                                    ),
                                                    html.P(
                                                        id="slider-text-42",
                                                        children="Share of light truck fleet in 2030 being electric"
                                                    ),
                                                    dcc.Slider(
                                                        id="slider-42",
                                                        min=min(percentages),
                                                        max=max(percentages),
                                                        marks={
                                                            str(perc): {
                                                                "label": str(perc)
                                                            }
                                                            for perc in percentages_5
                                                        },
                                                        tooltip={
                                                            "placement": "bottom",
                                                            "always_visible": True
                                                        }
                                                    )
                                                ])]),
                                ]
                            ),
                        ]
                    ),
                ]),

                html.Div(
                    children=[dbc.Button(
                        "Energy",
                        id="Energy-TBE-button",
                        n_clicks=0
                    ),
                        dbc.Collapse(
                            id="Energy-collapse-TBE",
                            is_open=False,
                            children=[
                                dbc.Button(
                                    "CCS waste",
                                    id="ccsw-collapse-button",
                                    n_clicks=0
                                ),
                                dbc.Collapse(
                                    id="ccsw-collapse",
                                    is_open=False,
                                    children=[
                                        html.P(
                                            id="slider-text-43",
                                            children="Share of current waste and energy emissions reduced by 2030 with CCS"
                                        ),
                                        html.Div([
                                            html.Label(('Start year of implementation'),
                                                       style={'font-size': '12px', 'color': 'white',
                                                              'text-align': 'right', 'margin-right': '10px',
                                                              'margin-left': '10px'}),
                                            dcc.Dropdown(
                                                id='CCSW-input',
                                                options=[
                                                    {'label': str(year), 'value': year} for year in range(2021, 2030)
                                                ],
                                                value=2021,  # Set the default year
                                                placeholder='Select a year',
                                                style={'font-size': '12px'}
                                            )
                                        ]),
                                        dcc.Slider(
                                            id="slider-43",
                                            min=min(percentages),
                                            max=max(percentages),
                                            marks={
                                                str(perc): {
                                                    "label": str(perc)
                                                }
                                                for perc in percentages_5
                                            },
                                            tooltip={
                                                "placement": "bottom",
                                                "always_visible": True
                                            }
                                        )
                                    ]),

                                html.Div(
                                    children=[
                                        dbc.Button(
                                            "Electricity production",
                                            id="Energy-collapse-button",
                                        ),
                                        dbc.Collapse(
                                            id="Energy-collapse",
                                            is_open=False,
                                            children=[
                                                html.P(
                                                    id="slider-text-44",
                                                    children="Share of fossil fueled electricity production replaced by wind"
                                                ),
                                                html.Div([
                                                    html.Label(('Start year of implementation'),
                                                               style={'font-size': '12px', 'color': 'white',
                                                                      'text-align': 'right', 'margin-right': '10px',
                                                                      'margin-left': '10px'}),
                                                    dcc.Dropdown(
                                                        id='W-input',
                                                        options=[
                                                            {'label': str(year), 'value': year} for year in
                                                            range(2021, 2030)
                                                        ],
                                                        value=2021,  # Set the default year
                                                        placeholder='Select a year',
                                                        style={'font-size': '12px'}
                                                    )
                                                ]),
                                                dcc.Slider(
                                                    id="slider-44",
                                                    min=min(percentages),
                                                    max=max(percentages),
                                                    marks={
                                                        str(perc): {
                                                            "label": str(perc)
                                                        }
                                                        for perc in percentages_5
                                                    },
                                                    tooltip={
                                                        "placement": "bottom",
                                                        "always_visible": True
                                                    }
                                                ),
                                                html.P(
                                                    id="slider-text-45",
                                                    children="Share of fossil fueled electricity production replaced by rooftop solar"
                                                ),
                                                html.Div([
                                                    html.Label(('Start year of implementation'),
                                                               style={'font-size': '12px', 'color': 'white',
                                                                      'text-align': 'right', 'margin-right': '10px',
                                                                      'margin-left': '10px'}),
                                                    dcc.Dropdown(
                                                        id='RS-input',
                                                        options=[
                                                            {'label': str(year), 'value': year} for year in
                                                            range(2021, 2030)
                                                        ],
                                                        value=2021,  # Set the default year
                                                        placeholder='Select a year',
                                                        style={'font-size': '12px'}
                                                    )
                                                ]),
                                                dcc.Slider(
                                                    id="slider-45",
                                                    min=min(percentages),
                                                    max=max(percentages),
                                                    marks={
                                                        str(perc): {
                                                            "label": str(perc)
                                                        }
                                                        for perc in percentages_5
                                                    },
                                                    tooltip={
                                                        "placement": "bottom",
                                                        "always_visible": True
                                                    }
                                                ),

                                                html.P(
                                                    id="slider-text-46",
                                                    children="Share of fossil fueled electricity production replaced by centralised solar"
                                                ),
                                                html.Div([
                                                    html.Label(('Start year of implementation'),
                                                               style={'font-size': '12px', 'color': 'white',
                                                                      'text-align': 'right', 'margin-right': '10px',
                                                                      'margin-left': '10px'}),
                                                    dcc.Dropdown(
                                                        id='CS-input',
                                                        options=[
                                                            {'label': str(year), 'value': year} for year in
                                                            range(2021, 2030)
                                                        ],
                                                        value=2021,  # Set the default year
                                                        placeholder='Select a year',
                                                        style={'font-size': '12px'}
                                                    )
                                                ]),
                                                dcc.Slider(
                                                    id="slider-46",
                                                    min=min(percentages),
                                                    max=max(percentages),
                                                    marks={
                                                        str(perc): {
                                                            "label": str(perc)
                                                        }
                                                        for perc in percentages_5
                                                    },
                                                    tooltip={
                                                        "placement": "bottom",
                                                        "always_visible": True
                                                    }
                                                ),
                                                html.P(
                                                    id="slider-text-47",
                                                    children="Share of existing energy production mix"
                                                ),
                                                dcc.Slider(
                                                    id="slider-47",
                                                    min=min(percentages),
                                                    max=max(percentages),
                                                    marks={
                                                        str(perc): {
                                                            "label": str(perc)
                                                        }
                                                        for perc in percentages_5
                                                    },
                                                    tooltip={
                                                        "placement": "bottom",
                                                        "always_visible": True
                                                    }
                                                )
                                            ]
                                        )]),
                                html.Div(
                                    children=[
                                        dbc.Button(
                                            "District heating",
                                            id="DH1-collapse-button",
                                        ),
                                        dbc.Collapse(
                                            id="DH1-collapse",
                                            is_open=False,
                                            children=[
                                                html.P(
                                                    id="slider-text-48",
                                                    children="Share of district heating covered by heat pumps"
                                                ),
                                                html.Div([
                                                    html.Label(('Start year of implementation'),
                                                               style={'font-size': '12px', 'color': 'white',
                                                                      'text-align': 'right', 'margin-right': '10px',
                                                                      'margin-left': '10px'}),
                                                    dcc.Dropdown(
                                                        id='DHP-input',
                                                        options=[
                                                            {'label': str(year), 'value': year} for year in
                                                            range(2021, 2030)
                                                        ],
                                                        value=2021,  # Set the default year
                                                        placeholder='Select a year',
                                                        style={'font-size': '12px'}
                                                    )
                                                ]),
                                                dcc.Slider(
                                                    id="slider-48",
                                                    min=min(percentages),
                                                    max=max(percentages),
                                                    marks={
                                                        str(perc): {
                                                            "label": str(perc)
                                                        }
                                                        for perc in percentages_5
                                                    },
                                                    tooltip={
                                                        "placement": "bottom",
                                                        "always_visible": True
                                                    }
                                                ),
                                            ]
                                        )]),

                            ]
                        ),

                        html.Div(
                            children=
                            [dbc.Button(
                                "The Built Environment",
                                id="buildingren-collapse-button",
                                n_clicks=0
                            ),
                                dbc.Collapse(
                                    id="buildingren-collapse",
                                    is_open=False,
                                    children=[
                                        html.P(
                                            id="slider-text-49",
                                            children="Squared meters by 2030 where indoor temperature is reduced to 20 C"
                                        ),
                                        dcc.Slider(
                                            id="slider-49",
                                            min=min(percentages),
                                            max=max(percentages),
                                            marks={
                                                str(perc): {
                                                    "label": str(perc)
                                                }
                                                for perc in percentages_5
                                            },
                                            tooltip={
                                                "placement": "bottom",
                                                "always_visible": True
                                            }
                                        ),
                                        html.P(
                                            id="slider-text-50",
                                            children="Squared meters by 2030 where the measures of reduced indoor temperature, water heating and retrofitting (Savvidou and Nykvist) are implemented"
                                        ),
                                        dcc.Slider(
                                            id="slider-50",
                                            min=min(percentages),
                                            max=max(percentages),
                                            marks={
                                                str(perc): {
                                                    "label": str(perc)
                                                }
                                                for perc in percentages_5
                                            },
                                            tooltip={
                                                "placement": "bottom",
                                                "always_visible": True
                                            }
                                        ),
                                        html.P(
                                            id="slider-text-51",
                                            children="Share of households that implement the best available technology household appliances measure "
                                        ),
                                        dcc.Slider(
                                            id="slider-51",
                                            min=min(percentages),
                                            max=max(percentages),
                                            marks={
                                                str(perc): {
                                                    "label": str(perc)
                                                }
                                                for perc in percentages_5
                                            },
                                            tooltip={
                                                "placement": "bottom",
                                                "always_visible": True
                                            }
                                        ),
                                        html.P(
                                            id="slider-text-52",
                                            children="Share of households where no heating measure is implemented"
                                        ),
                                        dcc.Slider(
                                            id="slider-52",
                                            min=min(percentages),
                                            max=max(percentages),
                                            marks={
                                                str(perc): {
                                                    "label": str(perc)
                                                }
                                                for perc in percentages_5
                                            },
                                            tooltip={
                                                "placement": "bottom",
                                                "always_visible": True
                                            }
                                        )
                                    ])]),

                        html.Div(
                            children=[
                                dbc.Button(
                                    "Industry",
                                    id="industry-collapse-button",
                                ),
                                dbc.Collapse(
                                    id="industry-collapse",
                                    is_open=False,
                                    children=[
                                        html.P(
                                            id="slider-text-53",
                                            children="Share of current industry production emissions reduced by 2030 with CCS"
                                        ),
                                        html.Div([
                                            html.Label(('Start year of implementation'),
                                                       style={'font-size': '12px', 'color': 'white',
                                                              'text-align': 'right', 'margin-right': '10px',
                                                              'margin-left': '10px'}),
                                            dcc.Dropdown(
                                                id='CCS-input',
                                                options=[
                                                    {'label': str(year), 'value': year} for year in range(2021, 2030)
                                                ],
                                                value=2026,  # Set the default year
                                                placeholder='Select a year',
                                                style={'font-size': '12px'}
                                            )
                                        ]),
                                        dcc.Slider(
                                            id="slider-53",
                                            min=min(percentages),
                                            max=max(percentages),
                                            marks={
                                                str(perc): {
                                                    "label": str(perc)
                                                }
                                                for perc in percentages_5
                                            },
                                            tooltip={
                                                "placement": "bottom",
                                                "always_visible": True
                                            }
                                        ),
                                        html.P(
                                            id="slider-text-54",
                                            children="Share of current industry emissions replaced with hydrogen production"
                                        ),
                                        html.Div([
                                            html.Label(('Start year of implementation'),
                                                       style={'font-size': '12px', 'color': 'white',
                                                              'text-align': 'right', 'margin-right': '10px',
                                                              'margin-left': '10px'}),
                                            dcc.Dropdown(
                                                id='Hyd-input',
                                                options=[
                                                    {'label': str(year), 'value': year} for year in range(2021, 2030)
                                                ],
                                                value=2021,  # Set the default year
                                                placeholder='Select a year',
                                                style={'font-size': '12px'}
                                            )
                                        ]),
                                        dcc.Slider(
                                            id="slider-54",
                                            min=min(percentages),
                                            max=max(percentages),
                                            marks={
                                                str(perc): {
                                                    "label": str(perc)
                                                }
                                                for perc in percentages_5
                                            },
                                            tooltip={
                                                "placement": "bottom",
                                                "always_visible": True
                                            }
                                        ),
                                        html.P(
                                            id="slider-text-541",
                                            children="Share of current work machinery emissions reduced by various measures"
                                        ),
                                        dcc.Slider(
                                            id="slider-541",
                                            min=min(percentages),
                                            max=max(percentages),
                                            marks={
                                                str(perc): {
                                                    "label": str(perc)
                                                }
                                                for perc in percentages_5
                                            },
                                            tooltip={
                                                "placement": "bottom",
                                                "always_visible": True
                                            }
                                        ),

                                    ]
                                )]),
                        html.Div(
                            children=[
                                dbc.Button(
                                    "Negative emission solutions",
                                    id="NET-collapse-button",
                                ),
                                dbc.Collapse(
                                    id="NET-collapse",
                                    is_open=False,
                                    children=[
                                        html.P(
                                            id="slider-text-55",
                                            children="Emissions avoided by bio-CCS or DACCS compared to city emissions (all sectors today)"
                                        ),
                                        html.Div([
                                            html.Label(('Start year of implementation'),
                                                       style={'font-size': '12px', 'color': 'white',
                                                              'text-align': 'right', 'margin-right': '10px',
                                                              'margin-left': '10px'}),
                                            dcc.Dropdown(
                                                id='Bioccs-input',
                                                options=[
                                                    {'label': str(year), 'value': year} for year in range(2021, 2030)
                                                ],
                                                value=2021,  # Set the default year
                                                placeholder='Select a year',
                                                style={'font-size': '12px'}
                                            )
                                        ]),
                                        dcc.Slider(
                                            id="slider-55",
                                            min=min(percentages),
                                            max=max(percentages),
                                            marks={
                                                str(perc): {
                                                    "label": str(perc)
                                                }
                                                for perc in percentages_5
                                            },
                                            tooltip={
                                                "placement": "bottom",
                                                "always_visible": True
                                            }
                                        ),
                                        html.P(
                                            id="slider-text-56",
                                            children="Emissions avoided by rewetting compared to city emissions (all sectors today)"
                                        ),
                                        html.Div([
                                            html.Label(('Start year of implementation'),
                                                       style={'font-size': '12px', 'color': 'white',
                                                              'text-align': 'right', 'margin-right': '10px',
                                                              'margin-left': '10px'}),
                                            dcc.Dropdown(
                                                id='RW-input',
                                                options=[
                                                    {'label': str(year), 'value': year} for year in range(2021, 2030)
                                                ],
                                                value=2021,  # Set the default year
                                                placeholder='Select a year',
                                                style={'font-size': '12px'}
                                            )
                                        ]),
                                        dcc.Slider(
                                            id="slider-56",
                                            min=min(percentages),
                                            max=max(percentages),
                                            marks={
                                                str(perc): {
                                                    "label": str(perc)
                                                }
                                                for perc in percentages_5
                                            },
                                            tooltip={
                                                "placement": "bottom",
                                                "always_visible": True
                                            }
                                        ),
                                        html.P(
                                            id="slider-text-57",
                                            children="Emissions avoided by compensation compared to city emissions (all sectors today)"
                                        ),
                                        html.Div([
                                            html.Label(('Start year of implementation'),
                                                       style={'font-size': '12px', 'color': 'white',
                                                              'text-align': 'right', 'margin-right': '10px',
                                                              'margin-left': '10px'}),
                                            dcc.Dropdown(
                                                id='CC-input',
                                                options=[
                                                    {'label': str(year), 'value': year} for year in range(2021, 2030)
                                                ],
                                                value=2021,  # Set the default year
                                                placeholder='Select a year',
                                                style={'font-size': '12px'}
                                            )
                                        ]),
                                        dcc.Slider(
                                            id="slider-57",
                                            min=min(percentages),
                                            max=max(percentages),
                                            marks={
                                                str(perc): {
                                                    "label": str(perc)
                                                }
                                                for perc in percentages_5
                                            },
                                            tooltip={
                                                "placement": "bottom",
                                                "always_visible": True
                                            }
                                        )
                                    ]
                                )]),
                    ], id="sliders-div-2")])], width=2, id="col1-2-1"),
        dbc.Col([
            html.Div([
                dcc.Tabs(id="db-tabs-2", value="graph-title-2", children=[
                    dcc.Tab(
                        label="0. Your data",
                        id="your-data-title-1",
                        value="your-data-title",
                        className="db-titles",
                        children=[
                            html.Div([
                                html.Label(('Full Name'),
                                           style={'font-size': '16px', 'font-weight': 'bold', 'color': 'black',
                                                  'text-align': 'right', 'margin-right': '10px',
                                                  'margin-left': '10px'}),
                                dcc.Input(
                                    id='full-name-input',
                                    type='text',
                                    placeholder='Enter your full name',
                                    style={'color': 'black'}
                                )
                            ]),
                            html.Div([
                                html.Label(('Organization'),
                                           style={'font-size': '16px', 'font-weight': 'bold', 'color': 'black',
                                                  'text-align': 'right', 'margin-right': '10px',
                                                  'margin-left': '10px'}),
                                dcc.Input(
                                    id='organization-input',
                                    type='text',
                                    placeholder='Enter your organization',
                                    style={'color': 'black'}
                                )
                            ]),
                            html.Div([
                                         dbc.Row([
                                             dbc.Col(
                                                 html.Div('Factor', style={'text-align': 'center', 'color': 'black'}),
                                                 width=2),
                                             dbc.Col(html.Div('Existing assumptions',
                                                              style={'text-align': 'center', 'color': 'black'}),
                                                     width=1),
                                             dbc.Col(
                                                 html.Div('Source', style={'text-align': 'center', 'color': 'black'}),
                                                 width=4),
                                             dbc.Col(html.Div('User assumptions',
                                                              style={'text-align': 'center', 'color': 'black'}),
                                                     width=1),
                                             dbc.Col(html.Div('User source',
                                                              style={'text-align': 'center', 'color': 'black'}),
                                                     width=3),
                                             dbc.Col(
                                                 html.Div('Units', style={'text-align': 'center', 'color': 'black'}),
                                                 width=1),
                                         ], style={'border': '0.2px solid black', 'width': '100%', 'display': 'flex',
                                                   'align-items': 'center', 'color': 'black', 'margin-top': '20px',
                                                   'padding': '10px', 'font-weight': 'bold'})
                                     ] + [
                                         dbc.Row([
                                             dbc.Col(html.Div(row['Factor'],
                                                              style={'text-align': 'center', 'color': 'black'}),
                                                     width=2),
                                             dbc.Col(html.Div(row['Existing assumptions'],
                                                              style={'text-align': 'center', 'color': 'black'}),
                                                     width=1),
                                             dbc.Col(html.Div(row['Source'],
                                                              style={'text-align': 'center', 'color': 'black'}),
                                                     width=4),
                                             dbc.Col(
                                                 dcc.Input(id={'type': 'user-assumptions', 'index': i}, type='number',
                                                           value=row['User assumptions'],
                                                           style={'text-align': 'center', 'color': 'black',
                                                                  'background-color': 'light gray',
                                                                  'border': 'light gray'}), width=1),
                                             dbc.Col(dcc.Input(id={'type': 'User source', 'index': i}, type='text',
                                                               value=row['User source'],
                                                               style={'text-align': 'center', 'color': 'black',
                                                                      'background-color': 'light gray',
                                                                      'border': 'light gray'}), width=3),
                                             dbc.Col(html.Div(row['Units'],
                                                              style={'text-align': 'center', 'color': 'black'}),
                                                     width=1), ],
                                             style={'border': '0.2px solid black', 'width': '100%', 'display': 'flex',
                                                    'align-items': 'center', 'padding': '10px'})
                                         for i, row in enumerate(Your_data)], style={'margin-left': '20px'}),
                            dcc.Store(id='data-saved-status'),  # Store component to store the data saved status
                            html.Div([
                                html.Button("Save Data", id="btn-save-own-data-tbe1")
                            ], className="data-download-buttons"),
                            dbc.Alert('The data has been successfully stored',
                                      id="popover_tbe1a",
                                      is_open=False,
                                      duration=6000,
                                      dismissable=True,
                                      style={"max-width": "200px", "border-radius": "8px", "position": "relative"},
                                      color='green',
                                      className="custom-alert",
                                      ),
                            dbc.Alert("Please enter all necessary information!",
                                      id="popover_tbe1b",
                                      is_open=False,
                                      duration=6000,
                                      dismissable=True,
                                      style={"max-width": "200px", "border-radius": "8px", "position": "relative"},
                                      color='red',
                                      className="custom-alert",
                                      ),
                            html.Div([
                                html.A('Download database template', id='download-link-2', href=download_mock_excel(),
                                       target='_blank',
                                       style={'display': 'block', 'margin-bottom': '10px', 'margin-left': '10px'}),
                                html.Label(
                                    'OR Please download the excel sheet by clicking the link and fill in your data and send it to the following mail address fedra.vanhuyse@sei.org',
                                    style={'font-size': '18px', 'color': 'black', 'margin-left': '10px',
                                           'margin-bottom': '10px'})
                            ], style={'margin-top': '20px'})
                        ]
                    ),
                    dcc.Tab(label="1. Climate Action Planning", id="graph-title-2", value="graph-title-2",
                            className="db-titles",
                            children=[
                                html.Div([
                                    html.P(
                                        "Please select a emission output:"
                                    ),
                                    dcc.Dropdown(
                                        id="emissions-dropdown-list",
                                        options=["Per capita emissions", "Municipality emissions"],
                                        searchable=True,
                                        placeholder="...."
                                    )
                                ], id="emissions-dropdown"),
                                html.Div(
                                    id="graph-space-2",
                                    children=[
                                        dcc.Graph(id="results-graph-2",
                                                  config={'displaylogo': False}
                                                  )]),
                                html.Div([
                                    html.Button("Download Data", id="btn-download-emissions-tbe"),
                                    dcc.Download(id="download-emissions-tbe-text"),
                                    dcc.Store(id="dd-emissions-value2")], className="data-download-buttons")]),
                    dcc.Tab(label="2. Economic Model", id="investments-title-div-2", className="db-titles",
                            children=[
                                html.Div([
                                    html.P(
                                        "Please select the output type 1:"
                                    ),
                                    dcc.Dropdown(
                                        id="ECoutput-dropdown-list",
                                        options=["Per capita", "Total for the municipality"],
                                        searchable=True,
                                        placeholder="..."
                                    )
                                ], id="ECoutput-dropdown"),

                                html.Div([
                                    html.P(
                                        "Please select the output type 2:"
                                    ),
                                    dcc.Dropdown(
                                        id="ECoutput-dropdown-list-2",
                                        options=['2025', '2027', "2030", '2025 Cumulative', '2027 Cumulative',
                                                 "2030 Cumulative"],
                                        searchable=True,
                                        placeholder="..."
                                    )
                                ], id="ECoutput2-dropdown"),

                                html.Div(
                                    id="CAPEX-TBE-graph-space",
                                    children=[
                                        dcc.Graph(id="CAPEX-TBE-graph", config={'displaylogo': False}),
                                        html.Div([
                                            html.Button("Download Data", id="btn-download-capex-tbe"),
                                            dcc.Download(id="download-capex-tbe-text"),
                                            dcc.Store(id="dd-capex-value")], className="data-download-buttons")
                                    ]
                                ),
                                html.Div(
                                    id="OPEX-TBE-graph-space",
                                    children=[
                                        dcc.Graph(id="OPEX-TBE-graph", config={'displaylogo': False}),
                                        html.Div([
                                            html.Button("Download Data", id="btn-download-opex-tbe"),
                                            dcc.Download(id="download-opex-tbe-text"),
                                            dcc.Store(id="dd-opex-value")], className="data-download-buttons")
                                    ]
                                ),
                                html.Div(
                                    id="SI-TBE-graph-div",
                                    children=[
                                        dcc.Graph(id="SI-TBE-graph", config={'displaylogo': False}),
                                        html.Div([
                                            html.Button("Download Data", id="btn-download-si-tbe"),
                                            dcc.Download(id="download-si-tbe-text"),
                                            dcc.Store(id="dd-si-value")], className="data-download-buttons")
                                    ]
                                ),
                                html.Div([
                                    html.P(
                                        "Please select a output type 3:"
                                    ),
                                    dcc.Dropdown(
                                        id="NPV-dropdown-list",
                                        options=["Total Cumulative NPV 2030", "Annual average NPV (2021-2030)"],
                                        searchable=True,
                                        placeholder="...."
                                    ),
                                ], id="NPV-dropdown"),

                                html.Div([
                                    html.P(
                                        "Please select a interest % to calculate NPV:"
                                    ),
                                    dcc.Dropdown(
                                        id='int-input',
                                        options=[1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 6, 7, 8, 9, 10],
                                        value='3.5',  # Set the default value
                                        placeholder='Select a percentage'
                                    )

                                ], id="NPV1-dropdown"),

                                html.Div(
                                    id="NPV-TBE-graph-div",
                                    children=[
                                        dcc.Graph(id="NPV-TBE-graph", config={'displaylogo': False}),
                                        html.Div([
                                            html.Button("Download Data", id="btn-download-NPV-tbe"),
                                            dcc.Download(id="download-NPV-tbe-text"),
                                            dcc.Store(id="dd-NPV-value")], className="data-download-buttons")
                                    ]
                                ),
                                html.Div([
                                    html.P(
                                        "Please select the Co-benefit type:"
                                    ),
                                    dcc.Dropdown(
                                        id="ci-dropdown-list",
                                        options=["Improved air quality", "Reduced noise pollution", "Improved traffic safety", "Improved physical health", 'Total'],
                                        value="Improved air quality",
                                        searchable=True,
                                        placeholder="..."
                                    )
                                ], id="ci-dropdown"),
                                html.Div(
                                    id="CI-TBE-graph-div",
                                    children=[
                                        dcc.Graph(id="CI-TBE-graph", config={'displaylogo': False}),
                                        html.Div([
                                            html.Button("Download Data", id="btn-download-ci-tbe"),
                                            dcc.Download(id="download-ci-tbe-text"),
                                            dcc.Store(id="dd-ci-value")], className="data-download-buttons"),
                                        html.P(
                                            "To download all the selected outputs together",
                                            style={'fontSize': '20px', 'textAlign': 'center'}  # Increase the font size
                                        ),
                                        html.Div([
                                            html.Button("Download Data", id="btn-download-total-tbe", style={
                                                'fontSize': '20px',  # Adjust for a bigger font size
                                                'padding': '10px 20px',  # Increase padding for bigger button size
                                            }),
                                            dcc.Download(id="download-total-tbe-text"),
                                            dcc.Store(id="dd-total-value")
                                        ], className="data-download-buttons", style={'textAlign': 'center'})  # Center align the content of the div
                                    ],
                                ),
                                html.Br()]),
                    dcc.Tab(
                        label="3. Investment Scenarios", className="db-titles", id="db3-2", children=[
                            html.Div([
                                html.P(
                                    "Please select a stakeholder:"
                                ),
                                dcc.Dropdown(
                                    id="stakeholder2-dropdown-list",
                                    options=["Citizens", "Public", "Private sector", "Public utility companies",
                                             "Total"],
                                    searchable=True,
                                    placeholder="..."
                                )
                            ], id="Stakeholders2-dropdown"),
                            html.Div(
                                id="fundingcap-TBE-graph-div",
                                children=[
                                    dcc.Graph(id="fundingcap-TBE-graph", config={'displaylogo': False})]
                            ),
                            html.Div(
                                id="fundingopp-TBE-graph-div",
                                children=[
                                    dcc.Graph(id="fundingopp-TBE-graph", config={'displaylogo': False})]
                            ),
                            html.Br()]),
                ]
                         )], id="sidebar-2")], style={'width': '100%'}, id="col2-2-1"),
                            html.Hr(id="graphs-break-2"),
                            html.Div([html.Img(
                                id="funders-img-2",
                                src="assets/funders-logo.png")], id="funders-space-2")
                        ], id="TBE-row-div")

def collapse_4():
    return dbc.Row([
        dbc.Col([
                html.Div([dbc.Button(
                    "Transport service",
                    id="transport-service-collapse-button2",
                    n_clicks=0
                ),
                dbc.Collapse(
                    id= "transport-service-collapse2",
                    is_open=False,
                children = [html.P(
                id="slider-text-100",
                children="Share of buses that is electrified"
            ),
            dcc.Slider(
                id="slider-100",
                min=min(percentages),
                max=max(percentages),
                marks={
                    str(perc): {
                        "label": str(perc)
                    }
                    for perc in percentages_5
                    },
                tooltip={
                    "placement": "bottom",
                    "always_visible": True
                }
            ),
            html.P(
                id="slider-text-101",
                children="Share of buses that run on conventional HVO"
            ),
            dcc.Slider(
                id="slider-101",
                min=min(percentages),
                max=max(percentages),
                marks={
                    str(perc): {
                        "label": str(perc)
                    }
                    for perc in percentages_5
                    },
                tooltip={
                    "placement": "bottom",
                    "always_visible": True
                }
            ),
            html.P(
                id="slider-text-102",
                children="Share of buses that will continue running on the current fuel mix"
            ),
            dcc.Slider(
                id="slider-102",
                min=min(percentages),
                max=max(percentages),
                marks={
                    str(perc): {
                        "label": str(perc)
                    }
                    for perc in percentages_5
                    },
                tooltip={
                    "placement": "bottom",
                    "always_visible": True
                }
            ),
            html.P(
                id="slider-text-103",
                children="Share of hybrid HVO buses"
            ),
            dcc.Slider(
                id="slider-103",
                min=min(percentages),
                max=max(percentages),
                marks={
                    str(perc): {
                        "label": str(perc)
                    }
                    for perc in percentages_5
                    },
                tooltip={
                    "placement": "bottom",
                    "always_visible": True
                }
            )]),
            html.Div(
                children=
                [dbc.Button(
                    "Air transport",
                    id="air-transport-collapse-button2",
                    n_clicks=0
                ),
                 dbc.Collapse(
                     id="air-transport-collapse2",
                     is_open=False,
                     children=[
                html.P(
                    id="slider-text-104",
                    children="Reduction in air transport"
                ),
                dcc.Slider(
                    id="slider-104",
                    min=min(percentages),
                    max=max(percentages),
                    marks={
                        str(perc): {
                            "label": str(perc)
                        }
                        for perc in percentages_5
                        },
                    tooltip={
                        "placement": "bottom",
                        "always_visible": True
                    }
                )]
            )]),
            html.Div(
                children=
                [dbc.Button(
                    "Vehicles",
                    id="vehicles-cars-collapse-button2",
                    n_clicks=0
                ),
                    dbc.Collapse(
                        id="vehicles-cars-collapse2",
                        is_open=False,
                        children=[
                html.P(
                    id="slider-text-105",
                    children="Share of cars that will be electrified"
                ),
                dcc.Slider(
                    id="slider-105",
                    min=min(percentages),
                    max=max(percentages),
                    marks={
                        str(perc): {
                            "label": str(perc)
                        }
                        for perc in percentages_5
                    },
                    tooltip={
                        "placement": "bottom",
                        "always_visible": True
                    }
                ),
                html.P(
                    id="slider-text-106",
                    children="Share of cars that will be given up in favor of public transport"
                ),
                dcc.Slider(
                    id="slider-106",
                    min=min(percentages),
                    max=max(percentages),
                    marks={
                        str(perc): {
                            "label": str(perc)
                        }
                        for perc in percentages_5
                    },
                    tooltip={
                        "placement": "bottom",
                        "always_visible": True
                    }
                ),
                html.P(
                    id="slider-text-107",
                    children="Share of cars that will run on the current fuel mix"
                ),
                dcc.Slider(
                    id="slider-107",
                    min=min(percentages),
                    max=max(percentages),
                    marks={
                        str(perc): {
                            "label": str(perc)
                        }
                        for perc in percentages_5
                    },
                    tooltip={
                        "placement": "bottom",
                        "always_visible": True
                    }
                ),
                html.P(
                    id="slider-text-108",
                    children="Share of plug-in-hybrid cars"
                ),
                dcc.Slider(
                    id="slider-108",
                    min=min(percentages),
                    max=max(percentages),
                    marks={
                        str(perc): {
                            "label": str(perc)
                        }
                        for perc in percentages_5
                    },
                    tooltip={
                        "placement": "bottom",
                        "always_visible": True
                    }
                ),
                html.P(
                    id="slider-text-109",
                    children="Share of hydrogen cars"
                ),
                dcc.Slider(
                    id="slider-109",
                    min=min(percentages),
                    max=max(percentages),
                    marks={
                        str(perc): {
                            "label": str(perc)
                        }
                        for perc in percentages_5
                    },
                    tooltip={
                        "placement": "bottom",
                        "always_visible": True
                    }
                )
                ])]
            ),
            html.Div(
                children=[
                    dbc.Button(
                        "Electricity",
                        id="el-collapse-button2",
                        n_clicks=0
                    ),
                    dbc.Collapse(
                        id="el-collapse2",
                        is_open=False,
                        children=[
                    html.P(
                        id="slider-text-110",
                        children="Share of households where BAT major appliances are purchased"
                    ),
                    dcc.Slider(
                        id="slider-110",
                        min=min(percentages),
                        max=max(percentages),
                        marks={
                            str(perc): {
                                "label": str(perc)
                            }
                            for perc in percentages_5
                        },
                        tooltip={
                            "placement": "bottom",
                            "always_visible": True
                        }
                    )
                ])]
            ),
            html.Div(
                children=[
                    dbc.Button(
                        "House heating",
                        id="house-heating-collapse-button2"
                    ),
                    dbc.Collapse(
                        id="house-heating-collapse2",
                        is_open=False,
                        children=[
                    html.P(
                        id="slider-text-111",
                        children="Share of households where indoor temperature is reduced to 20°C"
                    ),
                    dcc.Slider(
                        id="slider-111",
                        min=min(percentages),
                        max=max(percentages),
                        marks={
                            str(perc): {
                                "label": str(perc)
                            }
                            for perc in percentages_5
                        },
                        tooltip={
                            "placement": "bottom",
                            "always_visible": True
                        }
                    ),
                    html.P(
                        id="slider-text-112",
                        children="Share of households where no heating measure is implemented"
                    ),
                    dcc.Slider(
                        id="slider-112",
                        min=min(percentages),
                        max=max(percentages),
                        marks={
                            str(perc): {
                                "label": str(perc)
                            }
                            for perc in percentages_5
                        },
                        tooltip={
                            "placement": "bottom",
                            "always_visible": True
                        }
                    ),
                    html.P(
                        id="slider-text-113",
                        children="Share of households where the measures in Savvidou and Nykvist (2020) are implemented"
                    ),
                    dcc.Slider(
                        id="slider-113",
                        min=min(percentages),
                        max=max(percentages),
                        marks={
                            str(perc): {
                                "label": str(perc)
                            }
                            for perc in percentages_5
                        },
                        tooltip={
                            "placement": "bottom",
                            "always_visible": True
                        }
                    )
                ])]
            ),
            html.Div(
                children=[
                    dbc.Button(
                        "Heavy trucks",
                        id="heavy-collapse-button2",
                    ),
                    dbc.Collapse(
                        id="heavy-collapse2",
                        is_open=False,
                        children=[
                    html.P(
                        id="slider-text-114",
                        children="Share of diesel heavy trucks that is replaced by LBG heavy trucks"
                    ),
                    dcc.Slider(
                        id="slider-114",
                        min=min(percentages),
                        max=max(percentages),
                        marks={
                            str(perc): {
                                "label": str(perc)
                            }
                            for perc in percentages_5
                        },
                        tooltip={
                            "placement": "bottom",
                            "always_visible": True
                        }
                    )
                ])])], id="sliders-div-3")], width=2, id="col1-2-2"),
            dbc.Col([
                html.Div([
                    dcc.Tabs(id="db-tabs-3", value="graph-title-3", children=[
                    dcc.Tab(label="0. Your data", id="your-data-title-2", value="your-data-title", className="db-titles", 
                            children=[                                
                                html.Div([
                                    html.Label(('Full Name'), style={'font-size': '16px', 'font-weight': 'bold', 'color': 'black','text-align': 'right', 'margin-right': '10px', 'margin-left': '10px'}),
                                    dcc.Input(
                                        id='full-name-input-tbe2',
                                        type='text',
                                        placeholder='Enter your full name'
                                    )
                                ]),
                                html.Div([
                                    html.Label(('Organization'), style={'font-size': '16px', 'font-weight': 'bold', 'color': 'black','text-align': 'right', 'margin-right': '10px', 'margin-left': '10px'}),
                                    dcc.Input(
                                        id='organization-input-tbe2',
                                        type='text',
                                        placeholder='Enter your organization'
                                    )
                                ]),
                               html.Div([
                                    dbc.Row([
                                    dbc.Col(html.Div('Factor', style={'padding': '5px', 'text-align': 'center', 'color': 'black'}), width=2),
                                    dbc.Col(html.Div('Existing assumptions', style={'padding': '5px', 'text-align': 'center', 'color': 'black'}), width=2),
                                    dbc.Col(html.Div('Source (Existing)', style={'padding': '5px', 'text-align': 'center', 'color': 'black'}), width=2),
                                    dbc.Col(html.Div('User assumptions', style={'padding': '5px', 'text-align': 'center', 'color': 'black'}), width=2),
                                    dbc.Col(html.Div('Source (User)', style={'padding': '5px', 'text-align': 'center', 'color': 'black'}), width=2),
                                    dbc.Col(html.Div('Units', style={'padding': '5px', 'text-align': 'center', 'color': 'black'}), width=1),
                                ], style={'border': '0.2px solid black', 'width': '60rem', 'display': 'flex', 'align-items': 'center', 'color': 'black', 'margin-top': '20px'})
                            ] + [
                                dbc.Row([
                                    dbc.Col(html.Div(row['Factor'], style={'padding': '5px', 'text-align': 'center', 'color': 'black'}), width=2),
                                    dbc.Col(html.Div(row['Existing assumptions'], style={'padding': '5px', 'text-align': 'center', 'color': 'black'}), width=2),
                                    dbc.Col(html.Div(row['Source'], style={'padding': '5px', 'text-align': 'center', 'color': 'black'}), width=2),
                                    dbc.Col(dcc.Input(id={'type': 'user-assumptions-tbe2', 'index': i}, type='number', value=row['User assumptions'], style={'padding': '5px', 'text-align': 'center', 'color': 'black', 'background-color': 'light gray', 'border': 'light gray'}), width=2),
                                    dbc.Col(dcc.Input(id={'type': 'source-user-tbe2', 'index': i}, type='text', value=row['Source'], style={'padding': '5px', 'text-align': 'center', 'color': 'black', 'background-color': 'light gray', 'border': 'light gray'}), width=2),
                                    dbc.Col(html.Div(row['Units'], style={'padding': '5px', 'text-align': 'center', 'color': 'black'}), width=1),
                                ], style={'border': '0.2px solid black', 'width': '60rem', 'display': 'flex', 'align-items': 'center'})
                                for i, row in enumerate(Your_data)
                            ], style={'margin-left': '20px'}),
                                dcc.Store(id='data-saved-status-tbe2'),  # Store component to store the data saved status
                            html.Div([
                                html.Button("Save Data", id="btn-save-own-data-tbe2")
                                ], className="data-download-buttons"),
                                dbc.Alert('The data has been successfully stored',
                                    id="popover_tbe2a",
                                    is_open=False,
                                    duration=6000,
                                    dismissable=True,
                                    style={"max-width": "200px", "border-radius": "8px", "position": "relative"},
                                    color='green',
                                    className="custom-alert",
                            ),
                            dbc.Alert("Please enter all necessary information!",
                                    id="popover_tbe2b",
                                    is_open=False,                                    
                                    duration=6000,
                                    dismissable=True,
                                    style={"max-width": "200px", "border-radius": "8px", "position": "relative"},
                                    color='red',
                                    className="custom-alert",
                            ),
                                html.Div([
                                html.A('Download database template', id='download-link-3', href=download_mock_excel(), target='_blank', style={'display': 'block', 'margin-bottom': '10px',  'margin-left': '10px'}),
                                html.Label('OR Please download the excel sheet by clicking the link and fill in your data and send it to the following mail address fedra.vanhuyse@sei.org',
                                           style={'font-size': '18px', 'color': 'black', 'margin-left': '10px', 'margin-bottom': '10px'})
                            ], style={'margin-top': '20px'})
                        ]),
            dcc.Tab(label="1. Climate Action Planning", id="graph-title-3", value="graph-title-3", className="db-titles", 
                children=[
                html.Div(
                    id="graph-space-3",
                    children=[
                    dcc.Graph(id="results-graph-3",
                              config={'displaylogo': False}
                              )]),
                    html.Div([
                        html.Button("Download Data", id="btn-download-emissions-tbe2"),
                        dcc.Download(id="download-emissions-tbe2-text"),
                        dcc.Store(id="dd-emissions-value3")], className="data-download-buttons")]),
                    dcc.Tab(label="2. Economic Model", id="investments-title-div-3", className="db-titles", children=[
                    html.Div(
                        id="CAPEX-TBE2-graph-space",
                        children=[
                            dcc.Graph(id="CAPEX-TBE2-graph", config={'displaylogo': False})]
                    ),
                    html.Div(
                        id = "OPEX-TBE2-graph-space",
                        children =[
                        dcc.Graph(id="OPEX-TBE2-graph", config={'displaylogo': False})]
                    ),
                    html.Div(
                    id="benefit3-TBE2-graph-div",
                    children=[
                    dcc.Graph(id="benefit3-TBE2-graph", config={'displaylogo': False})]
                    ),
                    html.Div(
                    id="NPV-TBE2-graph-div",
                    children=[
                    dcc.Graph(id="NPV-TBE2-graph", config={'displaylogo': False})]
                    ),
                    html.Div(
                    id="MACC-TBE2-graph-div",
                    children=[
                    dcc.Graph(id="MACC-TBE2-graph", config={'displaylogo': False})]
                    ),
                    html.Br()]), 
                dcc.Tab(
                    label="3. Investment Scenarios", className="db-titles", id="db3-3", children=[
                    html.Div([
                    html.P(
                    "Please select a stakeholder:"
                    ),
                    dcc.Dropdown(
                    id="stakeholder3-dropdown-list",
                    options=["Citizens", "Public","Private sector", "Public utility companies", "Total"],
                    searchable=True,
                    placeholder="..."
                    )
                    ],id="Stakeholders3-dropdown"),
                    html.Div(
                    id="fundingcap-TBE2-graph-div",
                    children=[
                    dcc.Graph(id="fundingcap-TBE2-graph", config={'displaylogo': False})]
                    ),
                    html.Div(
                    id="fundingopp-TBE2-graph-div",
                    children=[
                    dcc.Graph(id="fundingopp-TBE2-graph", config={'displaylogo': False})]
                    ),
                    html.Br()]),
                    ]
                )],id="sidebar-3")], style={'width': '100%'}, id="col2-2-2"),
                html.Hr(id="graphs-break-3"),
                html.Div([html.Img(
                            id="funders-img-3",
                            src="assets/funders-logo.png")], id="funders-space-3")
                            ], id="TBE-row-div3")
#CBE callbacks
@app.callback(
    [Output("results-graph", "figure"), Output("slider-5", "value"), Output("slider-11", "value"), Output("slider-19", "value"),
     Output("slider-25", "value"), Output("dd-emissions-value1", "data")],
    [Input("municipality-dropdown", "value"), Input("slider-1", "value"), Input("slider-2", "value"),
     Input("slider-3", "value"), Input("slider-4", "value"), Input("slider-5", "value"), Input("slider-6", "value"),
     Input("slider-7", "value"), Input("slider-8", "value"), Input("slider-13", "value"), Input("slider-14", "value"),
     Input("slider-15", "value"), Input("slider-16", "value"), Input("slider-18", "value"), Input("slider-9", "value"),
     Input("slider-10", "value"), Input("slider-11", "value"), Input("slider-12", "value"), Input("slider-17", "value"),
     Input("slider-19", "value"), Input("slider-20", "value"), Input("slider-21", "value"), Input("slider-22", "value"),
     Input("slider-25", "value"), Input("slider-24", "value"), Input("slider-26", "value"), Input("slider-23", "value"),
     Input("scenario-dropdown-list-1", "value")]
)
def render_page_2(mun, vegan, veg, meat, nutrition, diet, reduction_clothes, doubling_clothes, half_furn, red_air,
                  double_life, package_holidays, rh_share, cars_givenup, share_elbus, share_HVObus, share_currentmixbus,
                  share_hibHVObus, share_elcars, share_currentmixcar, share_plugincar, share_hydrcar, BATel, dwell_unchanged,
                  dwell_20C, dwell_SN, dh_red, scenario):

    if mun is None:
        fig = go.Figure()
        fig.add_annotation(
            x = 2.7,
            y = 1.8,
            text = "Please make sure to select a municipality from above.",
            showarrow=False,
            font=dict(
                size=20
            ),
            bordercolor="#c7c7c7",
            borderwidth=2,
            borderpad=4,
            bgcolor="#ff7f0e",
            opacity=0.8
        )
        return[go.Figure(data=fig), diet, share_currentmixbus, share_currentmixcar, dwell_unchanged, None]

    if dh_red is None:
        dh_red = 0
    if dwell_unchanged is None:
        dwell_unchanged = 0
    if dwell_20C is None:
        dwell_20C = 0
    if dwell_SN is None:
        dwell_SN = 0
    if share_hydrcar is None:
        share_hydrcar = 0
    if share_plugincar is None:
        share_plugincar = 0
    if share_currentmixcar is None:
        share_currentmixcar = 0
    if share_elcars is None:
        share_elcars = 0
    if reduction_clothes is None:
        reduction_clothes = 0
    if doubling_clothes is None:
        doubling_clothes = 0
    if half_furn is None:
        half_furn = 0
    if red_air is None:
        red_air = 0
    if double_life is None:
        double_life = 0
    if package_holidays is None:
        package_holidays = 0
    if rh_share is None:
        rh_share = 0
    if cars_givenup is None:
        cars_givenup = 0
    if nutrition is None:
        nutrition = 0
    if diet is None:
        diet = 0
    if meat is None:
        meat = 0
    if veg is None:
        veg = 0
    if vegan is None:
        vegan = 0
    if share_elbus is None:
        share_elbus = 0
    if share_currentmixbus is None:
        share_currentmixbus = 0
    if share_HVObus is None:
        share_HVObus = 0
    if share_hibHVObus is None:
        share_hibHVObus = 0
    if BATel is None:
        BATel = 0

    share_currentmixbus = 100 - share_elbus - share_HVObus - share_hibHVObus
    diet = 100 - vegan - veg - meat - nutrition
    share_currentmixcar = 100 - share_elcars - share_plugincar - share_hydrcar - cars_givenup
    dwell_unchanged = 100- dwell_SN - dwell_20C

# Emissions computations
    food = cbe_emissions.loc[str(mun), "bread and cereals":"low alcoholic beer"].sum() * (0.33 * (vegan / 100) + 0.66 * (veg / 100) + 0.75 * (meat / 100) + 0.75 * (nutrition / 100) + (diet / 100)) + cbe_emissions.loc[str(mun), "tobacco":"narcotics"].sum()
    clothing = cbe_emissions.loc[str(mun), "clothing material":"repair and hire of footwear"].sum() * (0.7 * reduction_clothes + 0.5 * doubling_clothes + (100 - reduction_clothes - doubling_clothes))/100
    housing = cbe_emissions.loc[str(mun), "actual rentals paid by tenants, exclusive of heating":"materials and services for the maintenance and repair of the dwelling"].sum() + cbe_emissions.loc[str(mun), "gas":"solid fuels, coal, coke, briquettes, firewood, charcoal, peat and the like"].sum() + cbe_emissions.loc[str(mun), "major household appliances whether electric or not":"domestic services and household services"].sum() + cbe_emissions.loc[str(mun), "furniture and furnishings":"household textiles"].sum() * (1 - 0.5 * (half_furn/100))
    health = cbe_emissions.loc[str(mun), "pharmaceutical products":"hospital services incl. medical fee"].sum()
    air_transport = cbe_emissions.loc[str(mun), "passenger transport by air"] * (100 - red_air)/100
    recreation = ((100 - package_holidays)/100) * cbe_emissions.loc[str(mun), "package holidays"] + ((100 - double_life)/100) * cbe_emissions.loc[str(mun), ["major durables for outdoor recreation", "equipment for sport, camping and open-air recreation"]].sum() + ((100 - (double_life/100)*50)/100) * cbe_emissions.loc[str(mun), ["major durables for outdoor recreation", "equipment for sport, camping and open-air recreation"]].sum() + cbe_emissions.loc[str(mun), "equipment for the reception, recording and reproduction of sound and pictures":"repair of audio-visual, photographic and information processing equipment"].sum() + cbe_emissions.loc[str(mun), "musical instruments and major durables for indoor recreation":"games, toys and hobbies"].sum() + cbe_emissions.loc[str(mun), "plants and flowers, Christmas trees, specially treated soils, pots and pot holders.":"stationery and drawing materials"].sum()
    rh = cbe_emissions.loc[str(mun), "catering services"] * ((100 - rh_share * 0.33)/100) + cbe_emissions.loc[str(mun), "accommodation services"]

# The computation for public transport is a bit more complicated
    pop_growth = pop.loc[str(mun), 2030]/pop.loc[str(mun), 2019]
    pop_car_ratio = pop.loc[str(mun), 2019]/cars.loc[str(mun), "Number of cars"]
    cars_2030 = pop_growth * cars.loc[str(mun), "Number of cars"]
    bus_capacity = 130
    buses_2030 = pop_growth * buses.loc[str(mun), "Total"]
    total_buses_2030 = buses_2030 + ((cars_givenup/100) * cars_2030 * pop_car_ratio) / bus_capacity
    bus_increase = total_buses_2030/buses_2030
    share_diesel_bus = buses.loc[str(mun), "Diesel"]/buses.loc[str(mun), "Total"]

    pt = cbe_emissions.loc[str(mun), "tax benefit cars and hire of personal transport equipment without drivers":"passenger transport by railway"].sum() + cbe_emissions.loc[str(mun), "passenger transport by sea and inland waterway":"other purchased transport services, removal and storage services"].sum() + (share_diesel_bus/100) * (share_elbus * 0.17 + share_HVObus * 0.37 + share_hibHVObus * 0.28 + share_currentmixbus) * bus_increase * cbe_emissions.loc[str(mun), "passenger transport by road"]

# The computation for vehicles emissions is complicated as well

    share_diesel_cars = cars.loc[str(mun), "Cars-diesel"]/cars.loc[str(mun), "Number of cars"]
    share_petrol_cars = cars.loc[str(mun), "Cars-petrol"]/cars.loc[str(mun), "Number of cars"]

    vehicles = cbe_emissions.loc[str(mun), "driving lessons, driving tests and driving licences":"parking"].sum() + cbe_emissions.loc[str(mun), "motor cycles":"bicycles"].sum() + ((share_elcars/100) * (0.35 * share_diesel_cars + 0.25 * share_petrol_cars) + (share_hydrcar/100) * (0.55 * share_diesel_cars + 0.42 * share_petrol_cars) + (share_hydrcar/100) * (0.89 * share_diesel_cars + 0.67 * share_petrol_cars) + (share_currentmixcar/100)) * (cbe_emissions.loc[str(mun), "motor cars"] + cbe_emissions.loc[str(mun), "spare parts and accessories for personal transport equipment":"maintenance and repair of personal transport equipment"].sum() + cbe_emissions.loc[str(mun), "Household fuel use in private vehicles"])

    others = cbe_emissions.loc[str(mun), "hairdressing salons and personal grooming establishments":"fees for legal services, employment agencies, etc."].sum()
    el = cbe_emissions.loc[str(mun), "electricity"] * ((100 - BATel * 0.2075)/100)
    heat = ((dwellings_ratio.loc[str(mun), "1,2 Dwellings"] * (dwell_unchanged + dwell_20C * (1 - 0.21) + dwell_SN * (1 - 0.26))/100) + (dwellings_ratio.loc[str(mun), "Multiple dwellings"] * (dwell_unchanged + dwell_20C * (1 - 0.27) + dwell_SN * (1 - 0.27))/100)) * cbe_emissions.loc[str(mun), "Household fuel use in the home"]
    dist_heating = ((1 - dh_red/100) * cbe_emissions.loc[str(mun), "heat energy purchased from district heating plants."] + (dh_red/100) * (dh.loc[str(mun), "Stenkol (GWh)":"Övrigt fossilt bränsle (GWh)"].sum() + dh.loc[str(mun), "Flue gas condensation energy of fossil origin (GWh)"]) * np.mean([dh_ef.loc["Total (g CO2ekv/kWh)", "Primära trädbränslen"], dh_ef.loc["Total (g CO2ekv/kWh)", "Sekundära trädbränslen"], dh_ef.loc["Total (g CO2ekv/kWh)", "Pellets, briketter och pulver"]]) * cbe_emissions.loc[str(mun), "heat energy purchased from district heating plants."]/np.mean(dh_ef.loc["Total (g CO2ekv/kWh)", "Stenkol":"Övrigt fossilt"])) * ((dwellings_ratio.loc[str(mun), "1,2 Dwellings"] * (dwell_unchanged + dwell_20C * (1 - 0.21) + dwell_SN * (1 - 0.26))/100) + (dwellings_ratio.loc[str(mun), "Multiple dwellings"] * (dwell_unchanged + dwell_20C * (1 - 0.27) + dwell_SN * (1 - 0.27))/100))

    total = food + clothing + housing + health + air_transport + recreation + rh + pt + vehicles + el + heat + dist_heating + others

    plot_data = pd.DataFrame([-food, -clothing, -housing, -health, -air_transport, -recreation, -rh, -pt, -vehicles, -el, -heat,
           -dist_heating, -others, -food*1.1683, -clothing*1.1683, -housing*1.1683, -health*1.1683, -air_transport*1.1683,
            -recreation*1.1683, -rh*1.1683, -pt*1.1683, -vehicles*1.1683, -el*1.1683, -heat*1.1683, -dist_heating*1.1683, -others*1.1683,
            -food*0.94, -clothing*0.94, -housing*0.94, -health*0.94, -air_transport*0.94, -recreation*0.94, -rh*0.94, -pt*0.94,
            -vehicles*0.94, -el*0.94, -heat*0.94, -dist_heating*0.94, -others*0.94], columns = ["Var"])
    plot_data["Scenario"] = ["Scenario 1 - Business as usual Scenario"] * 13 + ["Scenario 2 - Pessimistic Scenario"] * 13 + ["Scenario 3 - Optimistic Scenario"] * 13

# I construct the benchmark values
    food_2019 = cbe_emissions.loc[str(mun), "bread and cereals":"low alcoholic beer"].sum() + cbe_emissions.loc[str(mun), "tobacco":"narcotics"].sum()
    clothing_2019 = cbe_emissions.loc[str(mun), "clothing material":"repair and hire of footwear"].sum()
    housing_2019 = cbe_emissions.loc[str(mun), "actual rentals paid by tenants, exclusive of heating":"materials and services for the maintenance and repair of the dwelling"].sum() + cbe_emissions.loc[str(mun), "gas":"solid fuels, coal, coke, briquettes, firewood, charcoal, peat and the like"].sum() + cbe_emissions.loc[str(mun), "major household appliances whether electric or not":"domestic services and household services"].sum() + cbe_emissions.loc[str(mun), "furniture and furnishings":"household textiles"].sum()
    health_2019 = cbe_emissions.loc[str(mun), "pharmaceutical products":"hospital services incl. medical fee"].sum()
    air_transport_2019 = cbe_emissions.loc[str(mun), "passenger transport by air"]
    recreation_2019 = cbe_emissions.loc[str(mun), "package holidays"] + cbe_emissions.loc[str(mun), ["major durables for outdoor recreation", "equipment for sport, camping and open-air recreation"]].sum() + cbe_emissions.loc[str(mun), ["major durables for outdoor recreation", "equipment for sport, camping and open-air recreation"]].sum() + cbe_emissions.loc[str(mun), "equipment for the reception, recording and reproduction of sound and pictures":"repair of audio-visual, photographic and information processing equipment"].sum() + cbe_emissions.loc[str(mun), "musical instruments and major durables for indoor recreation":"games, toys and hobbies"].sum() + cbe_emissions.loc[str(mun), "plants and flowers, Christmas trees, specially treated soils, pots and pot holders.":"stationery and drawing materials"].sum()
    rh_2019 = cbe_emissions.loc[str(mun), "catering services"] + cbe_emissions.loc[str(mun), "accommodation services"]
    pt_2019 = cbe_emissions.loc[str(mun), "tax benefit cars and hire of personal transport equipment without drivers":"passenger transport by railway"].sum() + cbe_emissions.loc[str(mun), "passenger transport by sea and inland waterway":"other purchased transport services, removal and storage services"].sum() +  cbe_emissions.loc[str(mun), "passenger transport by road"]
    vehicles_2019 = cbe_emissions.loc[str(mun), "driving lessons, driving tests and driving licences":"parking"].sum() + cbe_emissions.loc[str(mun), "motor cycles":"bicycles"].sum() + (cbe_emissions.loc[str(mun), "motor cars"] + cbe_emissions.loc[str(mun), "spare parts and accessories for personal transport equipment":"maintenance and repair of personal transport equipment"].sum() + cbe_emissions.loc[str(mun), "Household fuel use in private vehicles"])
    others_2019 = cbe_emissions.loc[str(mun), "hairdressing salons and personal grooming establishments":"fees for legal services, employment agencies, etc."].sum()
    el_2019 = cbe_emissions.loc[str(mun), "electricity"]
    heat_2019 = cbe_emissions.loc[str(mun), "Household fuel use in the home"]
    dist_heating_2019 = cbe_emissions.loc[str(mun), "heat energy purchased from district heating plants."]

    total_2019 = food_2019 + clothing_2019 + housing_2019 + health_2019 + air_transport_2019 + recreation_2019 + rh_2019 + pt_2019 + vehicles_2019 + others_2019 + el_2019 + heat_2019 + dist_heating_2019
    
# Constructing the forecasted 2030 numbers
    BAU_2030 = (food_2019 + clothing_2019 + housing_2019 + health_2019 + air_transport_2019 + recreation_2019 + rh_2019 + pt_2019 + vehicles_2019 + others_2019 + el_2019 + heat_2019 + dist_heating_2019)
    scenario2total_2030 = food_2019*1.1683 + clothing_2019*1.1683 + housing_2019*1.1683 + health_2019*1.1683 + air_transport_2019*1.1683 + recreation_2019*1.1683 + rh_2019*1.1683 + ((pt_2019*1.1683)) + ((vehicles_2019*1.1683)) + others_2019*1.1683 + el_2019 + heat_2019*1.1683 + dist_heating_2019*1.1683
    scenario3total_2030 = food_2019*0.94 + clothing_2019*0.94 + housing_2019*0.94 + health_2019*0.94 + air_transport_2019*0.94 + recreation_2019*0.94 + rh_2019*0.94 + ((pt_2019*0.94)) + ((vehicles_2019*0.94)) + others_2019*0.94 + el_2019*0.94 + heat_2019*0.94 + dist_heating_2019*0.94
    EAC_2030 = (food+ clothing+ housing+ health+ air_transport+recreation+ rh+ pt+ vehicles+ el+ heat+ dist_heating+ others)
    EAC2_2030 = (food*1.1683+ clothing*1.1683+ housing*1.1683+ health*1.1683+ air_transport*1.1683+recreation*1.1683+ rh*1.1683+ pt*1.1683+ vehicles*1.1683+ el*1.1683+ heat*1.1683+ dist_heating*1.1683+ others*1.1683)
    EAC3_2030 = (food*0.94+ clothing*0.94+ housing*0.94+ health*0.94+ air_transport*0.94+recreation*0.94+ rh*0.94+ pt*0.94+ vehicles*0.94+ el*0.94+ heat*0.94+ dist_heating*0.94+ others*0.94)
    
    if scenario == "Scenario 1 - Business as usual Scenario":
        start_year = 2019
        end_year = 2030
        num_years = end_year - start_year + 1
     
    
        growth_perc2030= 1
        growth_perc2019 = 1.0
    
        growth_rate_per_year = (growth_perc2030-growth_perc2019)/(end_year-start_year)
    
        food_values1 = [food_2019]
        for i in range(num_years - 1):
            interpolated_value = food_values1[-1] * (1 + growth_rate_per_year)
            food_values1.append(interpolated_value)
    
        # Repeat the above code for other variables
    
        #for clothing
        clothing_values1 = [clothing_2019]
        for i in range(num_years - 1):
            interpolated_value = clothing_values1[-1] * (1 + growth_rate_per_year)
            clothing_values1.append(interpolated_value)
        
                        
        housing_values1 = [housing_2019]
        for i in range(num_years - 1):
            interpolated_value = housing_values1[-1] * (1 + growth_rate_per_year)
            housing_values1.append(interpolated_value)
            

            
        health_values1 = [health_2019]
        for i in range(num_years - 1):
            interpolated_value = health_values1[-1] * (1 + growth_rate_per_year)
            health_values1.append(interpolated_value)
            

        air_transport_values1 = [air_transport_2019]
        for i in range(num_years - 1):
            interpolated_value = air_transport_values1[-1] * (1 + growth_rate_per_year)
            air_transport_values1.append(interpolated_value)

        recreation_values1 = [recreation_2019]
        for i in range(num_years - 1):
            interpolated_value = recreation_values1[-1] * (1 + growth_rate_per_year)
            recreation_values1.append(interpolated_value)
            
        
        rh_values1 = [rh_2019]
        for i in range(num_years - 1):
            interpolated_value = rh_values1[-1] * (1 + growth_rate_per_year)
            rh_values1.append(interpolated_value)
            

        pt_values1 = [pt_2019]
        for i in range(num_years - 1):
            interpolated_value = pt_values1[-1] * (1 + growth_rate_per_year)
            pt_values1.append(interpolated_value)

        vehicles_values1 = [vehicles_2019]
        for i in range(num_years - 1):
            interpolated_value = vehicles_values1[-1] * (1 + growth_rate_per_year)
            vehicles_values1.append(interpolated_value)
            

        others_values1 = [others_2019]
        for i in range(num_years - 1):
            interpolated_value = others_values1[-1] * (1 + growth_rate_per_year)
            others_values1.append(interpolated_value)
            

        el_values1 = [el_2019]
        for i in range(num_years - 1):
            interpolated_value = el_values1[-1] * (1 + growth_rate_per_year)
            el_values1.append(interpolated_value)
            
        
        
        heat_values1 = [heat_2019]
        for i in range(num_years - 1):
            interpolated_value = heat_values1[-1] * (1 + growth_rate_per_year)
            heat_values1.append(interpolated_value)
            
                    
        dist_heating_values1 = [dist_heating_2019]
        for i in range(num_years - 1):
            interpolated_value = dist_heating_values1[-1] * (1 + growth_rate_per_year)
            dist_heating_values1.append(interpolated_value)
           
            ################Lever###########################
       
        ## foodLevers    
        food_growth_2030 = food
        food_growth_2019 = food_2019
        food_values = [food_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (food_growth_2030 - food_growth_2019) / num_years
            interpolated_value = food_values[-1] + growth_rate_per_year
            food_values.append(interpolated_value)
## clothingLevers    
        clothing_growth_2030 = clothing
        clothing_growth_2019 = clothing_2019
        clothing_values = [clothing_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (clothing_growth_2030 - clothing_growth_2019) / num_years
            interpolated_value = clothing_values[-1] + growth_rate_per_year
            clothing_values.append(interpolated_value)            
        ## housingLevers    
        hs_growth_2030 = housing
        hs_growth_2019 = housing_2019
        hs_values = [hs_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (hs_growth_2030 - hs_growth_2019) / num_years
            interpolated_value = hs_values[-1] + growth_rate_per_year
            hs_values.append(interpolated_value) 
        ## healthLevers    
        he_growth_2030 = health
        he_growth_2019 = health_2019
        he_values = [he_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (he_growth_2030 - he_growth_2019) / num_years
            interpolated_value = he_values[-1] + growth_rate_per_year
            he_values.append(interpolated_value)
            
        ## air_transportLevers    
        at_growth_2030 = air_transport
        at_growth_2019 = air_transport_2019
        at_values = [at_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (at_growth_2030 - at_growth_2019) / num_years
            interpolated_value = at_values[-1] + growth_rate_per_year
            at_values.append(interpolated_value)
        ## recreationLevers    
        rc_growth_2030 = recreation
        rc_growth_2019 = recreation_2019
        rc_values = [rc_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (rc_growth_2030 - rc_growth_2019) / num_years
            interpolated_value = rc_values[-1] + growth_rate_per_year
            rc_values.append(interpolated_value)
        ## rhLevers    
        rh_growth_2030 = rh
        rh_growth_2019 = rh_2019
        rh_values = [rc_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (rh_growth_2030 - rh_growth_2019) / num_years
            interpolated_value = rh_values[-1] + growth_rate_per_year
            rh_values.append(interpolated_value)
            
        ## ptLevers    
        pt_growth_2030 = pt
        pt_growth_2019 = pt_2019
        pt_values = [pt_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (pt_growth_2030 - pt_growth_2019) / num_years
            interpolated_value = pt_values[-1] + growth_rate_per_year
            pt_values.append(interpolated_value)
        ## vehiclesLevers    
        vehicles_growth_2030 = vehicles
        vehicles_growth_2019 = vehicles_2019
        vehicles_values = [vehicles_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (vehicles_growth_2030 - vehicles_growth_2019) / num_years
            interpolated_value = vehicles_values[-1] + growth_rate_per_year
            vehicles_values.append(interpolated_value)
        ## othersLevers    
        others_growth_2030 = others
        others_growth_2019 = others_2019
        others_values = [others_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (others_growth_2030 - others_growth_2019) / num_years
            interpolated_value = others_values[-1] + growth_rate_per_year
            others_values.append(interpolated_value)
        ## elLevers    
        el_growth_2030 = el
        el_growth_2019 = el_2019
        el_values = [el_growth_2019]
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (el_growth_2030 - el_growth_2019) / num_years
            interpolated_value = el_values[-1] + growth_rate_per_year
            el_values.append(interpolated_value)
            ## heatLevers    
        heat_growth_2030 = heat
        heat_growth_2019 = heat_2019
        heat_values = [heat_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (heat_growth_2030 - heat_growth_2019) / num_years
            interpolated_value = heat_values[-1] + growth_rate_per_year
            heat_values.append(interpolated_value)
        ## DHLevers    
        dh_growth_2030 = dist_heating
        dh_growth_2019 = dist_heating_2019
        dh_values = [dh_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (dh_growth_2030 - dh_growth_2019) / num_years
            interpolated_value = dh_values[-1] + growth_rate_per_year
            dh_values.append(interpolated_value)
            
            years = list(range(2019, 2031))
            # Create a color scale for the categories
            color_scale = ['#636EFA', '#EF553B', '#00CC96', '#AB63FA', '#FFA15A', '#19D3F3',
                           '#FF6692', '#B6E880', '#FF97FF', '#FECB52', '#FE6100', '#DB00FF', '#8C00FF']

        categories = ["Food", "Clothing", "Housing", "Health", "Air transport", "Recreation",
              "Restaurants and hotels", "Public transport", "Vehicles", "Electricity", "Heating",
              "District heating", "Others"]
        values1 = [food_values1, clothing_values1, housing_values1, health_values1, air_transport_values1,
                   recreation_values1, rh_values1, pt_values1, vehicles_values1, el_values1, heat_values1,
                   dist_heating_values1, others_values1]
        values2 = [food_values, clothing_values, hs_values, he_values, at_values,
                   rc_values, rh_values, pt_values, vehicles_values, el_values, heat_values,
                   dh_values, others_values]
        
      
        # Create a figure with two subplots, each containing a stacked bar chart
        fig = make_subplots(rows=2, cols=1, subplot_titles=("Forecasted emissions 2030: {} Kg".format(round(BAU_2030 )), "Emissions after climate action 2030: {} Kg".format(round(EAC_2030 ))), shared_xaxes=False, shared_yaxes=False)
        
        # Plot stacked bar chart for BAU Scenario
        for i in range(len(categories)):
            fig.add_trace(
                go.Bar(x=years, y=values1[i], name=categories[i], hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                row=1, col=1
            )
        
        # Plot stacked bar chart for Scenario
        for i in range(len(categories)):
            fig.add_trace(
                go.Bar(x=years, y=values2[i], showlegend=False, hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                row=2, col=1
            )
            
        # Add labels and titles
        fig.update_layout(
            barmode="stack",  # Set the barmode to 'stack' for stacked bars
            margin=dict(l=40, r=20, b=10, t=60),  # Adjust the margin values to reduce space
            autosize=True,
            title_text="Emissions profile in {} (Kg of CO2-eq)".format(mun),
            title_font=dict(size=18, color="darkred"),
            yaxis=dict(
                title='Kg of CO2-eq',  # Add a title to the y-axis
                showgrid=True,  # Display gridlines on the y-axis
                gridcolor='lightgray',  # Set the color of the gridlines
                gridwidth=0.5  # Set the width of the gridlines
            ),
            height=800  # Increase the height of the chart
        )
        
        # Automatically determine the y-axis range for the first chart (values1)
        fig.update_yaxes(row=1, col=1)
        
        # Update x-axis labels and tick values for both charts
        fig.update_xaxes(title_text="Years", ticktext=[str(year) for year in years], tickvals=years, row=1, col=1)
        fig.update_xaxes(title_text="Years", ticktext=[str(year) for year in years], tickvals=years, row=2, col=1)
        
        # Update y-axis label for the second chart
        fig.update_yaxes(title_text="Kg of CO2-eq", row=2, col=1)
        
        data_exp = {
        "Sectors": categories,
        "Input1": values1,
        "Input2": values2}
        
        # Show the chart
        return [fig, diet, share_currentmixbus, share_currentmixcar, dwell_unchanged, pd.DataFrame.from_dict(data_exp, orient='index').to_dict('records')]
    
    elif scenario == "Scenario 2 - Pessimistic Scenario":
    
        start_year = 2019
        end_year = 2030
        num_years = end_year - start_year + 1
     
    
        growth_perc2030= 1.168
        growth_perc2019 = 1.0
    
        growth_rate_per_year = (growth_perc2030-growth_perc2019)/(end_year-start_year)
    
        food_values1 = [food_2019]
        for i in range(num_years - 1):
            interpolated_value = food_values1[-1] * (1 + growth_rate_per_year)
            food_values1.append(interpolated_value)
    
        # Repeat the above code for other variables
    
        #for clothing
        clothing_values1 = [clothing_2019]
        for i in range(num_years - 1):
            interpolated_value = clothing_values1[-1] * (1 + growth_rate_per_year)
            clothing_values1.append(interpolated_value)
        
                        
        housing_values1 = [housing_2019]
        for i in range(num_years - 1):
            interpolated_value = housing_values1[-1] * (1 + growth_rate_per_year)
            housing_values1.append(interpolated_value)
            

            
        health_values1 = [health_2019]
        for i in range(num_years - 1):
            interpolated_value = health_values1[-1] * (1 + growth_rate_per_year)
            health_values1.append(interpolated_value)
            

        air_transport_values1 = [air_transport_2019]
        for i in range(num_years - 1):
            interpolated_value = air_transport_values1[-1] * (1 + growth_rate_per_year)
            air_transport_values1.append(interpolated_value)

        recreation_values1 = [recreation_2019]
        for i in range(num_years - 1):
            interpolated_value = recreation_values1[-1] * (1 + growth_rate_per_year)
            recreation_values1.append(interpolated_value)
            
        
        rh_values1 = [rh_2019]
        for i in range(num_years - 1):
            interpolated_value = rh_values1[-1] * (1 + growth_rate_per_year)
            rh_values1.append(interpolated_value)
            

        pt_values1 = [pt_2019]
        for i in range(num_years - 1):
            interpolated_value = pt_values1[-1] * (1 + growth_rate_per_year)
            pt_values1.append(interpolated_value)

        vehicles_values1 = [vehicles_2019]
        for i in range(num_years - 1):
            interpolated_value = vehicles_values1[-1] * (1 + growth_rate_per_year)
            vehicles_values1.append(interpolated_value)
            

        others_values1 = [others_2019]
        for i in range(num_years - 1):
            interpolated_value = others_values1[-1] * (1 + growth_rate_per_year)
            others_values1.append(interpolated_value)
            

        el_values1 = [el_2019]
        for i in range(num_years - 1):
            interpolated_value = el_values1[-1] * (1 + growth_rate_per_year)
            el_values1.append(interpolated_value)
            
        
        
        heat_values1 = [heat_2019]
        for i in range(num_years - 1):
            interpolated_value = heat_values1[-1] * (1 + growth_rate_per_year)
            heat_values1.append(interpolated_value)
            
                    
        dist_heating_values1 = [dist_heating_2019]
        for i in range(num_years - 1):
            interpolated_value = dist_heating_values1[-1] * (1 + growth_rate_per_year)
            dist_heating_values1.append(interpolated_value)
           
            ################Lever###########################
       
        
        ## foodLevers    
        food_growth_2030 = food*growth_perc2030
        food_growth_2019 = food_2019
        food_values = [food_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (food_growth_2030 - food_growth_2019) / num_years
            interpolated_value = food_values[-1] + growth_rate_per_year
            food_values.append(interpolated_value)

## clothingLevers    
        clothing_growth_2030 = clothing*growth_perc2030
        clothing_growth_2019 = clothing_2019
        clothing_values = [clothing_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (clothing_growth_2030 - clothing_growth_2019) / num_years
            interpolated_value = clothing_values[-1] + growth_rate_per_year
            clothing_values.append(interpolated_value)            
        ## housingLevers    
        hs_growth_2030 = housing*growth_perc2030
        hs_growth_2019 = housing_2019
        hs_values = [hs_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (hs_growth_2030 - hs_growth_2019) / num_years
            interpolated_value = hs_values[-1] + growth_rate_per_year
            hs_values.append(interpolated_value) 
        ## healthLevers    
        he_growth_2030 = health*growth_perc2030
        he_growth_2019 = health_2019
        he_values = [he_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (he_growth_2030 - he_growth_2019) / num_years
            interpolated_value = he_values[-1] + growth_rate_per_year
            he_values.append(interpolated_value)
            
        ## air_transportLevers    
        at_growth_2030 = air_transport*growth_perc2030
        at_growth_2019 = air_transport_2019
        at_values = [at_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (at_growth_2030 - at_growth_2019) / num_years
            interpolated_value = at_values[-1] + growth_rate_per_year
            at_values.append(interpolated_value)
        ## recreationLevers    
        rc_growth_2030 = recreation*growth_perc2030
        rc_growth_2019 = recreation_2019
        rc_values = [rc_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (rc_growth_2030 - rc_growth_2019) / num_years
            interpolated_value = rc_values[-1] + growth_rate_per_year
            rc_values.append(interpolated_value)
        ## rhLevers    
        rh_growth_2030 = rh*growth_perc2030
        rh_growth_2019 = rh_2019
        rh_values = [rc_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (rh_growth_2030 - rh_growth_2019) / num_years
            interpolated_value = rh_values[-1] + growth_rate_per_year
            rh_values.append(interpolated_value)
            
        ## ptLevers    
        pt_growth_2030 = pt*growth_perc2030
        pt_growth_2019 = pt_2019
        pt_values = [pt_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (pt_growth_2030 - pt_growth_2019) / num_years
            interpolated_value = pt_values[-1] + growth_rate_per_year
            pt_values.append(interpolated_value)
        ## vehiclesLevers    
        vehicles_growth_2030 = vehicles*growth_perc2030
        vehicles_growth_2019 = vehicles_2019
        vehicles_values = [vehicles_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (vehicles_growth_2030 - vehicles_growth_2019) / num_years
            interpolated_value = vehicles_values[-1] + growth_rate_per_year
            vehicles_values.append(interpolated_value)
        ## othersLevers    
        others_growth_2030 = others*growth_perc2030
        others_growth_2019 = others_2019
        others_values = [others_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (others_growth_2030 - others_growth_2019) / num_years
            interpolated_value = others_values[-1] + growth_rate_per_year
            others_values.append(interpolated_value)
        ## elLevers    
        el_growth_2030 = el*growth_perc2030
        el_growth_2019 = el_2019
        el_values = [el_growth_2019]
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (el_growth_2030 - el_growth_2019) / num_years
            interpolated_value = el_values[-1] + growth_rate_per_year
            el_values.append(interpolated_value)
            ## heatLevers    
        heat_growth_2030 = heat*growth_perc2030
        heat_growth_2019 = heat_2019
        heat_values = [heat_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (heat_growth_2030 - heat_growth_2019) / num_years
            interpolated_value = heat_values[-1] + growth_rate_per_year
            heat_values.append(interpolated_value)
        ## DHLevers    
        dh_growth_2030 = dist_heating*growth_perc2030
        dh_growth_2019 = dist_heating_2019
        dh_values = [dh_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (dh_growth_2030 - dh_growth_2019) / num_years
            interpolated_value = dh_values[-1] + growth_rate_per_year
            dh_values.append(interpolated_value)

            
            years = list(range(2019, 2031))
            # Create a color scale for the categories
            color_scale = ['#636EFA', '#EF553B', '#00CC96', '#AB63FA', '#FFA15A', '#19D3F3',
                           '#FF6692', '#B6E880', '#FF97FF', '#FECB52', '#FE6100', '#DB00FF', '#8C00FF']

        categories = ["Food", "Clothing", "Housing", "Health", "Air transport", "Recreation",
              "Restaurants and hotels", "Public transport", "Vehicles", "Electricity", "Heating",
              "District heating", "Others"]
        values1 = [food_values1, clothing_values1, housing_values1, health_values1, air_transport_values1,
                   recreation_values1, rh_values1, pt_values1, vehicles_values1, el_values1, heat_values1,
                   dist_heating_values1, others_values1]
        values2 = [food_values, clothing_values, hs_values, he_values, at_values,
                   rc_values, rh_values, pt_values, vehicles_values, el_values, heat_values,
                   dh_values, others_values]       

        # Create a figure with two subplots, each containing a stacked bar chart
        fig = make_subplots(rows=2, cols=1, subplot_titles=("Forecasted emissions 2030: {} Kg".format(round(scenario2total_2030)), "Emissions after climate action 2030: {} Kg".format(round(EAC2_2030 ))), shared_xaxes=False, shared_yaxes=False)
        
        # Plot stacked bar chart for BAU Scenario
        for i in range(len(categories)):
            fig.add_trace(
                go.Bar(x=years, y=values1[i], name=categories[i], hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                row=1, col=1
            )
        
        # Plot stacked bar chart for Scenario
        for i in range(len(categories)):
            fig.add_trace(
                go.Bar(x=years, y=values2[i], showlegend=False, hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                row=2, col=1)
        
        # Add labels and titles
        fig.update_layout(
            barmode="stack",  # Set the barmode to 'stack' for stacked bars
            margin=dict(l=40, r=20, b=10, t=60),  # Adjust the margin values to reduce space
            autosize=True,
            title_text="Emissions profile in {} (Kg of CO2-eq)".format(mun),
            title_font=dict(size=18, color="darkred"),
            yaxis=dict(
                title='Kg of CO2-eq',  # Add a title to the y-axis
                showgrid=True,  # Display gridlines on the y-axis
                gridcolor='lightgray',  # Set the color of the gridlines
                gridwidth=0.5  # Set the width of the gridlines
            ),
            height=800  # Increase the height of the chart
        )
        
        # Automatically determine the y-axis range for the first chart (values1)
        fig.update_yaxes(row=1, col=1)
        
        # Update x-axis labels and tick values for both charts
        fig.update_xaxes(title_text="Years", ticktext=[str(year) for year in years], tickvals=years, row=1, col=1)
        fig.update_xaxes(title_text="Years", ticktext=[str(year) for year in years], tickvals=years, row=2, col=1)
        
        # Update y-axis label for the second chart
        fig.update_yaxes(title_text="Kg of CO2-eq", row=2, col=1)
        data_exp = {
        "Sectors": categories,
        "Input1": values1,
        "Input2": values2}

        return [fig, diet, share_currentmixbus, share_currentmixcar, dwell_unchanged, pd.DataFrame.from_dict(data_exp, orient='index').to_dict('records')]
    
    
    elif scenario == "Scenario 3 - Optimistic Scenario":
        start_year = 2019
        end_year = 2030
        num_years = end_year - start_year + 1
         
        growth_perc2030= 0.94
        growth_perc2019 = 1.0
        
        growth_rate_per_year = (growth_perc2030-growth_perc2019)/(end_year-start_year)
        
        food_values1 = [food_2019]
        for i in range(num_years - 1):
            interpolated_value = food_values1[-1] * (1 + growth_rate_per_year)
            food_values1.append(interpolated_value)
        
        # Repeat the above code for other variables
        
        #for clothing
        clothing_values1 = [clothing_2019]
        for i in range(num_years - 1):
            interpolated_value = clothing_values1[-1] * (1 + growth_rate_per_year)
            clothing_values1.append(interpolated_value)
        
                        
        housing_values1 = [housing_2019]
        for i in range(num_years - 1):
            interpolated_value = housing_values1[-1] * (1 + growth_rate_per_year)
            housing_values1.append(interpolated_value)
            
        
            
        health_values1 = [health_2019]
        for i in range(num_years - 1):
            interpolated_value = health_values1[-1] * (1 + growth_rate_per_year)
            health_values1.append(interpolated_value)
            
        
        air_transport_values1 = [air_transport_2019]
        for i in range(num_years - 1):
            interpolated_value = air_transport_values1[-1] * (1 + growth_rate_per_year)
            air_transport_values1.append(interpolated_value)
        
        recreation_values1 = [recreation_2019]
        for i in range(num_years - 1):
            interpolated_value = recreation_values1[-1] * (1 + growth_rate_per_year)
            recreation_values1.append(interpolated_value)
            
        
        rh_values1 = [rh_2019]
        for i in range(num_years - 1):
            interpolated_value = rh_values1[-1] * (1 + growth_rate_per_year)
            rh_values1.append(interpolated_value)
        
        pt_values1 = [pt_2019]
        for i in range(num_years - 1):
            interpolated_value = pt_values1[-1] * (1 + growth_rate_per_year)
            pt_values1.append(interpolated_value)
        
        vehicles_values1 = [vehicles_2019]
        for i in range(num_years - 1):
            interpolated_value = vehicles_values1[-1] * (1 + growth_rate_per_year)
            vehicles_values1.append(interpolated_value)
            
        
        others_values1 = [others_2019]
        for i in range(num_years - 1):
            interpolated_value = others_values1[-1] * (1 + growth_rate_per_year)
            others_values1.append(interpolated_value)
            
        
        el_values1 = [el_2019]
        for i in range(num_years - 1):
            interpolated_value = el_values1[-1] * (1 + growth_rate_per_year)
            el_values1.append(interpolated_value)
            
        
        
        heat_values1 = [heat_2019]
        for i in range(num_years - 1):
            interpolated_value = heat_values1[-1] * (1 + growth_rate_per_year)
            heat_values1.append(interpolated_value)
            
                    
        dist_heating_values1 = [dist_heating_2019]
        for i in range(num_years - 1):
            interpolated_value = dist_heating_values1[-1] * (1 + growth_rate_per_year)
            dist_heating_values1.append(interpolated_value)
           
            ################Lever###########################
           
        
        ## foodLevers    
        food_growth_2030 = food*growth_perc2030
        food_growth_2019 = food_2019
        food_values = [food_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (food_growth_2030 - food_growth_2019) / num_years
            interpolated_value = food_values[-1] + growth_rate_per_year
            food_values.append(interpolated_value)
        ## clothingLevers    
        clothing_growth_2030 = clothing*growth_perc2030
        clothing_growth_2019 = clothing_2019
        clothing_values = [clothing_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (clothing_growth_2030 - clothing_growth_2019) / num_years
            interpolated_value = clothing_values[-1] + growth_rate_per_year
            clothing_values.append(interpolated_value)            
        ## housingLevers    
        hs_growth_2030 = housing*growth_perc2030
        hs_growth_2019 = housing_2019
        hs_values = [hs_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (hs_growth_2030 - hs_growth_2019) / num_years
            interpolated_value = hs_values[-1] + growth_rate_per_year
            hs_values.append(interpolated_value) 
        ## healthLevers    
        he_growth_2030 = health*growth_perc2030
        he_growth_2019 = health_2019
        he_values = [he_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (he_growth_2030 - he_growth_2019) / num_years
            interpolated_value = he_values[-1] + growth_rate_per_year
            he_values.append(interpolated_value)
            
        ## air_transportLevers    
        at_growth_2030 = air_transport*growth_perc2030
        at_growth_2019 = air_transport_2019
        at_values = [at_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (at_growth_2030 - at_growth_2019) / num_years
            interpolated_value = at_values[-1] + growth_rate_per_year
            at_values.append(interpolated_value)
        ## recreationLevers    
        rc_growth_2030 = recreation*growth_perc2030
        rc_growth_2019 = recreation_2019
        rc_values = [rc_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (rc_growth_2030 - rc_growth_2019) / num_years
            interpolated_value = rc_values[-1] + growth_rate_per_year
            rc_values.append(interpolated_value)
        ## rhLevers    
        rh_growth_2030 = rh*growth_perc2030
        rh_growth_2019 = rh_2019
        rh_values = [rc_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (rh_growth_2030 - rh_growth_2019) / num_years
            interpolated_value = rh_values[-1] + growth_rate_per_year
            rh_values.append(interpolated_value)
            
        ## ptLevers    
        pt_growth_2030 = pt*growth_perc2030
        pt_growth_2019 = pt_2019
        pt_values = [pt_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (pt_growth_2030 - pt_growth_2019) / num_years
            interpolated_value = pt_values[-1] + growth_rate_per_year
            pt_values.append(interpolated_value)
        ## vehiclesLevers    
        vehicles_growth_2030 = vehicles*growth_perc2030
        vehicles_growth_2019 = vehicles_2019
        vehicles_values = [vehicles_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (vehicles_growth_2030 - vehicles_growth_2019) / num_years
            interpolated_value = vehicles_values[-1] + growth_rate_per_year
            vehicles_values.append(interpolated_value)
        ## othersLevers    
        others_growth_2030 = others*growth_perc2030
        others_growth_2019 = others_2019
        others_values = [others_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (others_growth_2030 - others_growth_2019) / num_years
            interpolated_value = others_values[-1] + growth_rate_per_year
            others_values.append(interpolated_value)
        ## elLevers    
        el_growth_2030 = el*growth_perc2030
        el_growth_2019 = el_2019
        el_values = [el_growth_2019]
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (el_growth_2030 - el_growth_2019) / num_years
            interpolated_value = el_values[-1] + growth_rate_per_year
            el_values.append(interpolated_value)
            ## heatLevers    
        heat_growth_2030 = heat*growth_perc2030
        heat_growth_2019 = heat_2019
        heat_values = [heat_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (heat_growth_2030 - heat_growth_2019) / num_years
            interpolated_value = heat_values[-1] + growth_rate_per_year
            heat_values.append(interpolated_value)
        ## DHLevers    
        dh_growth_2030 = dist_heating*growth_perc2030
        dh_growth_2019 = dist_heating_2019
        dh_values = [dh_growth_2019]
        
        num_years = 2030 - 2019
        
        for i in range(num_years):
            growth_rate_per_year = (dh_growth_2030 - dh_growth_2019) / num_years
            interpolated_value = dh_values[-1] + growth_rate_per_year
            dh_values.append(interpolated_value)
        
            
            years = list(range(2019, 2031))
            # Create a color scale for the categories
            color_scale = ['#636EFA', '#EF553B', '#00CC96', '#AB63FA', '#FFA15A', '#19D3F3',
                           '#FF6692', '#B6E880', '#FF97FF', '#FECB52', '#FE6100', '#DB00FF', '#8C00FF']
        
        categories = ["Food", "Clothing", "Housing", "Health", "Air transport", "Recreation",
              "Restaurants and hotels", "Public transport", "Vehicles", "Electricity", "Heating",
              "District heating", "Others"]
        values1 = [food_values1, clothing_values1, housing_values1, health_values1, air_transport_values1,
                   recreation_values1, rh_values1, pt_values1, vehicles_values1, el_values1, heat_values1,
                   dist_heating_values1, others_values1]
        values2 = [food_values, clothing_values, hs_values, he_values, at_values,
                   rc_values, rh_values, pt_values, vehicles_values, el_values, heat_values,
                   dh_values, others_values]       
        
        # Create a figure with two subplots, each containing a stacked bar chart
        fig = make_subplots(rows=2, cols=1, subplot_titles=("Forecasted emissions 2030: {} Kg".format(round(scenario3total_2030)), "Emissions after climate action 2030: {} Kg".format(round(EAC3_2030 ))), shared_xaxes=False, shared_yaxes=False)
        
        # Plot stacked bar chart for BAU Scenario
        for i in range(len(categories)):
            fig.add_trace(
                go.Bar(x=years, y=values1[i], name=categories[i], hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                row=1, col=1
            )
        
        # Plot stacked bar chart for Scenario
        for i in range(len(categories)):
            fig.add_trace(
                go.Bar(x=years, y=values2[i], showlegend=False, hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                row=2, col=1)
            
        
        # Add labels and titles
        fig.update_layout(
            barmode="stack",  # Set the barmode to 'stack' for stacked bars
            margin=dict(l=40, r=20, b=10, t=60),  # Adjust the margin values to reduce space
            autosize=True,
            title_text="Emissions profile in {} (Kg of CO2-eq)".format(mun),
            title_font=dict(size=18, color="darkred"),
            yaxis=dict(
                title='Kg of CO2-eq',  # Add a title to the y-axis
                showgrid=True,  # Display gridlines on the y-axis
                gridcolor='lightgray',  # Set the color of the gridlines
                gridwidth=0.5  # Set the width of the gridlines
            ),
            height=800  # Increase the height of the chart
        )
        
        # Automatically determine the y-axis range for the first chart (values1)
        fig.update_yaxes(row=1, col=1)
        
        # Update x-axis labels and tick values for both charts
        fig.update_xaxes(title_text="Years", ticktext=[str(year) for year in years], tickvals=years, row=1, col=1)
        fig.update_xaxes(title_text="Years", ticktext=[str(year) for year in years], tickvals=years, row=2, col=1)
        
        # Update y-axis label for the second chart
        fig.update_yaxes(title_text="Kg of CO2-eq", row=2, col=1)
        data_exp = {
        "Sectors": categories,
        "Input1": values1,
        "Input2": values2}
        return [fig, diet, share_currentmixbus, share_currentmixcar, dwell_unchanged, pd.DataFrame.from_dict(data_exp, orient='index').to_dict('records')]
    
#download button
@app.callback(
        Output("download-emissions-cbe-text", "data"), 
        [Input("btn-download-emissions-cbe", "n_clicks"), Input("dd-emissions-value1", "data")],
        [State("scenario-dropdown-list-1", "value"), State("municipality-dropdown", "value")],
        prevent_initial_call=True) #argument ensures that the callback function is not triggered during the initial page load.
def download_button1(n_clicks, value, scenario, mun):
    df = pd.DataFrame(value).transpose() #converts the value into a DataFrame and transposes it.
    ctx = dash.callback_context  # retrieves the context of the callback, including the triggered component and property.
    button_id=ctx.triggered[0]["prop_id"].split(".")[0] #xtracts the ID of the triggered button.
    if n_clicks is not None and button_id == "btn-download-emissions-cbe":
        df0=pd.DataFrame(df.iloc[:,0].to_list(),index=[1,2,3,4,5,6,7,8,9,10,11,12,13])
        df1 = pd.DataFrame(df. iloc[:,1].to_list(), columns=['Forecasted 2019', 'Forecasted 2020', 'Forecasted 2021', 
                                                                                               'Forecasted 2022', 'Forecasted 2023', 'Forecasted 2024', 
                                                                                               'Forecasted 2025', 'Forecasted 2026', 'Forecasted 2027', 
                                                                                               'Forecasted 2028', 'Forecasted 2029', 'Forecasted 2030'],
                                                                                               index=[1,2,3,4,5,6,7,8,9,10,11,12,13])
        df2 = pd.DataFrame(df. iloc[:,2].to_list(), columns=['Action plan 2019', 'Action plan 2020','Action plan 2021',
                                                                                                'Action plan 2022', 'Action plan 2023','Action plan 2024',
                                                                                                'Action plan 2025', 'Action plan 2026','Action plan 2027',
                                                                                                'Action plan 2028', 'Action plan 2029','Action plan 2030'],
                                                                                               index=[1,2,3,4,5,6,7,8,9,10,11,12,13])
        df3 = pd.concat([df0, df1, df2], axis=1)
        return dcc.send_data_frame(df3.to_csv, filename= f'Emissions-cbe-{mun}-{scenario}.csv', header=['sector', 'Forecasted 2019', 'Forecasted 2020', 'Forecasted 2021', 
                                                                                               'Forecasted 2022', 'Forecasted 2023', 'Forecasted 2024', 
                                                                                               'Forecasted 2025', 'Forecasted 2026', 'Forecasted 2027', 
                                                                                               'Forecasted 2028', 'Forecasted 2029', 'Forecasted 2030',
                                                                                               'Action plan 2019', 'Action plan 2020','Action plan 2021',
                                                                                                'Action plan 2022', 'Action plan 2023','Action plan 2024',
                                                                                                'Action plan 2025', 'Action plan 2026','Action plan 2027',
                                                                                                'Action plan 2028', 'Action plan 2029','Action plan 2030'], 
                                                                                                index=False)
    elif n_clicks in [0, None]:
        raise PreventUpdate #prevent any changes or updates to the output when the button has not been clicked.
    elif button_id != "btn-download-emissions-cbe":
        raise PreventUpdate

@app.callback(
        [Output("cost-CBE-graph", "figure")],
        [Input("municipality-dropdown", "value"), Input("slider-1", "value"), Input("slider-2", "value"),
         Input("slider-3", "value"), Input("slider-4", "value"), Input("slider-5", "value"), Input("slider-6", "value"),
         Input("slider-7", "value"), Input("slider-8", "value"), Input("slider-13", "value"),
         Input("slider-14", "value"), Input("slider-15", "value"), Input("slider-16", "value"),
         Input("slider-18", "value"), Input("slider-9", "value"), Input("slider-10", "value"),
         Input("slider-11", "value"), Input("slider-12", "value"), Input("slider-17", "value"),
         Input("slider-19", "value"), Input("slider-20", "value"), Input("slider-21", "value"),
         Input("slider-22", "value"), Input("slider-25", "value"), Input("slider-24", "value"),
         Input("slider-26", "value"), Input("slider-23", "value")]
)
def CBE_costplot(mun, vegan, veg, meat, nutrition, diet, reduction_clothes, doubling_clothes, half_furn, red_air,
                  double_life, package_holidays, rh_share, cars_givenup, share_elbus, share_HVObus, share_currentmixbus,
                  share_hibHVObus, share_elcars, share_currentmixcar, share_plugincar, share_hydrcar, BATel, dwell_unchanged,
                  dwell_20C, dwell_SN, dh_red):

    if dh_red is None:
        dh_red = 0
    if dwell_unchanged is None:
        dwell_unchanged = 0
    if dwell_20C is None:
        dwell_20C = 0
    if dwell_SN is None:
        dwell_SN = 0
    if share_hydrcar is None:
        share_hydrcar = 0
    if share_plugincar is None:
        share_plugincar = 0
    if share_currentmixcar is None:
        share_currentmixcar = 0
    if share_elcars is None:
        share_elcars = 0
    if reduction_clothes is None:
        reduction_clothes = 0
    if doubling_clothes is None:
        doubling_clothes = 0
    if half_furn is None:
        half_furn = 0
    if red_air is None:
        red_air = 0
    if double_life is None:
        double_life = 0
    if package_holidays is None:
        package_holidays = 0
    if rh_share is None:
        rh_share = 0
    if cars_givenup is None:
        cars_givenup = 0
    if nutrition is None:
        nutrition = 0
    if diet is None:
        diet = 0
    if meat is None:
        meat = 0
    if veg is None:
        veg = 0
    if vegan is None:
        vegan = 0
    if share_elbus is None:
        share_elbus = 0
    if share_currentmixbus is None:
        share_currentmixbus = 0
    if share_HVObus is None:
        share_HVObus = 0
    if share_hibHVObus is None:
        share_hibHVObus = 0
    if BATel is None:
        BATel = 0

    share_currentmixbus = 100 - share_elbus - share_HVObus - share_hibHVObus
    diet = 100 - vegan - veg - meat - nutrition
    share_currentmixcar = 100 - share_elcars - share_plugincar - share_hydrcar - cars_givenup
    dwell_unchanged = 100-max([dwell_unchanged, dwell_20C])

    if mun is None:
        fig = go.Figure()
        fig.add_annotation(
            x=2.7,
            y=1.8,
            text="Please make sure to select a municipality from the list above.",
            showarrow=False,
            font=dict(
                size=20
            ),
            bordercolor="#c7c7c7",
            borderwidth=2,
            borderpad=4,
            bgcolor="#ff7f0e",
            opacity=0.8
        )
        return [go.Figure(data=fig)]
    
    pop_growth = pop.loc[str(mun), 2030]/pop.loc[str(mun), 2019]
    pop_car_ratio = pop.loc[str(mun), 2019]/cars.loc[str(mun), "Number of cars"]
    cars_2030 = pop_growth * cars.loc[str(mun), "Number of cars"]
    bus_capacity = 130
    buses_2030 = pop_growth * buses.loc[str(mun), "Total"]
    total_buses_2030 = buses_2030 + ((cars_givenup/100) * cars_2030 * pop_car_ratio) / bus_capacity
    bus_increase = total_buses_2030/buses_2030
    share_diesel_bus = buses.loc[str(mun), "Diesel"]/buses.loc[str(mun), "Total"]

    vehicles_costs_nl = ((100 - cars_givenup)/100)*cars.loc[str(mun), "Privates-cars"]*pop_growth*((share_elcars/100)*600000 + (share_hydrcar/100)*775000 + (share_plugincar/100)*580000)/pop.loc[str(mun), 2019]
    vehicles_costs_l = dwellings_ownership.loc[str(mun), "housing cooperatives":"private persons"].sum()*cars.loc[str(mun), "Privates-cars"]*pop_growth*((100 - cars_givenup)/100)*(share_elcars/100)*np.mean([9000, 9995, 9122.67])/(10*(dwellings_tenureship.loc[str(mun), "multi-dwelling buildings, tenant-owned":"one- or two-dwelling buildings, owner-occupied"].sum() + dwellings_tenureship.loc[str(mun), "one- or two-dwelling buildings, tenant-owned"])*pop.loc[str(mun), 2019]) + vehicles_costs_nl
    el_l = (BATel/100)*dwellings_ownership.loc[str(mun), "housing cooperatives":"private persons"].sum()*dwellings_stock.loc[str(mun), "Housing stock"]*(8990 + 13950 + 11500 + 12100 + 20347 + 14770 + 30*40)/(pop.loc[str(mun), 2019]*(dwellings_tenureship.loc[str(mun), "multi-dwelling buildings, tenant-owned":"one- or two-dwelling buildings, owner-occupied"].sum() + dwellings_tenureship.loc[str(mun), "one- or two-dwelling buildings, tenant-owned"]))
    heating_l = (dwellings_ownership.loc[str(mun), "housing cooperatives":"private persons"].sum()*(dwell_SN/100)*(dwellings_size.loc[str(mun), "1-2 dwelling"]*((1.03*679*0.24) + ((1283 + 1256)*0.84) + (1367 + 7895)*0.15)) + dwellings_ownership.loc[str(mun), "housing cooperatives":"private persons"].sum()*(dwell_SN/100)*(dwellings_size.loc[str(mun), "Multi-dwelling"]*((0.38*679*0.24) + ((1283 + 1256)*0.51) + (1367 + 7895)*0.13)))/(pop.loc[str(mun), 2019]*(dwellings_tenureship.loc[str(mun), "multi-dwelling buildings, tenant-owned":"one- or two-dwelling buildings, owner-occupied"].sum() + dwellings_tenureship.loc[str(mun), "one- or two-dwelling buildings, tenant-owned"]))
    public_transport = ((((cars_givenup/100)*cars_2030*pop_car_ratio/bus_capacity) + buses_2030)*((share_elbus/100)*np.mean([5600000, 4730000, 4400000]) + (share_hibHVObus/100)*2614737) + (((cars_givenup/100)*cars_2030*pop_car_ratio/bus_capacity) + buses_2030)*(share_elbus/100)*((414990/2) + (912978/20) + (190895/20) + (3319920/20)))/pop.loc[str(mun), 2019]
    vehicles_mhc = dwellings_ownership.loc[str(mun), "state, municipal, region"]*cars.loc[str(mun), "Privates-cars"]*pop_growth*((100 - cars_givenup)/100)*((share_elcars)/100)*np.mean([9000, 9995, 9122.67])/(10*pop.loc[str(mun), 2019])
    el_mhc = (BATel/100)*dwellings_ownership.loc[str(mun), "state, municipal, region"]*dwellings_stock.loc[str(mun), "Housing stock"]*(8990 + 13950 + 11500 + 12100 + 20347 + 14770 + 30*40)/pop.loc[str(mun), 2019]
    heating_mhc = (dwellings_ownership.loc[str(mun), "state, municipal, region"]*(dwell_SN/100)*(dwellings_size.loc[str(mun), "1-2 dwelling"]*((1.03*679*0.24) + ((1283 + 1256)*0.84) + (1367 + 7895)*0.15)) + dwellings_ownership.loc[str(mun), "state, municipal, region"]*(dwell_SN/100)*(dwellings_size.loc[str(mun), "Multi-dwelling"]*((0.38*679*0.24) + ((1283 + 1256)*0.51) + (1367 + 7895)*0.13)))/pop.loc[str(mun), 2019]
    vehicles_costs_pc = dwellings_ownership.loc[str(mun), "Swedish joint-stock companies":"other owners"].sum()*cars.loc[str(mun), "Privates-cars"]*pop_growth*((100 - cars_givenup)/100)*(share_elcars/100)*np.mean([9000, 9995, 9122.67])/(10*pop.loc[str(mun), 2019]) + ((100 - cars_givenup)/100)*cars.loc[str(mun), "JP-cars"]*pop_growth*((share_elcars/100)*600000 + (share_hydrcar/100)*775000 + (share_plugincar/100)*580000)/pop.loc[str(mun), 2019]
    heating_pc = (dwellings_ownership.loc[str(mun), "Swedish joint-stock companies"]*(dwell_SN/100)*(dwellings_size.loc[str(mun), "1-2 dwelling"]*((1.03*679*0.24) + ((1283 + 1256)*0.84) + (1367 + 7895)*0.15)) + dwellings_ownership.loc[str(mun), "Swedish joint-stock companies"]*(dwell_SN/100)*(dwellings_size.loc[str(mun), "Multi-dwelling"]*((0.38*679*0.24) + ((1283 + 1256)*0.51) + (1367 + 7895)*0.13)))/pop.loc[str(mun), 2019]
    el_pc = (BATel/100)*dwellings_ownership.loc[str(mun), "Swedish joint-stock companies"]*dwellings_stock.loc[str(mun), "Housing stock"]*(8990 + 13950 + 11500 + 12100 + 20347 + 14770 + 30*40)/pop.loc[str(mun), 2019]
    vehicles_mun = np.mean([9000, 9995, 9122.67])*((100 - cars_givenup)/100)*(share_elcars/100)*cars_2030/(10*pop.loc[str(mun), 2019])

    vehicles_total = cars.loc[str(mun), "Number of cars"]*pop_growth*((100 - cars_givenup)/100)*(share_elcars/100)*np.mean([9000, 9995, 9122.67])/(10*pop.loc[str(mun), 2019]) + ((100 - cars_givenup)/100)*cars.loc[str(mun), "Number of cars"]*pop_growth*((share_elcars/100)*600000 + (share_hydrcar/100)*775000 + (share_plugincar/100)*580000)/pop.loc[str(mun), 2019]
    el_total = (BATel/100)*dwellings_stock.loc[str(mun), "Housing stock"]*(8990 + 13950 + 11500 + 12100 + 20347 + 14770 + 30*40)/(pop.loc[str(mun), 2019])
    heating_total = ((dwell_SN/100)*(dwellings_size.loc[str(mun), "1-2 dwelling"]*((1.03*679*0.24) + ((1283 + 1256)*0.84) + (1367 + 7895)*0.15)) + (dwell_SN/100)*(dwellings_size.loc[str(mun), "Multi-dwelling"]*((0.38*679*0.24) + ((1283 + 1256)*0.51) + (1367 + 7895)*0.13)))/pop.loc[str(mun), 2019]
    
    # Distribution to actors ... NEW
    vehicles_costs_citizens = vehicles_costs_nl+ vehicles_costs_l
    Vehicles_costs_public = vehicles_mun+vehicles_mhc
    
    Food_Mun_gov = 0
    Food_cit = 0
    Food_industry = 0
    Food_civil = 0
    Food_SG = 0
    Food_UC = 0
    Food_FI = 0
    total_food = Food_Mun_gov+Food_cit+Food_industry+Food_civil+Food_SG+Food_UC+Food_FI
    Clothing_Mun_gov = 0
    Clothing_cit = 0
    Clothing_industry = 0
    Clothing_civil = 0
    Clothing_SG = 0
    Clothing_UC = 0
    Clothing_FI = 0
    total_clothing = Clothing_Mun_gov + Clothing_cit + Clothing_industry + Clothing_civil + Clothing_SG + Clothing_UC + Clothing_FI
    Housing_Mun_gov = el_mhc + heating_mhc
    Housing_cit = el_l + heating_l
    Housing_industry = 0
    Housing_civil = 0
    Housing_SG = 0
    Housing_UC = 0
    Housing_FI = 0
    total_Housing = Housing_Mun_gov + Housing_cit + Housing_industry + Housing_civil + Housing_SG + Housing_UC + Housing_FI
    TRNS_Mun_gov = 0
    TRNS_cit = vehicles_costs_pc + heating_pc + el_pc
    TRNS_industry = 0
    TRNS_civil = 0
    TRNS_SG = 0
    TRNS_UC = 0
    TRNS_FI = 0
    total_TRNS = TRNS_Mun_gov + TRNS_cit + TRNS_industry + TRNS_civil + TRNS_SG + TRNS_UC + TRNS_FI
    Air_Mun_gov = 0
    Air_cit = 0
    Air_industry = 0
    Air_civil = 0
    Air_SG = 0
    Air_UC = 0
    Air_FI = 0
    total_Air = Air_Mun_gov + Air_cit + Air_industry + Air_civil + Air_SG + Air_UC + Air_FI
    rc_Mun_gov = public_transport+vehicles_mhc+vehicles_mun
    rc_cit = vehicles_costs_nl+vehicles_costs_l
    rc_industry = 0
    rc_civil = 0
    rc_SG = 0
    rc_UC = 0
    rc_FI = 0
    total_rc = rc_Mun_gov + rc_cit + rc_industry + rc_civil + rc_SG + rc_UC + rc_FI
    rh_Mun_gov = 0
    rh_cit = 0
    rh_industry = 0
    rh_civil = 0
    rh_SG = 0
    rh_UC = 0
    rh_FI = 0
    total_rh = rh_Mun_gov + rh_cit + rh_industry + rh_civil + rh_SG + rh_UC + rh_FI
    veh_Mun_gov = 0
    veh_cit = 0
    veh_industry = 0
    veh_civil = 0
    veh_SG = 0
    veh_UC = 0
    veh_FI = 0
    total_veh = veh_Mun_gov + veh_cit + veh_industry + veh_civil + veh_SG + veh_UC + veh_FI
    el_Mun_gov = 0
    el_cit = 0
    el_industry = 0
    el_civil = 0
    el_SG = 0
    el_UC = 0
    el_FI = 0
    total_el = el_Mun_gov + el_cit + el_industry + el_civil + el_SG + el_UC + el_FI
    dh_Mun_gov = 0
    dh_cit = 0
    dh_industry = 0
    dh_civil = 0
    dh_SG = 0
    dh_UC = 0
    dh_FI = 0
    total_dh = dh_Mun_gov + dh_cit + dh_industry + dh_civil + dh_SG + dh_UC + dh_FI
    hh_Mun_gov = 0
    hh_cit = 0
    hh_industry = 0
    hh_civil = 0
    hh_SG = 0
    hh_UC = 0
    hh_FI = 0
    total_hh = hh_Mun_gov + hh_cit + hh_industry + hh_civil + hh_SG + hh_UC + hh_FI

    hrz = ["Total","Municpal Goverment", "Citizens", "Industry", "Civil soceity", "Superordinate Goverment", "Utility companies", "Financial institutions"]
    
    fig = go.Figure()
    Food = [total_food,Food_Mun_gov,Food_cit,Food_industry,Food_civil,Food_SG,Food_UC,Food_FI]
    Clothing= [total_clothing,Clothing_Mun_gov,Clothing_cit,Clothing_industry,Clothing_civil,Clothing_SG,Clothing_UC,Clothing_FI]
    Housing = [total_Housing,Housing_Mun_gov,Housing_cit,Housing_industry,Housing_civil,Housing_SG,Housing_UC,Housing_FI]
    TRNS = [total_TRNS,TRNS_Mun_gov,TRNS_cit,TRNS_industry,TRNS_civil,TRNS_SG,TRNS_UC,TRNS_FI]
    Air = [total_Air,Air_Mun_gov, Air_cit, Air_industry, Air_civil,Air_SG,Air_UC,Air_FI]
    rc =[total_rc,rc_Mun_gov, rc_cit, rc_industry, rc_civil,rc_SG,rc_UC,rc_FI] 
    rh = [total_rh,rh_Mun_gov, rh_cit, rh_industry, rh_civil,rh_SG,rh_UC,rh_FI]
    veh = [total_veh,veh_Mun_gov, veh_cit, veh_industry, veh_civil,veh_SG,veh_UC,veh_FI]
    el = [total_el,el_Mun_gov, el_cit, el_industry, el_civil,el_SG,el_UC,el_FI]
    dh = [total_dh,dh_Mun_gov, dh_cit, dh_industry, dh_civil,dh_SG,dh_UC,dh_FI]
    hh = [total_hh,hh_Mun_gov, hh_cit, hh_industry, hh_civil,hh_SG,hh_UC,hh_FI]    
    
    fig.add_bar(x=hrz, y=Food, name="Food", marker=dict(color="#636EFA"))
    fig.add_bar(x=hrz, y=Clothing, name="Clothing", marker=dict(color="#EF553B"))
    fig.add_bar(x=hrz, y=Housing, name="Housing", marker=dict(color="#00CC96"))
    fig.add_bar(x=hrz, y=TRNS, name="Transport", marker=dict(color="#B6E880"))
    fig.add_bar(x=hrz, y=Air, name="Air transport", marker=dict(color="#FFA15A"))
    fig.add_bar(x=hrz, y=rc, name="Recreation", marker=dict(color="#19D3F3"))
    fig.add_bar(x=hrz, y=rh, name="Restaurants and hotels", marker=dict(color="#FF6692"))
    fig.add_bar(x=hrz, y=veh, name="Vehicles", marker=dict(color="#FF97FF"))
    fig.add_bar(x=hrz, y=el, name="Electricity", marker=dict(color="#FECB52"))
    fig.add_bar(x=hrz, y=dh, name="District heating", marker=dict(color="#DB00FF"))
    fig.add_bar(x=hrz, y=hh, name="House heating", marker=dict(color="#FE6100"))
    
    fig.update_layout(
        barmode="stack",  # Set the barmode to 'stack' for stacked bars
        margin=go.layout.Margin(l=40, r=20, b=5, t=60),
        autosize=True,
        title_text="Per capita CAPEX expenditure in {} (SEK)".format(mun),
        title_font=dict(size=18, color="darkred")
    )
    
    return [fig]
    
@app.callback(
        [Output("opex-CBE-graph", "figure")],
        [Input("municipality-dropdown", "value"), Input("slider-1", "value"), Input("slider-2", "value"),
         Input("slider-3", "value"), Input("slider-4", "value"), Input("slider-5", "value"), Input("slider-6", "value"),
         Input("slider-7", "value"), Input("slider-8", "value"), Input("slider-13", "value"),
         Input("slider-14", "value"), Input("slider-15", "value"), Input("slider-16", "value"),
         Input("slider-18", "value"), Input("slider-9", "value"), Input("slider-10", "value"),
         Input("slider-11", "value"), Input("slider-12", "value"), Input("slider-17", "value"),
         Input("slider-19", "value"), Input("slider-20", "value"), Input("slider-21", "value"),
         Input("slider-22", "value"), Input("slider-25", "value"), Input("slider-24", "value"),
         Input("slider-26", "value"), Input("slider-23", "value")]
)

def opex_CBE_costplot(mun, vegan, veg, meat, nutrition, diet, reduction_clothes, doubling_clothes, half_furn, red_air,
                  double_life, package_holidays, rh_share, cars_givenup, share_elbus, share_HVObus, share_currentmixbus,
                  share_hibHVObus, share_elcars, share_currentmixcar, share_plugincar, share_hydrcar, BATel, dwell_unchanged,
                  dwell_20C, dwell_SN, dh_red):

    if dh_red is None:
        dh_red = 0
    if dwell_unchanged is None:
        dwell_unchanged = 0
    if dwell_20C is None:
        dwell_20C = 0
    if dwell_SN is None:
        dwell_SN = 0
    if share_hydrcar is None:
        share_hydrcar = 0
    if share_plugincar is None:
        share_plugincar = 0
    if share_currentmixcar is None:
        share_currentmixcar = 0
    if share_elcars is None:
        share_elcars = 0
    if reduction_clothes is None:
        reduction_clothes = 0
    if doubling_clothes is None:
        doubling_clothes = 0
    if half_furn is None:
        half_furn = 0
    if red_air is None:
        red_air = 0
    if double_life is None:
        double_life = 0
    if package_holidays is None:
        package_holidays = 0
    if rh_share is None:
        rh_share = 0
    if cars_givenup is None:
        cars_givenup = 0
    if nutrition is None:
        nutrition = 0
    if diet is None:
        diet = 0
    if meat is None:
        meat = 0
    if veg is None:
        veg = 0
    if vegan is None:
        vegan = 0
    if share_elbus is None:
        share_elbus = 0
    if share_currentmixbus is None:
        share_currentmixbus = 0
    if share_HVObus is None:
        share_HVObus = 0
    if share_hibHVObus is None:
        share_hibHVObus = 0
    if BATel is None:
        BATel = 0

    if mun is None:
        fig = go.Figure()
        fig.add_annotation(
            x=2.7,
            y=1.8,
            text="Please make sure to select a municipality from the list above.",
            showarrow=False,
            font=dict(
                size=20
            ),
            bordercolor="#c7c7c7",
            borderwidth=2,
            borderpad=4,
            bgcolor="#ff7f0e",
            opacity=0.8
        )
        return [go.Figure(data=fig)]


    share_currentmixbus = 100 - share_elbus - share_HVObus - share_hibHVObus
    diet = 100 - vegan - veg - meat - nutrition
    share_currentmixcar = 100 - share_elcars - share_plugincar - share_hydrcar - cars_givenup
    dwell_unchanged = 100-max([dwell_unchanged, dwell_20C])

    pop_growth = pop.loc[str(mun), 2030] / pop.loc[str(mun), 2019]
    pop_car_ratio = pop.loc[str(mun), 2019] / cars.loc[str(mun), "Number of cars"]
    cars_2030 = pop_growth * cars.loc[str(mun), "Number of cars"]
    bus_capacity = 130
    buses_2030 = pop_growth * buses.loc[str(mun), "Total"]
    total_buses_2030 = buses_2030 + ((cars_givenup / 100) * cars_2030 * pop_car_ratio / bus_capacity)
    bus_increase = total_buses_2030 / buses_2030
    share_diesel_bus = buses.loc[str(mun), "Diesel"] / buses.loc[str(mun), "Total"]
    regional_pop = reg_pop.loc[regions.loc[str(mun)], "Pop"]
    mun_share = pop.loc[str(mun), 2019]/regional_pop

#The opex on public transport for the public transport company will be the last one analyzed as it entails some complicated assumptions
    opex_vehicles_nl = float(pop_growth*cars.loc[str(mun), "Privates-cars"]*(100 - cars_givenup)*(0.01)*(((share_elcars/100)*0.861586*0.221*distance.loc[str(mun)] + (share_elcars/100)*distance.loc[str(mun)]*1659.96*73/150000)*12 + (share_hydrcar/100)*np.average([29.4, 28.4, 19.4, 27.37])*distance.loc[str(mun)]*0.00875*12 + ((share_plugincar/100)*0.861586*0.221*distance.loc[str(mun)]*0.46 + (share_elcars/100)*distance.loc[str(mun)]*0.46*1659.96*73/150000)*12)/(pop.loc[str(mun), 2019:2030].sum()))
    opex_pt_nl = float(pt_cost.loc[regions.loc[str(mun)], "Annual cost"]*12*(cars_givenup/100)*cars_2030*pop_car_ratio/pop.loc[str(mun), 2019:2030].sum())
    opex_vehicles_l = float(pop_growth*cars.loc[str(mun), "Privates-cars"]*(100 - cars_givenup)*(0.01)*(((share_elcars/100)*0.861586*0.221*distance.loc[str(mun)] + (share_elcars/100)*distance.loc[str(mun)]*1659.96*73/150000)*12 + (share_hydrcar/100)*np.average([29.4, 28.4, 19.4, 27.37])*distance.loc[str(mun)]*0.00875*12 + ((share_plugincar/100)*0.861586*0.221*distance.loc[str(mun)]*0.46 + (share_elcars/100)*distance.loc[str(mun)]*0.46*1659.96*73/150000)*12)/(pop.loc[str(mun), 2019:2030].sum()))
    opex_pt_l = float(pt_cost.loc[regions.loc[str(mun)], "Annual cost"] * 12 * (cars_givenup / 100) * cars_2030 * pop_car_ratio / pop.loc[str(mun), 2019:2030].sum())
    #opex_district_heating = (dh_red/100)*(dh.loc[str(mun), "Stenkol (GWh)":"Övrigt fossilt bränsle (GWh)"].sum() + dh.loc[str(mun), "Flue gas condensation energy of fossil origin (GWh)"])*1000*(211849 + 6)/pop.loc[str(mun), 2019].sum()
    opex_vehicles_pb = float(pop_growth*cars.loc[str(mun), "JP-cars"]*(100 - cars_givenup)*(0.01)*(((share_elcars/100)*0.861586*0.221*distance.loc[str(mun)] + (share_elcars/100)*distance.loc[str(mun)]*1659.96*73/150000)*12 + (share_hydrcar/100)*np.average([29.4, 28.4, 19.4, 27.37])*distance.loc[str(mun)]*0.00875*12 + ((share_plugincar/100)*0.861586*0.221*distance.loc[str(mun)]*0.46 + (share_elcars/100)*distance.loc[str(mun)]*0.46*1659.96*73/150000)*12)/(pop.loc[str(mun), 2019:2030].sum()))
    opex_public_transport = float((bus_increase*offered_pt.loc[regions.loc[str(mun)], "Distance"]*mun_share*((share_elbus/100)*(3.3 + 0.82*1.053) + ((share_hibHVObus + share_HVObus)/100)*(3 + 3.6*3.5)) + total_buses_2030*(share_elbus/100)*4000*470/12)*12/pop.loc[str(mun), 2019:2030].sum())

    opex_vehicles_total =  float(pop_growth*cars.loc[str(mun), "Number of cars"]*(100 - cars_givenup)*(0.01)*(((share_elcars/100)*0.861586*0.221*distance.loc[str(mun)] + (share_elcars/100)*distance.loc[str(mun)]*1659.96*73/150000)*12 + (share_hydrcar/100)*np.average([29.4, 28.4, 19.4, 27.37])*distance.loc[str(mun)]*0.00875*12 + ((share_plugincar/100)*0.861586*0.221*distance.loc[str(mun)]*0.46 + (share_elcars/100)*distance.loc[str(mun)]*0.46*1659.96*73/150000)*12)/(pop.loc[str(mun), 2019:2030].sum()))
    opex_pt_total = float(pt_cost.loc[regions.loc[str(mun)], "Annual cost"]*12*(cars_givenup/100)*cars_2030*pop_car_ratio/pop.loc[str(mun), 2019:2030].sum()) + float((bus_increase*offered_pt.loc[regions.loc[str(mun)], "Distance"]*mun_share*((share_elbus/100)*(3.3 + 0.82*1.053) + ((share_hibHVObus + share_HVObus)/100)*(3 + 3.6*3.5)) + total_buses_2030*(share_elbus/100)*4000*470/12)*12/pop.loc[str(mun), 2019:2030].sum())


    hrz = ["Total", "Food", "Clothing", "Housing", "Health", "Air transport", "Recreation",
           "Restaurants and hotels", "Public transport", "Vehicles", "Electricity", "Heating", "District heating",
           "Others"]

    Food_Mun_gov = 0
    Food_cit = 0
    Food_industry = 0
    Food_civil = 0
    Food_SG = 0
    Food_UC = 0
    Food_FI = 0
    total_food = Food_Mun_gov+Food_cit+Food_industry+Food_civil+Food_SG+Food_UC+Food_FI
    Clothing_Mun_gov = 0
    Clothing_cit = 0
    Clothing_industry = 0
    Clothing_civil = 0
    Clothing_SG = 0
    Clothing_UC = 0
    Clothing_FI = 0
    total_clothing = Clothing_Mun_gov + Clothing_cit + Clothing_industry + Clothing_civil + Clothing_SG + Clothing_UC + Clothing_FI
    Housing_Mun_gov = 0
    Housing_cit = 0
    Housing_industry = 0
    Housing_civil = 0
    Housing_SG = 0
    Housing_UC = 0
    Housing_FI = 0
    total_Housing = Housing_Mun_gov + Housing_cit + Housing_industry + Housing_civil + Housing_SG + Housing_UC + Housing_FI
    TRNS_Mun_gov = 0
    TRNS_cit = 0
    TRNS_industry = 0
    TRNS_civil = 0
    TRNS_SG = 0
    TRNS_UC = 0
    TRNS_FI = 0
    total_TRNS = TRNS_Mun_gov + TRNS_cit + TRNS_industry + TRNS_civil + TRNS_SG + TRNS_UC + TRNS_FI
    Air_Mun_gov = 0
    Air_cit = 0
    Air_industry = 0
    Air_civil = 0
    Air_SG = 0
    Air_UC = 0
    Air_FI = 0
    total_Air = Air_Mun_gov + Air_cit + Air_industry + Air_civil + Air_SG + Air_UC + Air_FI
    rc_Mun_gov = 0
    rc_cit = 0
    rc_industry = 0
    rc_civil = 0
    rc_SG = 0
    rc_UC = 0
    rc_FI = 0
    total_rc = rc_Mun_gov + rc_cit + rc_industry + rc_civil + rc_SG + rc_UC + rc_FI
    rh_Mun_gov = 0
    rh_cit = 0
    rh_industry = 0
    rh_civil = 0
    rh_SG = 0
    rh_UC = 0
    rh_FI = 0
    total_rh = rh_Mun_gov + rh_cit + rh_industry + rh_civil + rh_SG + rh_UC + rh_FI
    veh_Mun_gov = 0
    veh_cit = 0
    veh_industry = 0
    veh_civil = 0
    veh_SG = 0
    veh_UC = 0
    veh_FI = 0
    total_veh = veh_Mun_gov + veh_cit + veh_industry + veh_civil + veh_SG + veh_UC + veh_FI
    el_Mun_gov = 0
    el_cit = 0
    el_industry = 0
    el_civil = 0
    el_SG = 0
    el_UC = 0
    el_FI = 0
    total_el = el_Mun_gov + el_cit + el_industry + el_civil + el_SG + el_UC + el_FI
    dh_Mun_gov = 0
    dh_cit = 0
    dh_industry = 0
    dh_civil = 0
    dh_SG = 0
    dh_UC = 0
    dh_FI = 0
    total_dh = dh_Mun_gov + dh_cit + dh_industry + dh_civil + dh_SG + dh_UC + dh_FI
    hh_Mun_gov = 0
    hh_cit = 0
    hh_industry = 0
    hh_civil = 0
    hh_SG = 0
    hh_UC = 0
    hh_FI = 0
    total_hh = hh_Mun_gov + hh_cit + hh_industry + hh_civil + hh_SG + hh_UC + hh_FI
    
    hrz = ["Total","Municpal Goverment", "Citizens", "Industry", "Civil soceity", "Superordinate Goverment", "Utility companies", "Financial institutions"]
    
    fig = go.Figure()
    Food = [total_food,Food_Mun_gov,Food_cit,Food_industry,Food_civil,Food_SG,Food_UC,Food_FI]
    Clothing= [total_clothing,Clothing_Mun_gov,Clothing_cit,Clothing_industry,Clothing_civil,Clothing_SG,Clothing_UC,Clothing_FI]
    Housing = [total_Housing,Housing_Mun_gov,Housing_cit,Housing_industry,Housing_civil,Housing_SG,Housing_UC,Housing_FI]
    TRNS = [total_TRNS,TRNS_Mun_gov,TRNS_cit,TRNS_industry,TRNS_civil,TRNS_SG,TRNS_UC,TRNS_FI]
    Air = [total_Air,Air_Mun_gov, Air_cit, Air_industry, Air_civil,Air_SG,Air_UC,Air_FI]
    rc =[total_rc,rc_Mun_gov, rc_cit, rc_industry, rc_civil,rc_SG,rc_UC,rc_FI] 
    rh = [total_rh,rh_Mun_gov, rh_cit, rh_industry, rh_civil,rh_SG,rh_UC,rh_FI]
    veh = [total_veh,veh_Mun_gov, veh_cit, veh_industry, veh_civil,veh_SG,veh_UC,veh_FI]
    el = [total_el,el_Mun_gov, el_cit, el_industry, el_civil,el_SG,el_UC,el_FI]
    dh = [total_dh,dh_Mun_gov, dh_cit, dh_industry, dh_civil,dh_SG,dh_UC,dh_FI]
    hh = [total_hh,hh_Mun_gov, hh_cit, hh_industry, hh_civil,hh_SG,hh_UC,hh_FI]    
    
    fig.add_bar(x=hrz, y=Food, name="Food", marker=dict(color="#636EFA"))
    fig.add_bar(x=hrz, y=Clothing, name="Clothing", marker=dict(color="#EF553B"))
    fig.add_bar(x=hrz, y=Housing, name="Housing", marker=dict(color="#00CC96"))
    fig.add_bar(x=hrz, y=TRNS, name="Transport", marker=dict(color="#B6E880"))
    fig.add_bar(x=hrz, y=Air, name="Air transport", marker=dict(color="#FFA15A"))
    fig.add_bar(x=hrz, y=rc, name="Recreation", marker=dict(color="#19D3F3"))
    fig.add_bar(x=hrz, y=rh, name="Restaurants and hotels", marker=dict(color="#FF6692"))
    fig.add_bar(x=hrz, y=veh, name="Vehicles", marker=dict(color="#FF97FF"))
    fig.add_bar(x=hrz, y=el, name="Electricity", marker=dict(color="#FECB52"))
    fig.add_bar(x=hrz, y=dh, name="District heating", marker=dict(color="#DB00FF"))
    fig.add_bar(x=hrz, y=hh, name="House heating", marker=dict(color="#FE6100"))
    
    fig.update_layout(
        barmode="stack",  # Set the barmode to 'stack' for stacked bars
        margin=go.layout.Margin(l=40, r=20, b=5, t=60),
        autosize=True,
        title_text="Per capita CAPEX expenditure in {} (SEK)".format(mun),
        title_font=dict(size=18, color="darkred")
    )
    
    return [fig]


@app.callback(
    [Output("results-graph-2", "figure"), Output("slider-31", "value"), Output("slider-36", "value"),Output("slider-47", "value"),
     Output("slider-52", "value"), Output("dd-emissions-value2", "data"),Output("CI-TBE-graph", "figure"),Output("dd-ci-value", "data")],
    [Input("municipality-dropdown", "value"), Input("slider-27", "value"), Input("slider-28", "value"),
     Input("slider-29", "value"), Input("slider-30", "value"), Input("slider-31", "value"), Input("slider-32", "value"),
     Input("slider-33", "value"), Input("slider-34", "value"), Input("slider-35", "value"), Input("slider-36", "value"),
     Input("slider-37", "value"), Input("slider-38", "value"), Input("slider-39", "value"), Input("slider-40", "value"),
     Input("slider-41", "value"),Input("slider-42", "value"), Input("slider-43", "value"),
      Input("slider-44", "value"), Input("slider-45", "value"), Input("slider-46", "value"), Input("slider-47", "value"),
      Input("slider-48", "value"), Input("slider-49", "value"), Input("slider-50", "value"), Input("slider-51", "value"),
      Input("slider-52", "value"), Input("slider-53", "value"), Input("slider-54", "value"),Input("slider-541", "value"), Input("slider-55", "value"),
      Input("slider-56", "value"),Input("slider-57", "value"), Input("scenario-dropdown-list-2", "value"), Input("emissions-dropdown-list", "value"),Input('CCS-input', "value"),Input('RENB-input', "value"),
      Input('AIT-input', "value"),Input('AT-input', "value"),Input('RC-input', "value"),Input('CCSW-input', "value"),Input('W-input', "value"),Input('RS-input', "value"),
      Input('CS-input', "value"),Input('DHP-input', "value"),Input('Hyd-input', "value"),Input('Bioccs-input', "value"),Input('RW-input', "value"),Input('CC-input', "value"), Input("ci-dropdown-list", "value")]
)

def render_page_3(mun, agr, cmu, el_bus, ren_bus, current_fuel_bus, air_transp, el_car, act_trans, pt_car, current_fuel_car, ph_car, hydr_car,
                  LBG_heavy, electric_heavy,LBG_light, electric_light,ccsw, wind, rtsolar, csolar, current_energymix, DH_heatpumps, ind_temp_red, sn_measure, 
                  BAT_appl, no_heat_measure,CCS_industry,H2_industry, wm, bio_ccs, rewetting_emissions, carbon_credit, scenario,emissions_output, ccs_year, RENB_year, AIT_year, AT_year, RC_year, CCSW_year,
                  W_year, RS_year, CS_year, DHP_year, Hyd_year, Bioccs_year, RW_year, CC_year, ci_dropdown):
    if mun is None:
        fig = go.Figure(go.Scatter())  # Create a figure with an empty scatter trace
        fig.add_annotation(
            x=0.5,
            y=0.5,
            text="Please make sure to select a municipality from above",
            showarrow=False,
            font=dict(size=20),
            bordercolor="#c7c7c7",
            borderwidth=2,
            borderpad=4,
            bgcolor="#ff7f0e",
            opacity=0.8
        )
        return [fig, current_fuel_bus, current_fuel_car, no_heat_measure, current_energymix, None, fig, None]

    elif emissions_output is None:
        fig = go.Figure(go.Scatter())  # Create a figure with an empty scatter trace
        fig.add_annotation(
            x=0.5,
            y=0.5,
            text="Please make sure to select an emission output",
            showarrow=False,
            font=dict(size=20),
            bordercolor="#c7c7c7",
            borderwidth=2,
            borderpad=4,
            bgcolor="#ff7f0e",
            opacity=0.8
        )
        return [fig, current_fuel_bus, current_fuel_car, no_heat_measure, current_energymix, None, fig, None]

################## need to create a statement for CI graph########################
    if agr is None:
        agr = 0
    if cmu is None:
        cmu = 0
    if el_bus is None:
        el_bus = 0
    if ren_bus is None:
        ren_bus = 0
    if current_fuel_bus is None:
        current_fuel_bus = 0
    if air_transp is None:
        air_transp = 0
    if el_car is None:
        el_car = 0
    if act_trans is None:
        act_trans = 0
    if pt_car is None:
        pt_car = 0
    if current_fuel_car is None:
        current_fuel_car = 0
    if ph_car is None:
        ph_car = 0
    if hydr_car is None:
        hydr_car = 0
    if LBG_heavy is None:
        LBG_heavy = 0
    if electric_heavy is None:
        electric_heavy = 0
    if LBG_light is None:
        LBG_light = 0
    if electric_light is None:
        electric_light = 0
    if ccsw is None:
        ccsw = 0
    if wind is None:
        wind = 0
    if rtsolar is None:
        rtsolar = 0
    if csolar is None:
        csolar = 0
    if current_energymix is None:
        current_energymix = 0
    if DH_heatpumps is None:
        DH_heatpumps = 0
    if ind_temp_red is None:
        ind_temp_red = 0
    if sn_measure is None:
        sn_measure = 0
    if BAT_appl is None:
        BAT_appl = 0
    if no_heat_measure is None:
        no_heat_measure = 0
    if CCS_industry is None:
        CCS_industry = 0
    if H2_industry is None:
        H2_industry = 0
    if bio_ccs is None:
        bio_ccs = 0
    if rewetting_emissions is None:
        rewetting_emissions = 0
    if carbon_credit is None:
        carbon_credit = 0
    if wm is None:
        wm = 0


    current_fuel_bus = (100 - el_bus - ren_bus)
    current_fuel_car = (100 - el_car - pt_car - ph_car - hydr_car - act_trans)
    current_energymix = (100 - wind - rtsolar - csolar)
    no_heat_measure = (100 - ind_temp_red - sn_measure- BAT_appl)

    Electricity_emission_intensity = 1
    Biogas_emission_intensity = 0.81

    caremission_intensity_EV = Electricity_emission_intensity
    caremission_intensity_PIH = 0.703703
    caremission_intensity_Hydrogen = 1

    busemission_intensity_EV = 1
    busemission_intensity_ren = 0.855

    HT_emission_intensity_EV = 1
    HT_emission_intensity_LBG = 0.81

    LT_emission_intensity_EV = 1
    LT_emission_intensity_LBG = 0.81

    ccs_emission_intensity = 0.90
    hyd_emission_intensity = 1
    ccsw_emission_intensity = 0.90
    agr_emission_intensity = 1

    BAT_energy_consumption_impact = 0.207483
    Ind_temp_impact = 0.16
    SN_eff_impact = 0.17

    Share_elec_DH = (el_shares.loc[str(mun), "El share"])
    Wind_emissions_intensity = 1
    Solar_emission_intensity = 1

    Share_DH_HP_air = 1 / 3
    Share_DH_HP_water = 1 / 3
    Share_DH_HP_GT = 1 / 3
    emission_savings_air = 1
    emission_savings_water = 1
    emission_savings_GT = 1

    Share_landfill_samecity = 1

    cars = (tbe_emissions.loc[str(mun), "Passenger cars"] * (1 - ((pt_car / 100) + (act_trans / 100) + ((el_car / 100) * caremission_intensity_EV) + ( (ph_car / 100) * caremission_intensity_PIH) + ((hydr_car / 100) * caremission_intensity_Hydrogen)))).sum()
    buses = (tbe_emissions.loc[str(mun), "Buses"] * (1 - ((el_bus / 100) * busemission_intensity_EV + (ren_bus / 100) * busemission_intensity_ren))).sum()
    heavy_trucks = (tbe_emissions.loc[str(mun), "Heavy trucks"] * (1 - ((LBG_heavy / 100) * HT_emission_intensity_LBG + (electric_heavy / 100) * HT_emission_intensity_EV))).sum()
    light_trucks = (tbe_emissions.loc[str(mun), "Light trucks"] * (1 - ((LBG_light / 100) * LT_emission_intensity_LBG + (electric_light / 100) * LT_emission_intensity_EV))).sum()
    air_transport = tbe_emissions.loc[str(mun), "Domestic air traffic"] * (1 - (air_transp / 100))
    Other_transport = (tbe_emissions.loc[str(mun),"Wear and tear from tires and brakes": "Domestic civil shipping (incl. private pleasure craft)"].sum() + tbe_emissions.loc[ str(mun),
                                                                                                                                "Railway":"Military transport"].sum() + \
                       tbe_emissions.loc[str(mun), "Mopeds and Motorcycles"]) * (1 - ((act_trans / 100) + (pt_car / 100)))

    transport_cal = (cars + buses + heavy_trucks + light_trucks + air_transport + Other_transport)
    industry_cal = (tbe_emissions.loc[str(mun), "Industry (energy + processes)"] * ( 1 - ((CCS_industry / 100) * ccs_emission_intensity + (H2_industry / 100) * hyd_emission_intensity))).sum()
    agriculture_cal = (tbe_emissions.loc[str(mun), "Animal digestion":"Other fertilizers"].sum() * (1 - (((agr / 100) * (agr_emission_intensity))))).sum()
    el_dh_cal = tbe_emissions.loc[str(mun), "Electricity and district heating"] * (((1 - ((BAT_appl / 100) * BAT_energy_consumption_impact + (ind_temp_red / 100) * Ind_temp_impact + (
            sn_measure / 100) * SN_eff_impact)) * ((1 - ( (Share_elec_DH) * ( ((wind / 100) * Wind_emissions_intensity) + ((rtsolar / 100) * Solar_emission_intensity) + (
                (csolar / 100) * Solar_emission_intensity)) + ((1 - Share_elec_DH) * (DH_heatpumps / 100) * (((Share_DH_HP_air * emission_savings_air) + (Share_DH_HP_water * emission_savings_water) + (
            Share_DH_HP_GT * emission_savings_GT)))))))) * (1 - ((ccsw / 100) * ccsw_emission_intensity)))
    own_heating_cal = (tbe_emissions.loc[str(mun), "Housing":"Agricultural and forestry premises"].sum() * ((1 - ((BAT_appl / 100) * BAT_energy_consumption_impact + (ind_temp_red / 100) * Ind_temp_impact + (sn_measure / 100) * SN_eff_impact)))).sum()
    work_machines_cal = (tbe_emissions.loc[str(mun), "Scooters and quad bikes":"Other (airports, ports, m.m.)"].sum() *(1 - (((wm / 100)))))
    product_use_cal = tbe_emissions.loc[str(mun), "Solvent use - operations":"Other product use"].sum()
    waste_cal = tbe_emissions.loc[str(mun), "Landfills":"Other waste management"].sum() * (1 - ((cmu / 100) * Share_landfill_samecity))
    foreign_transport_cal = tbe_emissions.loc[str(mun), "Foreign shipping within Sweden's borders": "International flights below 1000 m altitude in Swedish airspace"].sum()
    Negatives_cal = tbe_emissions.loc[str(mun), "Passenger cars":"International flights below 1000 m altitude in Swedish airspace"].sum() * ((((bio_ccs / 100) + (rewetting_emissions / 100) + (carbon_credit / 100))))

    #Per capita
    transport = 1000*transport_cal/pop.loc[str(mun), 2021]
    industry = 1000*industry_cal/pop.loc[str(mun), 2021]
    agriculture = 1000*agriculture_cal/pop.loc[str(mun), 2021]
    el_dh = 1000*el_dh_cal/pop.loc[str(mun), 2021]
    own_heating = 1000*own_heating_cal/pop.loc[str(mun), 2021]
    work_machines = 1000*work_machines_cal/pop.loc[str(mun), 2021]
    product_use = 1000*product_use_cal/pop.loc[str(mun), 2021]
    waste = 1000*waste_cal/pop.loc[str(mun), 2021]
    foreign_transport = 1000*foreign_transport_cal/pop.loc[str(mun), 2021]
    Negatives = 1000*Negatives_cal/pop.loc[str(mun), 2021]
    #Negatives = 1
 
    cars_2019 = 1000 * tbe_emissions.loc[str(mun), "Passenger cars"] / pop.loc[str(mun), 2021]
    buses_2019 = 1000 * tbe_emissions.loc[str(mun), "Buses"] / pop.loc[str(mun), 2021]
    heavy_trucks_2019 = 1000 * tbe_emissions.loc[str(mun), "Heavy trucks"] / pop.loc[str(mun), 2021]
    light_trucks_2019 = 1000 * tbe_emissions.loc[str(mun), "Light trucks"] / pop.loc[str(mun), 2021]
    air_transport_2019 = 1000 * tbe_emissions.loc[str(mun), "Domestic air traffic"] / pop.loc[str(mun), 2021]
    other_transport_2019 = 1000 * (tbe_emissions.loc[str(mun), "Mopeds and Motorcycles"] +  tbe_emissions.loc[str(mun), "Wear and tear from tires and brakes": "Domestic civil shipping (incl. private pleasure craft)"].sum() +
                                    tbe_emissions.loc[str(mun), "Railway":"Military transport"].sum()) / pop.loc[str(mun), 2021]
    transport_2019 =  cars_2019 + buses_2019 + heavy_trucks_2019 + light_trucks_2019 + air_transport_2019 + other_transport_2019
    industry_2019 = 1000*tbe_emissions.loc[str(mun), "Industry (energy + processes)"]/pop.loc[str(mun), 2021]
    agriculture_2019 = 1000*tbe_emissions.loc[str(mun), "Animal digestion":"Other fertilizers"].sum()/pop.loc[str(mun), 2021]
    el_dh_2019 = 1000*tbe_emissions.loc[str(mun), "Electricity and district heating"]/pop.loc[str(mun), 2021]
    own_heating_2019 = 1000*tbe_emissions.loc[str(mun), "Housing":"Agricultural and forestry premises"].sum()/pop.loc[str(mun), 2021]
    work_machines_2019 = 1000*tbe_emissions.loc[str(mun), "Scooters and quad bikes":"Other (airports, ports, m.m.)"].sum()/pop.loc[str(mun), 2021]
    product_use_2019 = 1000*tbe_emissions.loc[str(mun), "Solvent use - operations":"Other product use"].sum()/pop.loc[str(mun), 2021]
    waste_2019 = 1000*tbe_emissions.loc[str(mun), "Landfills":"Other waste management"].sum()/pop.loc[str(mun), 2021]
    foreign_transport_2019 = 1000*tbe_emissions.loc[str(mun), "Foreign shipping within Sweden's borders": "International flights below 1000 m altitude in Swedish airspace"].sum()/pop.loc[str(mun), 2021]
    Negatives_2019 = 0 #1000*tbe_emissions.loc[str(mun),"Passenger cars":"International flights below 1000 m altitude in Swedish airspace"].sum()/pop.loc[str(mun), 2019]
    #Negatives_2019 = 1

    #Munciplaity total emissions
    transport_MT = transport_cal/1000
    industry_MT = industry_cal/1000
    agriculture_MT = agriculture_cal/1000
    el_dh_MT = el_dh_cal/1000
    own_heating_MT = own_heating_cal/1000
    work_machines_MT = work_machines_cal/1000
    product_use_MT = product_use_cal/1000
    waste_MT = waste_cal/1000
    foreign_transport_MT = foreign_transport_cal/1000
    Negatives_MT = Negatives_cal/1000
    #Negatives = 1
    total_MT = transport_MT + industry_MT + agriculture_MT + el_dh_MT + own_heating_MT + work_machines_MT + product_use_MT + waste_MT + foreign_transport_MT + Negatives_MT


    cars_2019_MT = tbe_emissions.loc[str(mun), "Passenger cars"] / 1000
    buses_2019_MT =  tbe_emissions.loc[str(mun), "Buses"] / 1000
    heavy_trucks_2019_MT = tbe_emissions.loc[str(mun), "Heavy trucks"] / 1000
    light_trucks_2019_MT =  tbe_emissions.loc[str(mun), "Light trucks"] / 1000
    air_transport_2019_MT = tbe_emissions.loc[str(mun), "Domestic air traffic"] / 1000
    other_transport_2019_MT = (tbe_emissions.loc[str(mun), "Mopeds and Motorcycles"] +
                                    tbe_emissions.loc[str(mun), "Wear and tear from tires and brakes": "Domestic civil shipping (incl. private pleasure craft)"].sum() +
                                    tbe_emissions.loc[str(mun), "Railway":"Military transport"].sum()) / 1000
    transport_2019_MT =  cars_2019_MT + buses_2019_MT + heavy_trucks_2019_MT + light_trucks_2019_MT + air_transport_2019_MT + other_transport_2019_MT

    #transport_2019_MT =  (tbe_emissions.loc[str(mun), "Passenger cars"] + tbe_emissions.loc[str(mun), "Heavy trucks"] + tbe_emissions.loc[str(mun), "Light trucks"] + tbe_emissions.loc[str(mun), "Buses"] + tbe_emissions.loc[str(mun), "Domestic air traffic"] + tbe_emissions.loc[str(mun), "Mopeds and Motorcycles"] + tbe_emissions.loc[str(mun), "Wear and tear from tires and brakes": "Domestic civil shipping (incl. private pleasure craft)"].sum() + tbe_emissions.loc[str(mun), "Railway":"Military transport"].sum()) /1000
    industry_2019_MT = (tbe_emissions.loc[str(mun), "Industry (energy + processes)"]) /1000
    agriculture_2019_MT = (tbe_emissions.loc[str(mun), "Animal digestion":"Other fertilizers"].sum())/1000
    el_dh_2019_MT = (tbe_emissions.loc[str(mun), "Electricity and district heating"])/1000
    own_heating_2019_MT = (tbe_emissions.loc[str(mun), "Housing":"Agricultural and forestry premises"].sum())/1000
    work_machines_2019_MT = (tbe_emissions.loc[str(mun), "Scooters and quad bikes":"Other (airports, ports, m.m.)"].sum())/1000
    product_use_2019_MT = (tbe_emissions.loc[str(mun), "Solvent use - operations":"Other product use"].sum())/1000
    waste_2019_MT = (tbe_emissions.loc[str(mun), "Landfills":"Other waste management"].sum())/1000
    foreign_transport_2019_MT = (tbe_emissions.loc[str(mun), "Foreign shipping within Sweden's borders": "International flights below 1000 m altitude in Swedish airspace"].sum())/1000
    Negatives_2019_MT = 0#(tbe_emissions.loc[str(mun),"Passenger cars":"International flights below 1000 m altitude in Swedish airspace"].sum())/1000
    #Negatives_2019_MT = 1

# Constructing the forecasted 2030 numbers for percapita
    BAUtotal_2030 = transport_2019 + industry_2019 + agriculture_2019 + el_dh_2019 + own_heating_2019 + work_machines_2019 + product_use_2019 + waste_2019 + foreign_transport_2019 #+ Negatives_2019
    scenario2total_2030 = transport_2019*1.1683 + industry_2019*1.1683 + agriculture_2019*1.1683 + el_dh_2019*1.1683 + own_heating_2019*1.1683 + work_machines_2019*1.1683 + product_use_2019*1.1683 + waste_2019*1.1683 + foreign_transport_2019*1.1683 #+ Negatives_2019*1.1683
    scenario3total_2030 = transport_2019*0.94 + industry_2019*0.94 + agriculture_2019*0.94 + el_dh_2019*0.94 + own_heating_2019*0.94 + work_machines_2019*0.94 + product_use_2019*0.94 + waste_2019*0.94 + foreign_transport_2019*0.94 #+ Negatives_2019*0.94
    EAC_2030 = (transport + industry + agriculture + el_dh + own_heating + work_machines + product_use + waste + foreign_transport)#+ Negatives)
    EAC2_2030 = (transport*1.1683+ industry*1.1683+ agriculture*1.1683+ el_dh*1.1683+ own_heating*1.1683+ work_machines*1.1683+ product_use*1.1683+ waste*1.1683+ foreign_transport*1.1683)#+ Negatives*1.1683)
    EAC3_2030 = (transport*0.94+ industry*0.94+ agriculture*0.94+ el_dh*0.94+ own_heating*0.94+ work_machines*0.94+ product_use*0.94+ waste*0.94+ foreign_transport*0.94)#+ Negatives_2019*0.94)

# Constructing the forecasted 2030 numbers for municiplaity
    BAUtotal_2030_MT = transport_2019_MT + industry_2019_MT + agriculture_2019_MT + el_dh_2019_MT + own_heating_2019_MT + work_machines_2019_MT + product_use_2019_MT + waste_2019_MT + foreign_transport_2019_MT #+ Negatives_2019_MT
    scenario2total_2030_MT = transport_2019_MT*1.1683 + industry_2019_MT*1.1683 + agriculture_2019_MT*1.1683 + el_dh_2019_MT*1.1683 + own_heating_2019_MT*1.1683 + work_machines_2019_MT*1.1683 + product_use_2019_MT*1.1683 + waste_2019_MT*1.1683 + foreign_transport_2019_MT*1.1683 #+ Negatives_2019_MT*1.1683
    scenario3total_2030_MT = transport_2019_MT*0.94 + industry_2019_MT*0.94 + agriculture_2019_MT*0.94 + el_dh_2019_MT*0.94 + own_heating_2019_MT*0.94 + work_machines_2019_MT*0.94 + product_use_2019_MT*0.94 + waste_2019_MT*0.94 + foreign_transport_2019_MT*0.94 #+ Negatives_2019_MT*0.94
    EAC_2030_MT = (transport_MT + industry_MT + agriculture_MT + el_dh_MT + own_heating_MT + work_machines_MT + product_use_MT + waste_MT + foreign_transport_MT)#+ Negatives_2019_MT
    EAC2_2030_MT = (transport_MT * 1.1683 + industry_MT * 1.1683 + agriculture_MT * 1.1683 + el_dh_MT * 1.1683 + own_heating_MT * 1.1683 + work_machines_MT * 1.1683 + product_use_MT * 1.1683 + waste_MT * 1.1683 + foreign_transport_MT * 1.1683) #+ Negatives_MT * 1.1683)
    EAC3_2030_MT = (transport_MT * 0.94 + industry_MT * 0.94 + agriculture_MT * 0.94 + el_dh_MT * 0.94 + own_heating_MT * 0.94 + work_machines_MT * 0.94 + product_use_MT * 0.94 + waste_MT * 0.94 + foreign_transport_MT * 0.94) #+ Negatives_2019_MT * 0.94)

    #########Ton reduction factor for sweden - factor##################
    ##PM1 mean PM 2.5 and PM2 means PM10

    # Emission reduction factors
    emission_factors = {
        'CO2e': 1,
        'Nox': 0.003503,
        'PM1': 0.000619,
        'PM2': 0.000834,
        'CO': 0.008155
    }

    # Cost factors (EUR to SEK)
    cost_factors = {
        'CO2ec': 0.0335*11.34,
        'Noxc': 9.026*11.34,
        'PM1c': 153.346*11.34,
        'PM2c': 12.66*11.34,
        'COc': 2.3*11.34
    }

    Cobenefits_np_cars = 0.0029 * 11.34
    Cobenefits_np_buses = 0.0019 * 11.34
    Cobenefits_np_lt = 0.0049 * 11.34
    Cobenefits_np_ht = 0.0029 * 11.34

    Cobenefits_ts_cars = 0.0058 * 11.34
    Cobenefits_ts_buses = 0.0019 * 11.34
    Cobenefits_ts_lt = 0.0097 * 11.34
    Cobenefits_ts_ht = 0.0049 * 11.34

    Cobenefits_at_cars = 0.30 * 11.34

    ###############Co-impacts computational part###################################
    Average_car_distance = 10575  ######### average kms of the municipality
    Fossil_car_share = 0.90628 ###########avergae fossil car share
    Average_fossil_car_distance = Average_car_distance * Fossil_car_share  #######fossil fuel car distance in kms
    Total_passenger_cars_emission = tbe_emissions.loc[str(mun), "Passenger cars"]  ##########unit kgco2e
    Car_emission_per_km = Total_passenger_cars_emission / Average_fossil_car_distance  ###unit KGCO2 per kms

    Average_bus_distance = 46031  ######### average kms of the municipality
    Fossil_bus_share = 0.78755 ###########avergae fossil bus share
    Average_fossil_bus_distance = Average_bus_distance * Fossil_bus_share  #######fossil fuel bus distance in kms
    Total_passenger_buses_emission = tbe_emissions.loc[str(mun), "Buses"]  ##########unit kgco2e
    bus_emission_per_km = Total_passenger_buses_emission / Average_fossil_bus_distance  ###unit KGCO2 per kms

    Average_lt_distance = 13243  ######### average kms of the municipality
    Fossil_lt_share = 0.97515 ###########avergae fossil lt share
    Average_fossil_lt_distance = Average_lt_distance * Fossil_lt_share  #######fossil fuel lt distance in kms
    Total_passenger_lt_emission = tbe_emissions.loc[str(mun), "Light trucks"]  ##########unit kgco2e
    lt_emission_per_km = Total_passenger_lt_emission / Average_fossil_lt_distance  ###unit KGCO2 per kms

    Average_ht_distance = 41498  ######### average kms of the municipality
    Fossil_ht_share = 0.98613 ###########avergae fossil ht share
    Average_fossil_ht_distance = Average_ht_distance * Fossil_ht_share  #######fossil fuel ht distance in kms
    Total_passenger_ht_emission = tbe_emissions.loc[str(mun), "Heavy trucks"]  ##########unit kgco2e
    ht_emission_per_km = Total_passenger_ht_emission / Average_fossil_ht_distance  ###unit KGCO2 per kms

    fig_output = dash.no_update
    data_em_ouput = dash.no_update
    fig_ci_output= dash.no_update
    data_ci_output= dash.no_update

    if scenario == "Scenario 1 - Business as usual Scenario" and emissions_output == "Per capita emissions":
        # Your code to render the emissions chart

            start_year = 2021
            end_year = 2030
            num_years = end_year - start_year + 1

            growth_perc2030= 1
            growth_perc2019 = 1

            growth_rate_per_year = (growth_perc2030-growth_perc2019)/(end_year-start_year)

            transport_values1 = [transport_2019]
            for i in range(num_years - 1):
                interpolated_value = transport_values1[-1] * (1 + growth_rate_per_year)
                transport_values1.append(interpolated_value)

            # Repeat the above code for other variables

            industry_values1 = [industry_2019]
            for i in range(num_years - 1):
                interpolated_value = industry_values1[-1] * (1 + growth_rate_per_year)
                industry_values1.append(interpolated_value)

            agriculture_values1 = [agriculture_2019]
            for i in range(num_years - 1):
                interpolated_value = agriculture_values1[-1] * (1 + growth_rate_per_year)
                agriculture_values1.append(interpolated_value)

            el_dh_values1 = [el_dh_2019]
            for i in range(num_years - 1):
                interpolated_value = el_dh_values1[-1] * (1 + growth_rate_per_year)
                el_dh_values1.append(interpolated_value)


            own_heating_values1 = [own_heating_2019]
            for i in range(num_years - 1):
                interpolated_value = own_heating_values1[-1] * (1 + growth_rate_per_year)
                own_heating_values1.append(interpolated_value)

            work_machines_values1 = [work_machines_2019]
            for i in range(num_years - 1):
                interpolated_value = work_machines_values1[-1] * (1 + growth_rate_per_year)
                work_machines_values1.append(interpolated_value)


            product_use_values1 = [product_use_2019]
            for i in range(num_years - 1):
                interpolated_value = product_use_values1[-1] * (1 + growth_rate_per_year)
                product_use_values1.append(interpolated_value)


            waste_values1 = [waste_2019]
            for i in range(num_years - 1):
                interpolated_value = waste_values1[-1] * (1 + growth_rate_per_year)
                waste_values1.append(interpolated_value)

            foreign_transport_values1 = [foreign_transport_2019]
            for i in range(num_years - 1):
                interpolated_value = foreign_transport_values1[-1] * (1 + growth_rate_per_year)
                foreign_transport_values1.append(interpolated_value)

            Negatives_values1 = [Negatives_2019]
            for i in range(num_years - 1):
                interpolated_value = Negatives_values1[-1] * (1 + growth_rate_per_year)
                Negatives_values1.append(interpolated_value)

                ################Lever###########################

            ## transportLevers

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
            bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
            heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
            light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
            air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
            other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)

            car_values = np.full(num_years, cars_2019)
            bus_values = np.full(num_years, buses_2019)
            heavy_truck_values = np.full(num_years, heavy_trucks_2019)
            light_truck_values = np.full(num_years, light_trucks_2019)
            air_transport_values = np.full(num_years, air_transport_2019)
            other_transport_values = np.full(num_years, other_transport_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment
                bus_values[i] = bus_values[i - 1] + bus_growth_increment
                heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
                light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
                air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
                other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment

            # Apply the levers
            for i in range(num_years):
                current_year = 2021 + i
                pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (2030 - RC_year) if current_year >= RC_year else 0
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0
                el_car_value = ((el_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                ph_car_value = ((ph_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                hydr_car_value = ((hydr_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                ren_bus_value = ((ren_bus / 100) * (current_year - RENB_year)) / (2030 - RENB_year) if current_year >= RENB_year else 0
                LBG_heavy_value = ((LBG_heavy / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                LBG_light_value = ((LBG_light / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                air_transp_value = ((air_transp / 100) * (current_year - AIT_year)) / (2030 - AIT_year) if current_year >= AIT_year else 0

                # Calculate the values for each type of transport
                car_values[i] *= (1 - ((pt_car_value + act_trans_value + (el_car_value * caremission_intensity_EV) + (ph_car_value * caremission_intensity_PIH) + (hydr_car_value * caremission_intensity_Hydrogen))))
                bus_values[i] *= (1 - ((el_bus_value * busemission_intensity_EV) + (ren_bus_value * busemission_intensity_ren)))
                heavy_truck_values[i] *= (1 - (((LBG_heavy_value * HT_emission_intensity_LBG) + (electric_heavy_value * HT_emission_intensity_EV))))
                light_truck_values[i] *= (1 - (((LBG_light_value * LT_emission_intensity_LBG) + (electric_light_value * LT_emission_intensity_EV))))
                air_transport_values[i] *= (1 - air_transp_value)
                other_transport_values[i] *= (1 - (pt_car_value + act_trans_value))

            # The total emissions are the sum of all types of transport
            transport_values = car_values + bus_values + heavy_truck_values + light_truck_values + air_transport_values + other_transport_values

            # industryLevers

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for the industry
            industry_growth_increment = ((growth_perc2030 - 1) * industry_2019) / (num_years - 1)

            # Initialize the list for the industry values
            industry_values = np.full(num_years, industry_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                industry_values[i] = industry_values[i - 1] + industry_growth_increment

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                current_year = 2021 + i

                # Calculate lever values for the current year
                ccs_value = ((CCS_industry / 100) * (current_year - ccs_year)) / (2030 - ccs_year) if current_year >= ccs_year else 0
                Hyd_value = ((H2_industry / 100) * (current_year - Hyd_year)) / (2030 - Hyd_year) if current_year >= Hyd_year else 0

                # Apply the lever effects
                industry_values[i] *= (1 - ((ccs_value * ccs_emission_intensity) + (Hyd_value * hyd_emission_intensity)))

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment
            annual_growth_increment = ((growth_perc2030 - 1) * agriculture_2019) / (num_years - 1)

            # Initialize the list for the agriculture values
            agriculture_values = np.full(num_years, agriculture_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                agriculture_values[i] = agriculture_values[i - 1] + annual_growth_increment  # Linear growth

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i  # Current year in the simulation

                agr_value = ((agr / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Apply the lever effect
                agriculture_values[i] *= (1 - ((agr_value) * agr_emission_intensity))

            ## el_dhLevers
            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for el_dh
            annual_growth_increment = ((growth_perc2030 - 1) * el_dh_2019) / (num_years - 1)

            # Initialize the list for the el_dh values
            el_dh_values = np.full(num_years, el_dh_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                el_dh_values[i] = el_dh_values[i - 1] + annual_growth_increment

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i

                # Calculate lever effects
                wind_value = ((wind / 100) * (current_year - W_year)) / ( 2030 - W_year) if current_year >= W_year else 0
                rtsolar_value = ((rtsolar / 100) * (current_year - RS_year)) / ( 2030 - RS_year) if current_year >= RS_year else 0
                csolar_value = ((csolar / 100) * (current_year - CS_year)) / (2030 - CS_year) if current_year >= CS_year else 0
                DH_heatpumps_value = ((DH_heatpumps / 100) * (current_year -DHP_year)) / (2030 - DHP_year) if current_year >= DHP_year else 0
                ccsw_value = ((ccsw / 100) * (current_year - CCSW_year)) / (2030 - CCSW_year) if current_year >= CCSW_year else 0
                ind_temp_red_value = ((ind_temp_red / 100) * (current_year -start_year)) / (2030 - start_year) if current_year >= start_year else 0
                sn_measure_value = ((sn_measure/ 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                BAT_appl_value = ((BAT_appl / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0


                el_dh_values[i] *= (((1 - ((BAT_appl_value) * BAT_energy_consumption_impact + (ind_temp_red_value) * Ind_temp_impact + (
                sn_measure_value) * SN_eff_impact)) * ((1 - ( (Share_elec_DH) * ( ((wind_value) * Wind_emissions_intensity) + ((rtsolar_value) * Solar_emission_intensity) + (
                    (csolar_value) * Solar_emission_intensity)) + ((1 - Share_elec_DH) * (DH_heatpumps_value) * (((Share_DH_HP_air * emission_savings_air) + (Share_DH_HP_water * emission_savings_water) + (
                Share_DH_HP_GT * emission_savings_GT)))))))) * (1 - ((ccsw_value) * ccsw_emission_intensity)))

            ## own_heatingLevers
            own_heating_growth_2030 = own_heating*growth_perc2030
            own_heating_growth_2019 = own_heating_2019
            own_heating_values = [own_heating_growth_2019]

            num_years = 2030 - 2021

            for i in range(num_years):
                growth_rate_per_year = (own_heating_growth_2030 - own_heating_growth_2019) / num_years
                interpolated_value = own_heating_values[-1] + growth_rate_per_year
                own_heating_values.append(interpolated_value)

            ## work_machinesLevers

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment
            annual_growth_increment = ((growth_perc2030 - 1) * work_machines_2019) / (num_years - 1)

            # Initialize the list for the work_machines values
            work_machines_values = np.full(num_years, work_machines_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                work_machines_values[i] = work_machines_values[i - 1] + annual_growth_increment  # Linear growth

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i  # Current year in the simulation

                wm_value = ((wm / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Apply the lever effect
                work_machines_values[i] *= (1 - ((wm_value)))

            ## product_useLevers
            product_use_growth_2030 = product_use*growth_perc2030
            product_use_growth_2019 = product_use_2019
            product_use_values = [product_use_growth_2019]

            num_years = 2030 - 2021

            for i in range(num_years):
                growth_rate_per_year = (product_use_growth_2030 - product_use_growth_2019) / num_years
                interpolated_value = product_use_values[-1] + growth_rate_per_year
                product_use_values.append(interpolated_value)

            ## wasteLevers
            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for the industry
            annual_growth_increment = ((growth_perc2030 - 1) * waste_2019) / (num_years - 1)

            # Initialize the list for the waste values
            waste_values = np.full(num_years, waste_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                waste_values[i] = waste_values[i - 1] + annual_growth_increment

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i

                cmu_value = ((cmu/ 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Apply the lever effect
                waste_values[i] *= (1 - (cmu_value*Share_landfill_samecity))

            ## foreign_transportLevers
            foreign_transport_growth_2030 = foreign_transport*growth_perc2030
            foreign_transport_growth_2019 = foreign_transport_2019
            foreign_transport_values = [foreign_transport_growth_2019]

            num_years = 2030 - 2021

            for i in range(num_years):
                growth_rate_per_year = (foreign_transport_growth_2030 - foreign_transport_growth_2019) / num_years
                interpolated_value = foreign_transport_values[-1] + growth_rate_per_year
                foreign_transport_values.append(interpolated_value)

    ###########NegativesLevers
            Negatives_growth_2030 = Negatives*growth_perc2030
            Negatives_growth_2019 = Negatives_2019
            Negatives_values = [Negatives_growth_2019]

            num_years = end_year - start_year + 1  # Add 1 to include the end year
            Negatives_values = [Negatives_growth_2019] * num_years

            # Sort the levers by start year
            levers = sorted([(Bioccs_year, bio_ccs), (RW_year, rewetting_emissions), (CC_year, carbon_credit)])

            # Apply the levers
        # Apply the levers
            for lever_start_year, lever_percentage in levers:
                # Determine the target value for 2030 based on the lever pull
                target_2030_value = Negatives_growth_2030 * lever_percentage / 100

                # Starting value for the lever
                starting_value = Negatives_values[lever_start_year - start_year]

                # Calculate the total change required from the lever's start year to 2030
                total_change = target_2030_value - starting_value

                # Number of years from the lever's start year to 2030
                num_lever_years = end_year - lever_start_year + 1

                # Calculate the yearly change
                yearly_change = total_change / num_lever_years

                # Apply the yearly change linearly from the start year of the lever to 2030
                for i in range(lever_start_year - start_year, num_years):
                    Negatives_values[i] = starting_value + yearly_change * (i - (lever_start_year - start_year) + 1)

                years = list(range(2021, 2031))
                # Create a color scale for the categories
                color_scale = ["#ef553b", "#FECB52", "#e377c2", '#AB63FA', '#FFA15A', "#9467bd",
                               "#ff7f0e", '#B6E880', "#1f77b4", "#d62728"]

            categories = ["Agriculture","Waste","Transport", "Foreign transport", "Work machinery", "Electricity and DH",
                   "Own heating","Product use","Industry", "Negatives"]
            values1 = [agriculture_values1, waste_values1, transport_values1, foreign_transport_values1,
                       work_machines_values1, el_dh_values1, own_heating_values1, product_use_values1, industry_values1, Negatives_values1]
            values2 = [agriculture_values, waste_values, transport_values, foreign_transport_values,
                       work_machines_values, el_dh_values, own_heating_values, product_use_values, industry_values, Negatives_values]



            # Create a figure with two subplots, each containing a stacked bar chart
            fig = make_subplots(rows=2, cols=1, subplot_titles=("Forecasted emissions 2030: {} Kg".format(round(BAUtotal_2030)), "Emissions after climate action 2030: {} Kg".format(round(EAC_2030))), shared_xaxes=False, shared_yaxes=False)

            # Categories to display on the positive side
            positive_categories = ["Agriculture", "Waste", "Transport", "Foreign transport", "Work machinery", "Electricity and DH", "Own heating", "Product use", "Industry"]

            # Plot stacked bar chart for BAU Scenario
            for i in range(len(categories)):
                if categories[i] in positive_categories:
                    fig.add_trace(
                        go.Bar(x=years, y=values1[i], name=categories[i], hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=1, col=1
                    )
                else:
                    fig.add_trace(
                        go.Bar(x=years, y=[-val for val in values1[i]], name=categories[i], hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=1, col=1
                    )


            # Plot stacked bar chart for Scenario
            for i in range(len(categories)):
                if categories[i] in positive_categories:
                    fig.add_trace(
                        go.Bar(x=years, y=values2[i], showlegend=False, hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=2, col=1
                    )
                else:
                    fig.add_trace(
                        go.Bar(x=years, y=[-val for val in values2[i]], showlegend=False, hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=2, col=1
                    )

            # Compute the net emissions for each year
            netzero_emissions_values = []
            for year in range(len(years)):
                positive_sum = sum(values2[i][year] for i in range(len(categories)) if categories[i] in positive_categories)
                negative_sum = sum(values2[i][year] for i in range(len(categories)) if categories[i] not in positive_categories)
                netzero_emissions_values.append(positive_sum - negative_sum)

            # Plot line chart for Netzero emissions
            fig.add_trace(
                go.Scatter(x=years, y=netzero_emissions_values, name="Net emissions", mode='lines', hovertemplate="Variable: Net emissions<br>Value: %{y}<extra></extra>", marker=dict(color='#000080'), line=dict(width=3)),
                row=2, col=1
            )

            # Add labels and titles
            fig.update_layout(
                barmode="relative",
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Emissions profile in {} (Kg of CO2-eq)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='Kg of CO2-eq',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                   # tickformat=".0f",  # Format tick labels as decimal numbers
                    #ticksuffix=" Kg"  # Add "Kg" suffix to tick labels
                ),
                height=800
            )

            # Automatically determine the y-axis range for both charts based on the data
            fig.update_yaxes(row=1, col=1, autorange=True)
            fig.update_yaxes(row=2, col=1, autorange=True)

            # Update x-axis labels and tick values for both charts
            fig.update_xaxes(title_text="Years", ticktext=[str(year) for year in years], tickvals=years, row=1, col=1)
            fig.update_xaxes(title_text="Years", ticktext=[str(year) for year in years], tickvals=years, row=2, col=1)

            # Update y-axis label for the second chart
            fig.update_yaxes(title_text="Kg of CO2-eq", row=2, col=1)

            # Update y-axis label for the second chart
            fig.update_yaxes(title_text="Kg of CO2-eq", row=2, col=1)

            data_exp = {
            "Sectors": categories,
            "Input1": values1,
            "Input2": values2}

            fig_output = fig
            data_em_output = pd.DataFrame.from_dict(data_exp, orient='index').to_dict('records')

    if scenario == "Scenario 1 - Business as usual Scenario" and emissions_output == "Per capita emissions" and ci_dropdown == 'Improved air quality':
            ##################################Co-impacts###################################################################

            # 2030 emission value from the provided array
            agr_emission_2030 = agriculture_values[-1] - agriculture_values[0] # Last value in the array

            # Calculate reduced emissions and total cost
            agr_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = agr_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                agr_total_cost += (-cost)

            # 2030 emission value from the provided array
            trans_emission_2030 = transport_values[-1] - transport_values[0]# Last value in the array

            # Calculate reduced emissions and total cost
            trans_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = trans_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                trans_total_cost += (-cost)

            # 2030 emission value from the provided array
            waste_emission_2030 = waste_values[-1] - waste_values[0]   # Last value in the array

            # Calculate reduced emissions and total cost
            waste_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = waste_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                waste_total_cost += (-cost)

            # 2030 emission value from the provided array
            ft_emission_2030 = foreign_transport_values[-1] - foreign_transport_values[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            ft_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = ft_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                ft_total_cost += (-cost)

            # 2030 emission value from the provided array
            wm_emission_2030 = work_machines_values[-1] - work_machines_values[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            wm_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = wm_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                wm_total_cost += (-cost)

            # 2030 emission value from the provided array
            el_emission_2030 = el_dh_values[-1] - el_dh_values[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            el_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = el_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                el_total_cost += (-cost)

            # 2030 emission value from the provided array
            oh_emission_2030 = own_heating_values[-1] - own_heating_values[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            oh_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = oh_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                oh_total_cost += (-cost)

            # 2030 emission value from the provided array
            pu_emission_2030 = product_use_values[-1] - product_use_values[0] # Last value in the array

            # Calculate reduced emissions and total cost
            pu_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = pu_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                pu_total_cost += (-cost)

            # 2030 emission value from the provided array
            ind_emission_2030 = industry_values[-1] - industry_values[0] # Last value in the array

            # Calculate reduced emissions and total cost
            ind_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = ind_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                ind_total_cost += (-cost)


            # Given total costs for each sector
            sectors = {
                'Agriculture': agr_total_cost,
                'Transport': trans_total_cost,
                'Waste': waste_total_cost,
                'Foreign Transport': ft_total_cost,
                'Work Machines': wm_total_cost,
                'Electric DH': el_total_cost,
                'Own Heating': oh_total_cost,
                'Product Use': pu_total_cost,
                'Industry': ind_total_cost
            }

            # Actors and their share
            actors_share = {
                'Total':1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share


            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Per Capita - Cumulative Co-benefits of improved air quality in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Per capita - Cumulative co-benefits of improved air quality 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df

    if scenario == "Scenario 1 - Business as usual Scenario" and emissions_output == "Per capita emissions" and ci_dropdown == 'Reduced noise pollution':
            ##################################Co-impacts###################################################################

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
            bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
            heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
            light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
            air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
            other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)

            car_values = np.full(num_years, cars_2019)
            bus_values = np.full(num_years, buses_2019)
            heavy_truck_values = np.full(num_years, heavy_trucks_2019)
            light_truck_values = np.full(num_years, light_trucks_2019)
            air_transport_values = np.full(num_years, air_transport_2019)
            other_transport_values = np.full(num_years, other_transport_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment
                bus_values[i] = bus_values[i - 1] + bus_growth_increment
                heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
                light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
                air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
                other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment

            # Apply the levers
            for i in range(num_years):
                current_year = 2021 + i
                pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (2030 - RC_year) if current_year >= RC_year else 0
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0
                el_car_value = ((el_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 00
                electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Calculate the values for each type of transport
                car_values[i] *= (1 - ((pt_car_value + act_trans_value + (el_car_value * caremission_intensity_EV)))) #####refernce available only for electric cars
                bus_values[i] *= (1 - ((el_bus_value * busemission_intensity_EV)))
                heavy_truck_values[i] *= (1 - (((electric_heavy_value * HT_emission_intensity_EV))))
                light_truck_values[i] *= (1 - (((electric_light_value * LT_emission_intensity_EV))))

            ###############computational part of co-benefits#####################
            # 2030 emission value from the provided array
            Car_emission_per_emission = car_values[-1] - car_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            car_per_km_emission= Car_emission_per_km/Car_emission_per_emission ########unit is value/kms
            caremission_per_km = 1/car_per_km_emission ###unit is kms
            Total_cb_np_cars = caremission_per_km * Cobenefits_np_cars

            bus_emission_per_emission = bus_values[-1] - bus_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            bus_per_km_emission= bus_emission_per_km/bus_emission_per_emission ########unit is value/kms
            busemission_per_km = 1/bus_per_km_emission ###unit is kms
            Total_cb_np_buses = busemission_per_km * Cobenefits_np_buses

            ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
            htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
            Total_cb_np_ht = htemission_per_km * Cobenefits_np_ht

            lt_emission_per_emission =  light_truck_values[-1] -  light_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
            ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
            Total_cb_np_lt = ltemission_per_km * Cobenefits_np_lt

            transport_cp_np = -(Total_cb_np_cars + Total_cb_np_buses + Total_cb_np_ht + Total_cb_np_lt)

            # Given total costs for each sector
            sectors = {
                'Agriculture': 0,
                'Transport': transport_cp_np,
                'Waste': 0,
                'Foreign Transport': 0,
                'Work Machines': 0,
                'Electric DH': 0,
                'Own Heating': 0,
                'Product Use': 0,
                'Industry': 0
            }

            # Actors and their share
            actors_share = {
                'Total':1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share


            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Per Capita - Cumulative Co-benefits of reduced noise pollution in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Per capita - Cumulative co-benefits of reduced noise pollution 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df

    if scenario == "Scenario 1 - Business as usual Scenario" and emissions_output == "Per capita emissions" and ci_dropdown == 'Improved traffic safety':
            ##################################Co-impacts###################################################################

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
            bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
            heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
            light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
            air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
            other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)

            car_values = np.full(num_years, cars_2019)
            bus_values = np.full(num_years, buses_2019)
            heavy_truck_values = np.full(num_years, heavy_trucks_2019)
            light_truck_values = np.full(num_years, light_trucks_2019)
            air_transport_values = np.full(num_years, air_transport_2019)
            other_transport_values = np.full(num_years, other_transport_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment
                bus_values[i] = bus_values[i - 1] + bus_growth_increment
                heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
                light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
                air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
                other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment

            # Apply the levers
            for i in range(num_years):
                current_year = 2021 + i
                pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (2030 - RC_year) if current_year >= RC_year else 0
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0
                el_car_value = ((el_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 00
                electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Calculate the values for each type of transport
                car_values[i] *= (1 - ((pt_car_value + act_trans_value + (el_car_value * caremission_intensity_EV)))) #####refernce available only for electric cars
                bus_values[i] *= (1 - ((el_bus_value * busemission_intensity_EV)))
                heavy_truck_values[i] *= (1 - (((electric_heavy_value * HT_emission_intensity_EV))))
                light_truck_values[i] *= (1 - (((electric_light_value * LT_emission_intensity_EV))))

            ###############computational part of co-benefits#####################
            # 2030 emission value from the provided array
            Car_emission_per_emission = car_values[-1] - car_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            car_per_km_emission= Car_emission_per_km/Car_emission_per_emission ########unit is value/kms
            caremission_per_km = 1/car_per_km_emission ###unit is kms
            Total_cb_ts_cars = caremission_per_km * Cobenefits_ts_cars

            bus_emission_per_emission = bus_values[-1] - bus_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            bus_per_km_emission= bus_emission_per_km/bus_emission_per_emission ########unit is value/kms
            busemission_per_km = 1/bus_per_km_emission ###unit is kms
            Total_cb_ts_buses = busemission_per_km * Cobenefits_ts_buses

            ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
            htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
            Total_cb_ts_ht = htemission_per_km * Cobenefits_ts_ht

            lt_emission_per_emission =  light_truck_values[-1] -  light_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
            ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
            Total_cb_ts_lt = ltemission_per_km * Cobenefits_ts_lt

            transport_cp_ts = -(Total_cb_ts_cars + Total_cb_ts_buses + Total_cb_ts_ht + Total_cb_ts_lt)

            # Given total costs for each sector
            sectors = {
                'Agriculture': 0,
                'Transport': transport_cp_ts,
                'Waste': 0,
                'Foreign Transport': 0,
                'Work Machines': 0,
                'Electric DH': 0,
                'Own Heating': 0,
                'Product Use': 0,
                'Industry': 0
            }

            # Actors and their share
            actors_share = {
                'Total':1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share


            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Per Capita - Cumulative Co-benefits of improved traffic safety in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Per capita - Cumulative co-benefits of improved traffic safety 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df

    if scenario == "Scenario 1 - Business as usual Scenario" and emissions_output == "Per capita emissions" and ci_dropdown == 'Improved physical health':
            ##################################Co-impacts###################################################################

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)

            car_values = np.full(num_years, cars_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment

            # Apply the levers
            for i in range(num_years):
                current_year = 2021 + i
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0

                # Calculate the values for each type of transport
                car_values[i] *= (1 - ((act_trans_value))) #####refernce available only for electric cars

            ###############computational part of co-benefits#####################
            # 2030 emission value from the provided array
            Car_emission_per_emission = car_values[-1] - car_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            car_per_km_emission= Car_emission_per_km/Car_emission_per_emission ########unit is value/kms
            caremission_per_km = 1/car_per_km_emission ###unit is kms
            Total_cb_at_cars = caremission_per_km * Cobenefits_at_cars

            transport_cp_at = -Total_cb_at_cars

            # Given total costs for each sector
            sectors = {
                'Agriculture': 0,
                'Transport': transport_cp_at,
                'Waste': 0,
                'Foreign Transport': 0,
                'Work Machines': 0,
                'Electric DH': 0,
                'Own Heating': 0,
                'Product Use': 0,
                'Industry': 0
            }

            # Actors and their share
            actors_share = {
                'Total':1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share


            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Per Capita - Cumulative Co-benefits of improved physical health (active transport) in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Per capita - Cumulative co-benefits of improved physical health 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df

    if scenario == "Scenario 1 - Business as usual Scenario" and emissions_output == "Per capita emissions" and ci_dropdown == 'Total':
            ##################################Co-impacts###################################################################

########################Air quality ###################################
            # 2030 emission value from the provided array
            agr_emission_2030 = agriculture_values[-1] - agriculture_values[0] # Last value in the array

            # Calculate reduced emissions and total cost
            agr_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = agr_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                agr_total_cost += (-cost)

            # 2030 emission value from the provided array
            trans_emission_2030 = transport_values[-1] - transport_values[0]# Last value in the array

            # Calculate reduced emissions and total cost
            trans_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = trans_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                trans_total_cost += (-cost)

            # 2030 emission value from the provided array
            waste_emission_2030 = waste_values[-1] - waste_values[0]   # Last value in the array

            # Calculate reduced emissions and total cost
            waste_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = waste_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                waste_total_cost += (-cost)

            # 2030 emission value from the provided array
            ft_emission_2030 = foreign_transport_values[-1] - foreign_transport_values[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            ft_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = ft_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                ft_total_cost += (-cost)

            # 2030 emission value from the provided array
            wm_emission_2030 = work_machines_values[-1] - work_machines_values[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            wm_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = wm_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                wm_total_cost += (-cost)

            # 2030 emission value from the provided array
            el_emission_2030 = el_dh_values[-1] - el_dh_values[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            el_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = el_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                el_total_cost += (-cost)

            # 2030 emission value from the provided array
            oh_emission_2030 = own_heating_values[-1] - own_heating_values[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            oh_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = oh_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                oh_total_cost += (-cost)

            # 2030 emission value from the provided array
            pu_emission_2030 = product_use_values[-1] - product_use_values[0] # Last value in the array

            # Calculate reduced emissions and total cost
            pu_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = pu_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                pu_total_cost += (-cost)

            # 2030 emission value from the provided array
            ind_emission_2030 = industry_values[-1] - industry_values[0] # Last value in the array

            # Calculate reduced emissions and total cost
            ind_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = ind_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                ind_total_cost += (-cost)

###########################Noise pollution ############################
            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
            bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
            heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
            light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
            air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
            other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)

            car_values = np.full(num_years, cars_2019)
            bus_values = np.full(num_years, buses_2019)
            heavy_truck_values = np.full(num_years, heavy_trucks_2019)
            light_truck_values = np.full(num_years, light_trucks_2019)
            air_transport_values = np.full(num_years, air_transport_2019)
            other_transport_values = np.full(num_years, other_transport_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment
                bus_values[i] = bus_values[i - 1] + bus_growth_increment
                heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
                light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
                air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
                other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment

            # Apply the levers
            for i in range(num_years):
                current_year = 2021 + i
                pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (2030 - RC_year) if current_year >= RC_year else 0
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0
                el_car_value = ((el_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 00
                electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Calculate the values for each type of transport
                car_values[i] *= (1 - ((pt_car_value + act_trans_value + (el_car_value * caremission_intensity_EV)))) #####refernce available only for electric cars
                bus_values[i] *= (1 - ((el_bus_value * busemission_intensity_EV)))
                heavy_truck_values[i] *= (1 - (((electric_heavy_value * HT_emission_intensity_EV))))
                light_truck_values[i] *= (1 - (((electric_light_value * LT_emission_intensity_EV))))

            ###############computational part of co-benefits#####################
            # 2030 emission value from the provided array
            Car_emission_per_emission = car_values[-1] - car_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            car_per_km_emission= Car_emission_per_km/Car_emission_per_emission ########unit is value/kms
            caremission_per_km = 1/car_per_km_emission ###unit is kms
            Total_cb_np_cars = caremission_per_km * Cobenefits_np_cars

            bus_emission_per_emission = bus_values[-1] - bus_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            bus_per_km_emission= bus_emission_per_km/bus_emission_per_emission ########unit is value/kms
            busemission_per_km = 1/bus_per_km_emission ###unit is kms
            Total_cb_np_buses = busemission_per_km * Cobenefits_np_buses

            ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
            htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
            Total_cb_np_ht = htemission_per_km * Cobenefits_np_ht

            lt_emission_per_emission =  light_truck_values[-1] -  light_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
            ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
            Total_cb_np_lt = ltemission_per_km * Cobenefits_np_lt

            transport_cp_np = -(Total_cb_np_cars + Total_cb_np_buses + Total_cb_np_ht + Total_cb_np_lt)


#######################Traffic safety##################


            ###############computational part of co-benefits#####################
            # 2030 emission value from the provided array
            Car_emission_per_emission = car_values[-1] - car_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            car_per_km_emission= Car_emission_per_km/Car_emission_per_emission ########unit is value/kms
            caremission_per_km = 1/car_per_km_emission ###unit is kms
            Total_cb_ts_cars = caremission_per_km * Cobenefits_ts_cars

            bus_emission_per_emission = bus_values[-1] - bus_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            bus_per_km_emission= bus_emission_per_km/bus_emission_per_emission ########unit is value/kms
            busemission_per_km = 1/bus_per_km_emission ###unit is kms
            Total_cb_ts_buses = busemission_per_km * Cobenefits_ts_buses

            ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
            htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
            Total_cb_ts_ht = htemission_per_km * Cobenefits_ts_ht

            lt_emission_per_emission =  light_truck_values[-1] -  light_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
            ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
            Total_cb_ts_lt = ltemission_per_km * Cobenefits_ts_lt

            transport_cp_ts = -(Total_cb_ts_cars + Total_cb_ts_buses + Total_cb_ts_ht + Total_cb_ts_lt)

#############Improved physical health ##############

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)

            car_values = np.full(num_years, cars_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment

            # Apply the levers
            for i in range(num_years):
                current_year = 2021 + i
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0

                # Calculate the values for each type of transport
                car_values[i] *= (1 - ((act_trans_value))) #####refernce available only for electric cars

            ###############computational part of co-benefits#####################
            # 2030 emission value from the provided array
            Car_emission_per_emission = car_values[-1] - car_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            car_per_km_emission= Car_emission_per_km/Car_emission_per_emission ########unit is value/kms
            caremission_per_km = 1/car_per_km_emission ###unit is kms
            Total_cb_at_cars = caremission_per_km * Cobenefits_at_cars

            transport_cp_at = -Total_cb_at_cars

            Transport = trans_total_cost + transport_cp_at +  transport_cp_np + transport_cp_ts


            # Given total costs for each sector
            sectors = {
                'Agriculture': agr_total_cost,
                'Transport': Transport ,
                'Waste': waste_total_cost,
                'Foreign Transport': ft_total_cost,
                'Work Machines': wm_total_cost,
                'Electric DH': el_total_cost,
                'Own Heating': oh_total_cost,
                'Product Use': pu_total_cost,
                'Industry': ind_total_cost
            }

            # Actors and their share
            actors_share = {
                'Total':1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share


            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Per Capita - Total Cumulative Co-benefits in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Per capita - Total Cumulative co-benefits 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df

    if scenario == "Scenario 1 - Business as usual Scenario" and emissions_output == "Municipality emissions":

            start_year = 2021
            end_year = 2030
            num_years = end_year - start_year + 1

            growth_perc2030= 1
            growth_perc2019 = 1

            growth_rate_per_year = (growth_perc2030-growth_perc2019)/(end_year-start_year)

            transport_values1 = [transport_2019]
            for i in range(num_years - 1):
                interpolated_value = transport_values1[-1] * (1 + growth_rate_per_year)
                transport_values1.append(interpolated_value)

            # Create a list to store the multiplied values
            transport_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                transport_value = transport_values1[year - start_year]  # Index adjustment
                multiplied_value = transport_value * population
                transport_population_values.append(multiplied_value)

            # Repeat the above code for other variables

            industry_values1 = [industry_2019]
            for i in range(num_years - 1):
                interpolated_value = industry_values1[-1] * (1 + growth_rate_per_year)
                industry_values1.append(interpolated_value)

            # Create a list to store the multiplied values
            industry_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                industry_value = industry_values1[year - start_year]  # Index adjustment
                multiplied_value = industry_value * population
                industry_population_values.append(multiplied_value)


            agriculture_values1 = [agriculture_2019]
            for i in range(num_years - 1):
                interpolated_value = agriculture_values1[-1] * (1 + growth_rate_per_year)
                agriculture_values1.append(interpolated_value)

            # Create a list to store the multiplied values
            agriculture_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                agriculture_value = agriculture_values1[year - start_year]  # Index adjustment
                multiplied_value = agriculture_value * population
                agriculture_population_values.append(multiplied_value)


            el_dh_values1 = [el_dh_2019]
            for i in range(num_years - 1):
                interpolated_value = el_dh_values1[-1] * (1 + growth_rate_per_year)
                el_dh_values1.append(interpolated_value)

            # Create a list to store the multiplied values
            el_dh_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                el_dh_value = el_dh_values1[year - start_year]  # Index adjustment
                multiplied_value = el_dh_value * population
                el_dh_population_values.append(multiplied_value)


            own_heating_values1 = [own_heating_2019]
            for i in range(num_years - 1):
                interpolated_value = own_heating_values1[-1] * (1 + growth_rate_per_year)
                own_heating_values1.append(interpolated_value)

            # Create a list to store the multiplied values
            own_heating_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                own_heating_value = own_heating_values1[year - start_year]  # Index adjustment
                multiplied_value = own_heating_value * population
                own_heating_population_values.append(multiplied_value)

            work_machines_values1 = [work_machines_2019]
            for i in range(num_years - 1):
                interpolated_value = work_machines_values1[-1] * (1 + growth_rate_per_year)
                work_machines_values1.append(interpolated_value)

            # Create a list to store the multiplied values
            work_machines_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                work_machines_value = work_machines_values1[year - start_year]  # Index adjustment
                multiplied_value = work_machines_value * population
                work_machines_population_values.append(multiplied_value)


            product_use_values1 = [product_use_2019]
            for i in range(num_years - 1):
                interpolated_value = product_use_values1[-1] * (1 + growth_rate_per_year)
                product_use_values1.append(interpolated_value)

            # Create a list to store the multiplied values
            product_use_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                product_use_value = product_use_values1[year - start_year]  # Index adjustment
                multiplied_value = product_use_value * population
                product_use_population_values.append(multiplied_value)

            waste_values1 = [waste_2019]
            for i in range(num_years - 1):
                interpolated_value = waste_values1[-1] * (1 + growth_rate_per_year)
                waste_values1.append(interpolated_value)

            # Create a list to store the multiplied values
            waste_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                waste_value = waste_values1[year - start_year]  # Index adjustment
                multiplied_value = waste_value * population
                waste_population_values.append(multiplied_value)

            foreign_transport_values1 = [foreign_transport_2019]
            for i in range(num_years - 1):
                interpolated_value = foreign_transport_values1[-1] * (1 + growth_rate_per_year)
                foreign_transport_values1.append(interpolated_value)

            # Create a list to store the multiplied values
            foreign_transport_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                foreign_transport_value = foreign_transport_values1[year - start_year]  # Index adjustment
                multiplied_value = foreign_transport_value * population
                foreign_transport_population_values.append(multiplied_value)

            Negatives_values1 = [Negatives_2019]
            for i in range(num_years - 1):
                interpolated_value = Negatives_values1[-1] * (1 + growth_rate_per_year)
                Negatives_values1.append(interpolated_value)

            # Create a list to store the multiplied values
            Negatives_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                Negatives_value = Negatives_values1[year - start_year]  # Index adjustment
                multiplied_value = Negatives_value * population
                Negatives_population_values.append(multiplied_value)

                ################Lever###########################

            ## transportLevers
            # Initialize the lists for each type of transport
            car_values = np.full(num_years, cars_2019)
            bus_values = np.full(num_years, buses_2019)
            heavy_truck_values = np.full(num_years, heavy_trucks_2019)
            light_truck_values = np.full(num_years, light_trucks_2019)
            air_transport_values = np.full(num_years, air_transport_2019)
            other_transport_values = np.full(num_years, other_transport_2019)


            # Apply the levers
            for i in range(num_years):
                current_year = 2021 + i
                pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (2030 - RC_year) if current_year >= RC_year else 0
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0
                el_car_value = ((el_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                ph_car_value = ((ph_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                hydr_car_value = ((hydr_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                ren_bus_value = ((ren_bus / 100) * (current_year - RENB_year)) / (2030 - RENB_year) if current_year >= RENB_year else 0
                el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                LBG_heavy_value = ((LBG_heavy / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                LBG_light_value = ((LBG_light / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                air_transp_value = ((air_transp / 100) * (current_year - AIT_year)) / (2030 - AIT_year) if current_year >= AIT_year else 0

                # Calculate the values for each type of transport
                car_values[i] *= (1 - ((pt_car_value + act_trans_value + el_car_value * caremission_intensity_EV + ph_car_value * caremission_intensity_PIH + hydr_car_value * caremission_intensity_Hydrogen)))
                bus_values[i] *= (1 - ((ren_bus_value * busemission_intensity_ren + el_bus_value * busemission_intensity_EV)))
                heavy_truck_values[i] *= (1 - ((LBG_heavy_value * HT_emission_intensity_LBG + electric_heavy_value * HT_emission_intensity_EV)))
                light_truck_values[i] *= (1 - ((LBG_light_value * LT_emission_intensity_LBG + electric_light_value * LT_emission_intensity_EV)))
                air_transport_values[i] *= (1 - air_transp_value)
                other_transport_values[i] *= (1 - (pt_car_value + act_trans_value))

            # The total emissions are the sum of all types of transport
            transport_values = car_values + bus_values + heavy_truck_values + light_truck_values + air_transport_values + other_transport_values

            # Create a list to store the multiplied values
            transport_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                transport_value = transport_values[year - start_year]  # Index adjustment
                multiplied_value = transport_value * population
                transport_population_values1.append(multiplied_value)

    # industryLevers
            industry_growth_2030 = industry * growth_perc2030
            industry_growth_2019 = industry_2019
            industry_values = [industry_growth_2019]

            # Prepare a list of values for each year
            num_years = 2030 - 2021 + 1  # Add 1 to include the year 2030
            industry_values = np.full(num_years, industry_growth_2019)

            # Sort the levers by start year
            levers = sorted([(ccs_year, CCS_industry), (Hyd_year, H2_industry)])

            for i in range(num_years):
                current_year = 2021 + i
                ccs_value = ((CCS_industry / 100) * (current_year - levers[0][0])) / (2030 - levers[0][0]) if current_year >= levers[0][0] else 0
                Hyd_value = ((H2_industry / 100) * (current_year - levers[1][0])) / (2030 - levers[1][0]) if current_year >= levers[1][0] else 0
                industry_values[i] = industry_values[i] * (1 - ((ccs_value * ccs_emission_intensity) + (Hyd_value * hyd_emission_intensity)))

            # Create a list to store the multiplied values
            industry_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                industry_value = industry_values[year - start_year]  # Index adjustment
                multiplied_value = industry_value * population
                industry_population_values1.append(multiplied_value)

            ## agricultureLevers
            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment
            annual_growth_increment = ((growth_perc2030 - 1) * agriculture_2019) / (num_years - 1)

            # Initialize the list for the agriculture values
            agriculture_values = np.full(num_years, agriculture_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                agriculture_values[i] = agriculture_values[i - 1] + annual_growth_increment  # Linear growth

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i  # Current year in the simulation

                agr_value = ((agr / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Apply the lever effect
                agriculture_values[i] *= (1 - ((agr_value) * agr_emission_intensity))

            # Create a list to store the multiplied values
            agriculture_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                agriculture_value = agriculture_values[year - start_year]  # Index adjustment
                multiplied_value = agriculture_value * population
                agriculture_population_values1.append(multiplied_value)

            ## el_dhLevers
            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for el_dh
            annual_growth_increment = ((growth_perc2030 - 1) * el_dh_2019) / (num_years - 1)

            # Initialize the list for the el_dh values
            el_dh_values = np.full(num_years, el_dh_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                el_dh_values[i] = el_dh_values[i - 1] + annual_growth_increment

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i

                # Calculate lever effects
                wind_value = ((wind / 100) * (current_year - W_year)) / ( 2030 - W_year) if current_year >= W_year else 0
                rtsolar_value = ((rtsolar / 100) * (current_year - RS_year)) / ( 2030 - RS_year) if current_year >= RS_year else 0
                csolar_value = ((csolar / 100) * (current_year - CS_year)) / (2030 - CS_year) if current_year >= CS_year else 0
                DH_heatpumps_value = ((DH_heatpumps / 100) * (current_year -DHP_year)) / (2030 - DHP_year) if current_year >= DHP_year else 0
                ccsw_value = ((ccsw / 100) * (current_year - CCSW_year)) / (2030 - CCSW_year) if current_year >= CCSW_year else 0
                ind_temp_red_value = ((ind_temp_red / 100) * (current_year -start_year)) / (2030 - start_year) if current_year >= start_year else 0
                sn_measure_value = ((sn_measure/ 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                BAT_appl_value = ((BAT_appl / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0


                el_dh_values[i] *= (((1 - ((BAT_appl_value * BAT_energy_consumption_impact) + (ind_temp_red_value* Ind_temp_impact)  + (
                sn_measure_value* SN_eff_impact))) * ((1 - ( (Share_elec_DH) * (((wind_value* Wind_emissions_intensity)) + ((rtsolar_value* Solar_emission_intensity)) + (
                    (csolar_value) * Solar_emission_intensity)) + ((1 - Share_elec_DH) * (DH_heatpumps_value) * (((Share_DH_HP_air * emission_savings_air) + (Share_DH_HP_water * emission_savings_water) + (
                Share_DH_HP_GT * emission_savings_GT)))))))) * (1 -((ccsw_value) * ccsw_emission_intensity)))

            # Create a list to store the multiplied values
            el_dh_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]
                el_dh_value = el_dh_values[year - start_year]
                multiplied_value = el_dh_value * population
                el_dh_population_values1.append(multiplied_value)

            ## own_heatingLevers
            own_heating_growth_2030 = own_heating*growth_perc2030
            own_heating_growth_2019 = own_heating_2019
            own_heating_values = [own_heating_growth_2019]

            num_years = 2030 - 2021

            for i in range(num_years):
                growth_rate_per_year = (own_heating_growth_2030 - own_heating_growth_2019) / num_years
                interpolated_value = own_heating_values[-1] + growth_rate_per_year
                own_heating_values.append(interpolated_value)

            # Create a list to store the multiplied values
            own_heating_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                own_heating_value = own_heating_values[year - start_year]  # Index adjustment
                multiplied_value = own_heating_value * population
                own_heating_population_values1.append(multiplied_value)

            ## work_machinesLevers

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment
            annual_growth_increment = ((growth_perc2030 - 1) * work_machines_2019) / (num_years - 1)

            # Initialize the list for the work_machines values
            work_machines_values = np.full(num_years, work_machines_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                work_machines_values[i] = work_machines_values[i - 1] + annual_growth_increment  # Linear growth

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i  # Current year in the simulation

                wm_value = ((wm / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Apply the lever effect
                work_machines_values[i] *= (1 - ((wm_value)))

            # Create a list to store the multiplied values
            work_machines_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                work_machines_value = work_machines_values[year - start_year]  # Index adjustment
                multiplied_value = work_machines_value * population
                work_machines_population_values1.append(multiplied_value)

            ## product_useLevers
            product_use_growth_2030 = product_use*growth_perc2030
            product_use_growth_2019 = product_use_2019
            product_use_values = [product_use_growth_2019]

            num_years = 2030 - 2021

            for i in range(num_years):
                growth_rate_per_year = (product_use_growth_2030 - product_use_growth_2019) / num_years
                interpolated_value = product_use_values[-1] + growth_rate_per_year
                product_use_values.append(interpolated_value)

            # Create a list to store the multiplied values
            product_use_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                product_use_value = product_use_values[year - start_year]  # Index adjustment
                multiplied_value = product_use_value * population
                product_use_population_values1.append(multiplied_value)

            ## wasteLevers
            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for the industry
            annual_growth_increment = ((growth_perc2030 - 1) * waste_2019) / (num_years - 1)

            # Initialize the list for the waste values
            waste_values = np.full(num_years, waste_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                waste_values[i] = waste_values[i - 1] + annual_growth_increment

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i

                cmu_value = ((cmu / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Apply the lever effect
                waste_values[i] *= (1 - (cmu_value * Share_landfill_samecity))

            # Create a list to store the multiplied values
            waste_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]
                waste_value = waste_values[year - start_year]  # Index adjustment
                multiplied_value = waste_value * population
                waste_population_values1.append(multiplied_value)

            ## foreign_transportLevers
            foreign_transport_growth_2030 = foreign_transport*growth_perc2030
            foreign_transport_growth_2019 = foreign_transport_2019
            foreign_transport_values = [foreign_transport_growth_2019]

            num_years = 2030 - 2021

            for i in range(num_years):
                growth_rate_per_year = (foreign_transport_growth_2030 - foreign_transport_growth_2019) / num_years
                interpolated_value = foreign_transport_values[-1] + growth_rate_per_year
                foreign_transport_values.append(interpolated_value)

            # Create a list to store the multiplied values
            foreign_transport_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                foreign_transport_value = foreign_transport_values[year - start_year]  # Index adjustment
                multiplied_value = foreign_transport_value * population
                foreign_transport_population_values1.append(multiplied_value)

    ###########NegativesLevers
            Negatives_growth_2030 = Negatives*growth_perc2030
            Negatives_growth_2019 = Negatives_2019
            Negatives_values = [Negatives_growth_2019]

            num_years = end_year - start_year + 1  # Add 1 to include the end year
            Negatives_values = [Negatives_growth_2019] * num_years

            # Sort the levers by start year
            levers = sorted([(Bioccs_year, bio_ccs), (RW_year, rewetting_emissions), (CC_year, carbon_credit)])

            # Apply the levers
            for lever_start_year, lever_percentage in levers:
                # Calculate the total change based on the lever
                total_change = (Negatives_growth_2030 - Negatives_growth_2019) * lever_percentage / 100

                # Calculate the yearly change
                yearly_change = total_change / (end_year - (lever_start_year + 1) + 1)

                # Apply the yearly change to each year from the year after the start of the lever
                for i in range(lever_start_year - start_year + 1, num_years):
                    Negatives_values[i] += yearly_change * (i - (lever_start_year - start_year + 1) + 1)

                # Create a list to store the multiplied values
                Negatives_population_values1 = []

                # Iterate over years and calculate multiplied values
                for year in range(start_year, end_year + 1):
                    population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                    Negatives_value = Negatives_values[year - start_year]  # Index adjustment
                    multiplied_value = Negatives_value * population
                    Negatives_population_values1.append(multiplied_value)

                BAU1_total_emissions_2030 = (
                        transport_population_values[-1] +
                        industry_population_values[-1] +
                        agriculture_population_values[-1] +
                        el_dh_population_values[-1] +
                        own_heating_population_values1[-1] +
                        work_machines_population_values[-1] +
                        product_use_population_values[-1] +
                        waste_population_values[-1] +
                        foreign_transport_population_values[-1]

                )/1000000

                BAU2_total_emissions_2030 = (
                        transport_population_values1[-1] +
                        industry_population_values1[-1] +
                        agriculture_population_values1[-1] +
                        el_dh_population_values1[-1] +
                        own_heating_population_values1[-1] +
                        work_machines_population_values1[-1] +
                        product_use_population_values1[-1] +
                        waste_population_values1[-1] +
                        foreign_transport_population_values1[-1]

                )/1000000


                years = list(range(2021, 2031))
                # Create a color scale for the categories
                color_scale = ["#ef553b", "#FECB52", "#e377c2", '#AB63FA', '#FFA15A', "#9467bd",
                               "#ff7f0e", '#B6E880', "#1f77b4", "#d62728"]

            categories = ["Agriculture","Waste","Transport", "Foreign transport", "Work machinery", "Electricity and DH",
                   "Own heating","Product use","Industry", "Negatives"]
            values1 = [agriculture_population_values, waste_population_values, transport_population_values, foreign_transport_population_values,
                       work_machines_population_values, el_dh_population_values, own_heating_population_values, product_use_population_values, industry_population_values, Negatives_population_values]
            values2 = [agriculture_population_values1, waste_population_values1, transport_population_values1, foreign_transport_population_values1,
                       work_machines_population_values1, el_dh_population_values1, own_heating_population_values1, product_use_population_values1, industry_population_values1, Negatives_population_values1]


            # Create a figure with two subplots, each containing a stacked bar chart
            fig = make_subplots(rows=2, cols=1, subplot_titles=(f"Total Forecasted Emissions for 2030: {BAU1_total_emissions_2030:.2f}", f"Total Emissions after taking measures for 2030: {BAU2_total_emissions_2030:.2f}"), shared_xaxes=False, shared_yaxes=False)

            # Categories to display on the positive side
            positive_categories = ["Agriculture", "Waste", "Transport", "Foreign transport", "Work machinery", "Electricity and DH", "Own heating", "Product use", "Industry"]

            # Plot stacked bar chart for BAU Scenario
            for i in range(len(categories)):
                if categories[i] in positive_categories:
                    fig.add_trace(
                        go.Bar(x=years, y=values1[i], name=categories[i], hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=1, col=1
                    )
                else:
                    fig.add_trace(
                        go.Bar(x=years, y=[-val for val in values1[i]], name=categories[i], hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=1, col=1
                    )

            # Plot stacked bar chart for Scenario
            for i in range(len(categories)):
                if categories[i] in positive_categories:
                    fig.add_trace(
                        go.Bar(x=years, y=values2[i], showlegend=False, hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=2, col=1
                    )
                else:
                    fig.add_trace(
                        go.Bar(x=years, y=[-val for val in values2[i]], showlegend=False, hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=2, col=1
                    )

            # Compute the net emissions for each year
            netzero_emissions_values = []
            for year in range(len(years)):
                positive_sum = sum(values2[i][year] for i in range(len(categories)) if categories[i] in positive_categories)
                negative_sum = sum(values2[i][year] for i in range(len(categories)) if categories[i] not in positive_categories)
                netzero_emissions_values.append(positive_sum - negative_sum)

            # Plot line chart for Netzero emissions
            fig.add_trace(
                go.Scatter(x=years, y=netzero_emissions_values, name="Net emissions", mode='lines', hovertemplate="Variable: Net emissions<br>Value: %{y}<extra></extra>", marker=dict(color='#000080'), line=dict(width=3)),
                row=2, col=1
            )

            # Add labels and titles
            fig.update_layout(
                barmode="relative",
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Emissions profile in {} (Ton of CO2-eq)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='Ton of CO2-eq',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                    #tickformat=".0f",  # Format tick labels as decimal numbers
                    #ticksuffix=" Kg"  # Add "Kg" suffix to tick labels
                ),
                height=800
            )

            # Automatically determine the y-axis range for both charts based on the data
            fig.update_yaxes(row=1, col=1, autorange=True)
            fig.update_yaxes(row=2, col=1, autorange=True)

            # Update x-axis labels and tick values for both charts
            fig.update_xaxes(title_text="Years", ticktext=[str(year) for year in years], tickvals=years, row=1, col=1)
            fig.update_xaxes(title_text="Years", ticktext=[str(year) for year in years], tickvals=years, row=2, col=1)

            # Update y-axis label for the second chart
            fig.update_yaxes(title_text="Ton of CO2-eq", row=2, col=1)

            # Update y-axis label for the second chart
            fig.update_yaxes(title_text="Ton of CO2-eq", row=2, col=1)

            data_exp = {
            "Sectors": categories,
            "Input1": values1,
            "Input2": values2}

            fig_output = fig
            data_em_output = pd.DataFrame.from_dict(data_exp, orient='index').to_dict('records')

    if scenario == "Scenario 1 - Business as usual Scenario" and emissions_output == "Municipality emissions" and ci_dropdown == 'Improved air quality':
            ##################################Co-impacts###################################################################

            # 2030 emission value from the provided array
            agr_emission_2030 = agriculture_population_values1[-1] - agriculture_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            agr_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = agr_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                agr_total_cost += (-cost)

            # 2030 emission value from the provided array
            trans_emission_2030 = transport_population_values1[-1] - transport_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            trans_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = trans_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                trans_total_cost += (-cost)

            # 2030 emission value from the provided array
            waste_emission_2030 = waste_population_values1[-1] - waste_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            waste_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = waste_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                waste_total_cost += (-cost)

            # 2030 emission value from the provided array
            ft_emission_2030 = foreign_transport_population_values1[-1] - foreign_transport_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            ft_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = ft_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                ft_total_cost += (-cost)

            # 2030 emission value from the provided array
            wm_emission_2030 = work_machines_population_values1[-1] - work_machines_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            wm_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = wm_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                wm_total_cost += (-cost)

            # 2030 emission value from the provided array
            el_emission_2030 = el_dh_population_values1[-1] - el_dh_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            el_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = el_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                el_total_cost += (-cost)

            # 2030 emission value from the provided array
            oh_emission_2030 = own_heating_population_values1[-1] - own_heating_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            oh_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = oh_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                oh_total_cost += (-cost)

            # 2030 emission value from the provided array
            pu_emission_2030 = product_use_population_values1[-1] - product_use_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            pu_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = pu_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                pu_total_cost += (-cost)

            # 2030 emission value from the provided array
            ind_emission_2030 = industry_population_values1[-1] - industry_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            ind_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = ind_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                ind_total_cost += (-cost)

            # Given total costs for each sector
            sectors = {
                'Agriculture': agr_total_cost,
                'Transport': trans_total_cost,
                'Waste': waste_total_cost,
                'Foreign Transport': ft_total_cost,
                'Work Machines': wm_total_cost,
                'Electric DH': el_total_cost,
                'Own Heating': oh_total_cost,
                'Product Use': pu_total_cost,
                'Industry': ind_total_cost
            }

            # Actors and their share
            actors_share = {
                'Total': 1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share

            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Municipality - Cumulative Co-benefits of improved air quality in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Municipality - Cumulative co-benefits of improved air quality 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df

    if scenario == "Scenario 1 - Business as usual Scenario" and emissions_output == "Municipality emissions" and ci_dropdown == 'Reduced noise pollution':
            ##################################Co-impacts###################################################################

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
            bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
            heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
            light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
            air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
            other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)

            car_values = np.full(num_years, cars_2019)
            bus_values = np.full(num_years, buses_2019)
            heavy_truck_values = np.full(num_years, heavy_trucks_2019)
            light_truck_values = np.full(num_years, light_trucks_2019)
            air_transport_values = np.full(num_years, air_transport_2019)
            other_transport_values = np.full(num_years, other_transport_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment
                bus_values[i] = bus_values[i - 1] + bus_growth_increment
                heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
                light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
                air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
                other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment

            # Apply the levers
            for i in range(num_years):
                current_year = 2021 + i
                pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (2030 - RC_year) if current_year >= RC_year else 0
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0
                el_car_value = ((el_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 00
                electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Calculate the values for each type of transport
                car_values[i] *= (1 - ((pt_car_value + act_trans_value + (el_car_value * caremission_intensity_EV)))) #####refernce available only for electric cars
                bus_values[i] *= (1 - ((el_bus_value * busemission_intensity_EV)))
                heavy_truck_values[i] *= (1 - (((electric_heavy_value * HT_emission_intensity_EV))))
                light_truck_values[i] *= (1 - (((electric_light_value * LT_emission_intensity_EV))))

            ###############computational part of co-benefits#####################
            # 2030 emission value from the provided array
            Car_emission_per_emission = car_values[-1] - car_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            car_per_km_emission= Car_emission_per_km/Car_emission_per_emission ########unit is value/kms
            caremission_per_km = 1/car_per_km_emission ###unit is kms
            Total_cb_np_cars = (caremission_per_km * Cobenefits_np_cars)* pop.loc[str(mun), 20300] ###############20300 means the average population of the each municipality is taken into account

            bus_emission_per_emission = bus_values[-1] - bus_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            bus_per_km_emission= bus_emission_per_km/bus_emission_per_emission ########unit is value/kms
            busemission_per_km = 1/bus_per_km_emission ###unit is kms
            Total_cb_np_buses = (busemission_per_km * Cobenefits_np_buses)* pop.loc[str(mun), 20300] ###############20300 means the average population of the each municipality is taken into account

            ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
            htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
            Total_cb_np_ht = (htemission_per_km * Cobenefits_np_ht)* pop.loc[str(mun), 20300] ###############20300 means the average population of the each municipality is taken into account

            lt_emission_per_emission =  light_truck_values[-1] - light_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
            ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
            Total_cb_np_lt = (ltemission_per_km * Cobenefits_np_lt)* pop.loc[str(mun), 20300] ###############20300 means the average population of the each municipality is taken into account

            transport_cp_np = -(Total_cb_np_cars + Total_cb_np_buses + Total_cb_np_ht + Total_cb_np_lt)

            # Given total costs for each sector
            sectors = {
                'Agriculture': 0,
                'Transport': transport_cp_np,
                'Waste': 0,
                'Foreign Transport': 0,
                'Work Machines': 0,
                'Electric DH': 0,
                'Own Heating': 0,
                'Product Use': 0,
                'Industry': 0
            }

            # Actors and their share
            actors_share = {
                'Total':1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share


            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Municipality - Cumulative Co-benefits of reduced noise pollution in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Municipality - Cumulative co-benefits of reduced noise pollution 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df

    if scenario == "Scenario 1 - Business as usual Scenario" and emissions_output == "Municipality emissions" and ci_dropdown == 'Improved traffic safety':
            ##################################Co-impacts###################################################################

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
            bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
            heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
            light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
            air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
            other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)

            car_values = np.full(num_years, cars_2019)
            bus_values = np.full(num_years, buses_2019)
            heavy_truck_values = np.full(num_years, heavy_trucks_2019)
            light_truck_values = np.full(num_years, light_trucks_2019)
            air_transport_values = np.full(num_years, air_transport_2019)
            other_transport_values = np.full(num_years, other_transport_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment
                bus_values[i] = bus_values[i - 1] + bus_growth_increment
                heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
                light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
                air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
                other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment

            # Apply the levers
            for i in range(num_years):
                current_year = 2021 + i
                pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (2030 - RC_year) if current_year >= RC_year else 0
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0
                el_car_value = ((el_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 00
                electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Calculate the values for each type of transport
                car_values[i] *= (1 - ((pt_car_value + act_trans_value + (el_car_value * caremission_intensity_EV)))) #####refernce available only for electric cars
                bus_values[i] *= (1 - ((el_bus_value * busemission_intensity_EV)))
                heavy_truck_values[i] *= (1 - (((electric_heavy_value * HT_emission_intensity_EV))))
                light_truck_values[i] *= (1 - (((electric_light_value * LT_emission_intensity_EV))))

            ###############computational part of co-benefits#####################
            # 2030 emission value from the provided array ###############20300 means the average population of the each municipality is taken into account
            Car_emission_per_emission = car_values[-1] - car_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            car_per_km_emission= Car_emission_per_km/Car_emission_per_emission ########unit is value/kms
            caremission_per_km = 1/car_per_km_emission ###unit is kms
            Total_cb_ts_cars = (caremission_per_km * Cobenefits_ts_cars)* pop.loc[str(mun), 20300]

            bus_emission_per_emission = bus_values[-1] - bus_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            bus_per_km_emission= bus_emission_per_km/bus_emission_per_emission ########unit is value/kms
            busemission_per_km = 1/bus_per_km_emission ###unit is kms
            Total_cb_ts_buses = (busemission_per_km * Cobenefits_ts_buses)* pop.loc[str(mun), 20300]

            ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
            htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
            Total_cb_ts_ht = (htemission_per_km * Cobenefits_ts_ht)* pop.loc[str(mun), 20300]

            lt_emission_per_emission =  light_truck_values[-1] -  light_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
            ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
            Total_cb_ts_lt = (ltemission_per_km * Cobenefits_ts_lt)* pop.loc[str(mun), 20300]

            transport_cp_ts = -(Total_cb_ts_cars + Total_cb_ts_buses + Total_cb_ts_ht + Total_cb_ts_lt)

            # Given total costs for each sector
            sectors = {
                'Agriculture': 0,
                'Transport': transport_cp_ts,
                'Waste': 0,
                'Foreign Transport': 0,
                'Work Machines': 0,
                'Electric DH': 0,
                'Own Heating': 0,
                'Product Use': 0,
                'Industry': 0
            }

            # Actors and their share
            actors_share = {
                'Total':1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share


            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Municipality - Cumulative Co-benefits of improved traffic safety in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Municipality - Cumulative co-benefits of improved traffic safety 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df

    if scenario == "Scenario 1 - Business as usual Scenario" and emissions_output == "Municipality emissions" and ci_dropdown == 'Improved physical health':
            ##################################Co-impacts###################################################################

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)

            car_values = np.full(num_years, cars_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment

            # Apply the levers
            for i in range(num_years):
                current_year = 2021 + i
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0

                # Calculate the values for each type of transport
                car_values[i] *= (1 - ((act_trans_value))) #####refernce available only for electric cars

            ###############computational part of co-benefits#####################
            # 2030 emission value from the provided array ###############20300 means the average population of the each municipality is taken into account
            Car_emission_per_emission = car_values[-1] - car_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            car_per_km_emission= Car_emission_per_km/Car_emission_per_emission ########unit is value/kms
            caremission_per_km = 1/car_per_km_emission ###unit is kms
            Total_cb_at_cars = (caremission_per_km * Cobenefits_at_cars)* pop.loc[str(mun), 20300]

            transport_cp_at = -Total_cb_at_cars

            # Given total costs for each sector
            sectors = {
                'Agriculture': 0,
                'Transport': transport_cp_at,
                'Waste': 0,
                'Foreign Transport': 0,
                'Work Machines': 0,
                'Electric DH': 0,
                'Own Heating': 0,
                'Product Use': 0,
                'Industry': 0
            }

            # Actors and their share
            actors_share = {
                'Total':1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share


            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Municipality - Cumulative Co-benefits of improved physical health (active transport) in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Municipality - Cumulative co-benefits of improved physical health 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df

    if scenario == "Scenario 1 - Business as usual Scenario" and emissions_output == "Municipality emissions" and ci_dropdown == 'Total':
        ##################################Co-impacts###################################################################

        ########################Air quality ###################################
        agr_emission_2030 = agriculture_population_values1[-1] - agriculture_population_values1[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        agr_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = agr_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            agr_total_cost += (-cost)

        # 2030 emission value from the provided array
        trans_emission_2030 = transport_population_values1[-1] - transport_population_values1[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        trans_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = trans_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            trans_total_cost += (-cost)

        # 2030 emission value from the provided array
        waste_emission_2030 = waste_population_values1[-1] - waste_population_values1[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        waste_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = waste_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            waste_total_cost += (-cost)

        # 2030 emission value from the provided array
        ft_emission_2030 = foreign_transport_population_values1[-1] - foreign_transport_population_values1[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        ft_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = ft_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            ft_total_cost += (-cost)

        # 2030 emission value from the provided array
        wm_emission_2030 = work_machines_population_values1[-1] - work_machines_population_values1[
            0]  # Last value in the array

        # Calculate reduced emissions and total cost
        wm_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = wm_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            wm_total_cost += (-cost)

        # 2030 emission value from the provided array
        el_emission_2030 = el_dh_population_values1[-1] - el_dh_population_values1[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        el_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = el_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            el_total_cost += (-cost)

        # 2030 emission value from the provided array
        oh_emission_2030 = own_heating_population_values1[-1] - own_heating_population_values1[
            0]  # Last value in the array

        # Calculate reduced emissions and total cost
        oh_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = oh_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            oh_total_cost += (-cost)

        # 2030 emission value from the provided array
        pu_emission_2030 = product_use_population_values1[-1] - product_use_population_values1[
            0]  # Last value in the array

        # Calculate reduced emissions and total cost
        pu_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = pu_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            pu_total_cost += (-cost)

        # 2030 emission value from the provided array
        ind_emission_2030 = industry_population_values1[-1] - industry_population_values1[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        ind_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = ind_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            ind_total_cost += (-cost)

        ###########################Noise pollution ############################
        # Initialize the number of years in the simulation
        num_years = 2030 - 2021 + 1

        # Calculate the annual growth increment for each type of transport
        car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
        bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
        heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
        light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
        air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
        other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)

        car_values = np.full(num_years, cars_2019)
        bus_values = np.full(num_years, buses_2019)
        heavy_truck_values = np.full(num_years, heavy_trucks_2019)
        light_truck_values = np.full(num_years, light_trucks_2019)
        air_transport_values = np.full(num_years, air_transport_2019)
        other_transport_values = np.full(num_years, other_transport_2019)

        # Apply the linear growth from 2019 to 2030
        for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
            car_values[i] = car_values[i - 1] + car_growth_increment
            bus_values[i] = bus_values[i - 1] + bus_growth_increment
            heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
            light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
            air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
            other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment

        # Apply the levers
        for i in range(num_years):
            current_year = 2021 + i
            pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (
                        2030 - RC_year) if current_year >= RC_year else 0
            act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (
                        2030 - AT_year) if current_year >= AT_year else 0
            el_car_value = ((el_car / 100) * (current_year - start_year)) / (
                        2030 - start_year) if current_year >= start_year else 0
            el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (
                        2030 - start_year) if current_year >= start_year else 00
            electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (
                        2030 - start_year) if current_year >= start_year else 0
            electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (
                        2030 - start_year) if current_year >= start_year else 0

            # Calculate the values for each type of transport
            car_values[i] *= (1 - ((pt_car_value + act_trans_value + (el_car_value * caremission_intensity_EV))))  #####refernce available only for electric cars
            bus_values[i] *= (1 - ((el_bus_value * busemission_intensity_EV)))
            heavy_truck_values[i] *= (1 - (((electric_heavy_value * HT_emission_intensity_EV))))
            light_truck_values[i] *= (1 - (((electric_light_value * LT_emission_intensity_EV))))

        ###############computational part of co-benefits#####################
        # 2030 emission value from the provided array
        Car_emission_per_emission = car_values[-1] - car_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        car_per_km_emission = Car_emission_per_km / Car_emission_per_emission  ########unit is value/kms
        caremission_per_km = 1 / car_per_km_emission  ###unit is kms
        Total_cb_np_cars = (caremission_per_km * Cobenefits_np_cars)* pop.loc[str(mun), 20300]

        bus_emission_per_emission = bus_values[-1] - bus_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        bus_per_km_emission = bus_emission_per_km / bus_emission_per_emission  ########unit is value/kms
        busemission_per_km = 1 / bus_per_km_emission  ###unit is kms
        Total_cb_np_buses = (busemission_per_km * Cobenefits_np_buses)* pop.loc[str(mun), 20300]

        ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
        htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
        Total_cb_np_ht = (htemission_per_km * Cobenefits_np_ht)* pop.loc[str(mun), 20300]

        lt_emission_per_emission = light_truck_values[-1] - light_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
        ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
        Total_cb_np_lt = (ltemission_per_km * Cobenefits_np_lt)* pop.loc[str(mun), 20300]

        transport_cp_np = -(Total_cb_np_cars + Total_cb_np_buses + Total_cb_np_ht + Total_cb_np_lt)

        #######################Traffic safety##################

        ###############computational part of co-benefits#####################
        # 2030 emission value from the provided array
        Car_emission_per_emission = car_values[-1] - car_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        car_per_km_emission = Car_emission_per_km / Car_emission_per_emission  ########unit is value/kms
        caremission_per_km = 1 / car_per_km_emission  ###unit is kms
        Total_cb_ts_cars = (caremission_per_km * Cobenefits_ts_cars)* pop.loc[str(mun), 20300]

        bus_emission_per_emission = bus_values[-1] - bus_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        bus_per_km_emission = bus_emission_per_km / bus_emission_per_emission  ########unit is value/kms
        busemission_per_km = 1 / bus_per_km_emission  ###unit is kms
        Total_cb_ts_buses = (busemission_per_km * Cobenefits_ts_buses)* pop.loc[str(mun), 20300]

        ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
        htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
        Total_cb_ts_ht = (htemission_per_km * Cobenefits_ts_ht)* pop.loc[str(mun), 20300]

        lt_emission_per_emission = light_truck_values[-1] - light_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
        ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
        Total_cb_ts_lt = (ltemission_per_km * Cobenefits_ts_lt)* pop.loc[str(mun), 20300]

        transport_cp_ts = -(Total_cb_ts_cars + Total_cb_ts_buses + Total_cb_ts_ht + Total_cb_ts_lt)

        #############Improved physical health ##############

        # Initialize the number of years in the simulation
        num_years = 2030 - 2021 + 1

        # Calculate the annual growth increment for each type of transport
        car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)

        car_values = np.full(num_years, cars_2019)

        # Apply the linear growth from 2019 to 2030
        for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
            car_values[i] = car_values[i - 1] + car_growth_increment

        # Apply the levers
        for i in range(num_years):
            current_year = 2021 + i
            act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0

            # Calculate the values for each type of transport
            car_values[i] *= (1 - ((act_trans_value)))  #####refernce available only for electric cars

        ###############computational part of co-benefits#####################
        # 2030 emission value from the provided array
        Car_emission_per_emission = car_values[-1] - car_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        car_per_km_emission = Car_emission_per_km / Car_emission_per_emission  ########unit is value/kms
        caremission_per_km = 1 / car_per_km_emission  ###unit is kms
        Total_cb_at_cars = (caremission_per_km * Cobenefits_at_cars)* pop.loc[str(mun), 20300]

        transport_cp_at = -Total_cb_at_cars

        Transport = trans_total_cost + transport_cp_at + transport_cp_np + transport_cp_ts

        # Given total costs for each sector
        sectors = {
            'Agriculture': agr_total_cost,
            'Transport': Transport,
            'Waste': waste_total_cost,
            'Foreign Transport': ft_total_cost,
            'Work Machines': wm_total_cost,
            'Electric DH': el_total_cost,
            'Own Heating': oh_total_cost,
            'Product Use': pu_total_cost,
            'Industry': ind_total_cost
        }

        # Actors and their share
        actors_share = {
            'Total': 1,
            'Citizens': 0.4,
            'Civil soceity': 0,
            'Financial institutions': 0,
            'Industry': 0,
            'Municipal governments': 0.6,
            'Superordinate governments': 0,
            'Utility companies': 0

        }

        # Determine the share of each actor
        actors_values = {}
        for actor, share in actors_share.items():
            for sector, cost in sectors.items():
                if sector not in actors_values:
                    actors_values[sector] = {}
                actors_values[sector][actor] = cost * share

        # Define color mapping for sectors
        sector_colors = {
            'Agriculture': "#ef553b",
            'Waste': "#FECB52",
            'Transport': "#e377c2",
            'Foreign Transport': '#AB63FA',
            'Work Machines': '#FFA15A',
            'Electric DH': "#9467bd",
            'Own Heating': "#ff7f0e",
            'Product Use': '#B6E880',
            'Industry': "#1f77b4"
        }

        # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
        fig_ci = go.Figure()

        for sector in sectors.keys():
            fig_ci.add_trace(go.Bar(
                x=list(actors_share.keys()),
                y=[actors_values[sector][actor] for actor in actors_share.keys()],
                name=sector,
                marker_color=sector_colors[sector]
            ))

        fig_ci.update_layout(
            barmode='stack',
            margin=dict(l=40, r=20, b=10, t=60),
            autosize=True,
            title_text="Municipality - Total Cumulative Co-benefits in {} (SEK) - 2030".format(mun),
            title_font=dict(size=18, color="darkred"),
            xaxis_title="Actors",
            yaxis_title="SEK",
            yaxis=dict(
                showgrid=True,
                gridcolor='lightgray',
                gridwidth=0.5
            )
        )

        def create_dataframe(sectors, actors_share, actors_values):
            unique_sectors = list(sectors.keys())
            unique_actors = list(actors_share.keys())

            # Constructing a Data Dictionary
            data_exp = {"Sectors": unique_sectors}
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    actor_values.append(actors_values[sector].get(actor, 0))
                data_exp[actor] = actor_values

            # Converting Dictionary to DataFrame
            df = pd.DataFrame.from_dict(data_exp)

            # Reordering the DataFrame Columns
            df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

            # Inserting a new row at the beginning
            new_row = ["Municipality - Total Cumulative co-benefits 2030"] + [""] * (len(df.columns) - 1)
            df.loc[-1] = new_row  # adding a row
            df.index = df.index + 1  # shifting index
            df = df.sort_index()  # sorting by index

            # Return the serialized DataFrame
            return df.to_dict(orient='records')

        df = create_dataframe(sectors, actors_share, actors_values)

        fig_ci_output = fig_ci
        data_ci_output = df


    elif scenario == "Scenario 2 - Pessimistic Scenario" and emissions_output == 'Per capita emissions':
            start_year = 2021
            end_year = 2030
            num_years = end_year - start_year + 1
         
        
            growth_perc2030= 1.1683
            growth_perc2019 = 1
        
            growth_rate_per_year = (growth_perc2030-growth_perc2019)/(end_year-start_year)
        
            transport_values1 = [transport_2019]

            # Calculate the annual growth increment required to achieve the target growth
            annual_growth_increment = (growth_perc2030 * transport_2019 - transport_2019) / (num_years - 1)
            
            # Calculate the transport values for the years 2019 to 2030
            for i in range(num_years - 1):
                interpolated_value = transport_values1[-1] + annual_growth_increment
                transport_values1.append(interpolated_value)
        
            # Repeat the above code for other variables
        
            industry_values1 = [industry_2019]

            # Calculate the annual growth increment required to achieve the target growth
            annual_growth_increment = (growth_perc2030 * industry_2019 - industry_2019) / (num_years - 1)
            
            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = industry_values1[-1] + annual_growth_increment
                industry_values1.append(next_value)                   
                            
            agriculture_values1 = [agriculture_2019]
            
            # Calculate the annual growth increment required to achieve the target growth
            annual_growth_increment = (growth_perc2030 * agriculture_2019 - agriculture_2019) / (num_years - 1)
            
            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = agriculture_values1[-1] + annual_growth_increment
                agriculture_values1.append(next_value)
                
                
            el_dh_values1 = [el_dh_2019]
    
            # Calculate the annual growth increment required to achieve the target growth
            annual_growth_increment = (growth_perc2030 * el_dh_2019 - el_dh_2019) / (num_years - 1)
            
            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = el_dh_values1[-1] + annual_growth_increment
                el_dh_values1.append(next_value)
                
    
            own_heating_values1 = [own_heating_2019]
            # Calculate the annual growth increment required to achieve the target growth
            annual_growth_increment = (growth_perc2030 * own_heating_2019 - own_heating_2019) / (num_years - 1)
            
            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = own_heating_values1[-1] + annual_growth_increment
                own_heating_values1.append(next_value)
    
            work_machines_values1 = [work_machines_2019]
            annual_growth_increment = (growth_perc2030 * work_machines_2019 - work_machines_2019) / (num_years - 1)
            
            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = work_machines_values1[-1] + annual_growth_increment
                work_machines_values1.append(next_value)
                
            
            product_use_values1 = [product_use_2019]
            annual_growth_increment = (growth_perc2030 * product_use_2019 - product_use_2019) / (num_years - 1)
            
            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = product_use_values1[-1] + annual_growth_increment
                product_use_values1.append(next_value)
                
    
            waste_values1 = [waste_2019]
            annual_growth_increment = (growth_perc2030 * waste_2019 - waste_2019) / (num_years - 1)
            
            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = waste_values1[-1] + annual_growth_increment
                waste_values1.append(next_value)
    
            foreign_transport_values1 = [foreign_transport_2019]
            annual_growth_increment = (growth_perc2030 * foreign_transport_2019 - foreign_transport_2019) / (num_years - 1)
            
            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = foreign_transport_values1[-1] + annual_growth_increment
                foreign_transport_values1.append(next_value)
                
            Negatives_values1 = [Negatives_2019]
            for i in range(num_years - 1):
                interpolated_value = Negatives_values1[-1] * (1 + (1-1)/(end_year-start_year))
                Negatives_values1.append(interpolated_value)
               
                ################Lever###########################
           
            ## transportLevers    
           # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1
            
            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
            bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
            heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
            light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
            air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
            other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)
            
            # Initialize the lists for each type of transport
            car_values = np.full(num_years, cars_2019)
            bus_values = np.full(num_years, buses_2019)
            heavy_truck_values = np.full(num_years, heavy_trucks_2019)
            light_truck_values = np.full(num_years, light_trucks_2019)
            air_transport_values = np.full(num_years, air_transport_2019)
            other_transport_values = np.full(num_years, other_transport_2019)
            
            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment
                bus_values[i] = bus_values[i - 1] + bus_growth_increment
                heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
                light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
                air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
                other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment
            
            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                current_year = 2021 + i
            
                # Calculate lever values for the current year
                pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (2030 - RC_year) if current_year >= RC_year else 0
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0
                el_car_value = ((el_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                ph_car_value = ((ph_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                hydr_car_value = ((hydr_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                ren_bus_value = ((ren_bus / 100) * (current_year - RENB_year)) / (2030 - RENB_year) if current_year >= RENB_year else 0
                el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                LBG_heavy_value = ((LBG_heavy / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                LBG_light_value = ((LBG_light / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                air_transp_value = ((air_transp / 100) * (current_year - AIT_year)) / (2030 - AIT_year) if current_year >= AIT_year else 0
            
                # Apply the lever effects
                car_values[i] *= (1 - ((pt_car_value + act_trans_value + el_car_value * caremission_intensity_EV + ph_car_value * caremission_intensity_PIH + hydr_car_value * caremission_intensity_Hydrogen)))
                bus_values[i] *= (1 - ((ren_bus_value * busemission_intensity_ren + el_bus_value * busemission_intensity_EV)))
                heavy_truck_values[i] *= (1 - ((LBG_heavy_value * HT_emission_intensity_LBG + electric_heavy_value * HT_emission_intensity_EV)))
                light_truck_values[i] *= (1 - ((LBG_light_value * LT_emission_intensity_LBG + electric_light_value * LT_emission_intensity_EV)))
                air_transport_values[i] *= (1 - air_transp_value)
                other_transport_values[i] *= (1 - (pt_car_value + act_trans_value))
            
            # The total emissions are the sum of all types of transport
            transport_values = car_values + bus_values + heavy_truck_values + light_truck_values + air_transport_values + other_transport_values


    # industryLevers 
    
            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1
            
            # Calculate the annual growth increment for the industry
            industry_growth_increment = ((growth_perc2030 - 1) * industry_2019) / (num_years - 1)
            
            # Initialize the list for the industry values
            industry_values = np.full(num_years, industry_2019)
            
            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                industry_values[i] = industry_values[i - 1] + industry_growth_increment
            
            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                current_year = 2021 + i
            
                # Calculate lever values for the current year
                ccs_value = ((CCS_industry / 100) * (current_year - ccs_year)) / (2030 - ccs_year) if current_year >= ccs_year else 0
                Hyd_value = ((H2_industry / 100) * (current_year - Hyd_year)) / (2030 - Hyd_year) if current_year >= Hyd_year else 0
            
                # Apply the lever effects
                industry_values[i] *= (1 - ((ccs_value * ccs_emission_intensity) + (Hyd_value * hyd_emission_intensity)))
            
            # The total emissions are in industry_values
            Industry_total_values = industry_values

                
            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment
            annual_growth_increment = ((growth_perc2030 - 1) * agriculture_2019) / (num_years - 1)

            # Initialize the list for the agriculture values
            agriculture_values = np.full(num_years, agriculture_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                agriculture_values[i] = agriculture_values[i - 1] + annual_growth_increment  # Linear growth

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i  # Current year in the simulation

                agr_value = ((agr / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Apply the lever effect
                agriculture_values[i] *= (1 - ((agr_value) * agr_emission_intensity))
                
            ## el_dhLevers    
            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for el_dh
            annual_growth_increment = ((growth_perc2030 - 1) * el_dh_2019) / (num_years - 1)

            # Initialize the list for the el_dh values
            el_dh_values = np.full(num_years, el_dh_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                el_dh_values[i] = el_dh_values[i - 1] + annual_growth_increment

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i

                # Calculate lever effects
                wind_value = ((wind / 100) * (current_year - W_year)) / ( 2030 - W_year) if current_year >= W_year else 0
                rtsolar_value = ((rtsolar / 100) * (current_year - RS_year)) / ( 2030 - RS_year) if current_year >= RS_year else 0
                csolar_value = ((csolar / 100) * (current_year - CS_year)) / (2030 - CS_year) if current_year >= CS_year else 0
                DH_heatpumps_value = ((DH_heatpumps / 100) * (current_year -DHP_year)) / (2030 - DHP_year) if current_year >= DHP_year else 0
                ccsw_value = ((ccsw / 100) * (current_year - CCSW_year)) / (2030 - CCSW_year) if current_year >= CCSW_year else 0
                ind_temp_red_value = ((ind_temp_red / 100) * (current_year -start_year)) / (2030 - start_year) if current_year >= start_year else 0
                sn_measure_value = ((sn_measure/ 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                BAT_appl_value = ((BAT_appl / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0


                el_dh_values[i] *= (((1 - ((BAT_appl_value * BAT_energy_consumption_impact) + (ind_temp_red_value* Ind_temp_impact)  + (
                sn_measure_value* SN_eff_impact))) * ((1 - ( (Share_elec_DH) * (((wind_value* Wind_emissions_intensity)) + ((rtsolar_value* Solar_emission_intensity)) + (
                    (csolar_value) * Solar_emission_intensity)) + ((1 - Share_elec_DH) * (DH_heatpumps_value) * (((Share_DH_HP_air * emission_savings_air) + (Share_DH_HP_water * emission_savings_water) + (
                Share_DH_HP_GT * emission_savings_GT)))))))) * (1 -((ccsw_value) * ccsw_emission_intensity)))
                                        
            ## own_heatingLevers    
            own_heating_growth_2030 = own_heating*growth_perc2030
            own_heating_growth_2019 = own_heating_2019
            own_heating_values = [own_heating_growth_2019]
            
            num_years = 2030 - 2021
            
            for i in range(num_years):
                growth_rate_per_year = (own_heating_growth_2030 - own_heating_growth_2019) / num_years
                interpolated_value = own_heating_values[-1] + growth_rate_per_year
                own_heating_values.append(interpolated_value)
            
            ## work_machinesLevers

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment
            annual_growth_increment = ((growth_perc2030 - 1) * work_machines_2019) / (num_years - 1)

            # Initialize the list for the work_machines values
            work_machines_values = np.full(num_years, work_machines_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                work_machines_values[i] = work_machines_values[i - 1] + annual_growth_increment  # Linear growth

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i  # Current year in the simulation

                wm_value = ((wm / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Apply the lever effect
                work_machines_values[i] *= (1 - ((wm_value)))

            ## product_useLevers    
            product_use_growth_2030 = product_use*growth_perc2030
            product_use_growth_2019 = product_use_2019
            product_use_values = [product_use_growth_2019]
            
            num_years = 2030 - 2021
            
            for i in range(num_years):
                growth_rate_per_year = (product_use_growth_2030 - product_use_growth_2019) / num_years
                interpolated_value = product_use_values[-1] + growth_rate_per_year
                product_use_values.append(interpolated_value)
                
            ## wasteLevers
            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for the industry
            annual_growth_increment = ((growth_perc2030 - 1) * waste_2019) / (num_years - 1)

            # Initialize the list for the waste values
            waste_values = np.full(num_years, waste_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                waste_values[i] = waste_values[i - 1] + annual_growth_increment

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i

                cmu_value = ((cmu / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Apply the lever effect
                waste_values[i] *= (1 - (cmu_value * Share_landfill_samecity))
                
            ## foreign_transportLevers    
            foreign_transport_growth_2030 = foreign_transport*growth_perc2030
            foreign_transport_growth_2019 = foreign_transport_2019
            foreign_transport_values = [foreign_transport_growth_2019]
            
            num_years = 2030 - 2021
            
            for i in range(num_years):
                growth_rate_per_year = (foreign_transport_growth_2030 - foreign_transport_growth_2019) / num_years
                interpolated_value = foreign_transport_values[-1] + growth_rate_per_year
                foreign_transport_values.append(interpolated_value)
                
            ## NegativesLevers    
            Negatives_growth_2030 = Negatives*1
            Negatives_growth_2019 = Negatives_2019
            Negatives_values = [Negatives_growth_2019]
            
            num_years = end_year - start_year + 1  # Add 1 to include the end year
            Negatives_values = [Negatives_growth_2019] * num_years
            
            # Sort the levers by start year
            levers = sorted([(Bioccs_year, bio_ccs), (RW_year, rewetting_emissions), (CC_year, carbon_credit)])
            
            # Apply the levers
            for lever_start_year, lever_percentage in levers:
                # Calculate the total change based on the lever
                total_change = (Negatives_growth_2030 - Negatives_growth_2019) * lever_percentage / 100
            
                # Calculate the yearly change
                yearly_change = total_change / (end_year - (lever_start_year + 1) + 1)
            
                # Apply the yearly change to each year from the year after the start of the lever
                for i in range(lever_start_year - start_year + 1, num_years):
                    Negatives_values[i] += yearly_change * (i - (lever_start_year - start_year + 1) + 1)
            
                
                years = list(range(2021, 2031))
                # Create a color scale for the categories
                color_scale = ["#ef553b", "#FECB52", "#e377c2", '#AB63FA', '#FFA15A', "#9467bd",
                               "#ff7f0e", '#B6E880', "#1f77b4", "#d62728"]
    
            categories = ["Agriculture","Waste","Transport", "Foreign transport", "Work machinery", "Electricity and DH",
                   "Own heating","Product use","Industry", "Negatives"]
            values1 = [agriculture_values1, waste_values1, transport_values1, foreign_transport_values1,
                       work_machines_values1, el_dh_values1, own_heating_values1, product_use_values1, industry_values1, Negatives_values1]
            values2 = [agriculture_values, waste_values, transport_values, foreign_transport_values,
                       work_machines_values, el_dh_values, own_heating_values, product_use_values, industry_values, Negatives_values]
            
          
            # Create a figure with two subplots, each containing a stacked bar chart
            fig = make_subplots(rows=2, cols=1, subplot_titles=("Forecasted emissions 2030: {} Kg".format(round(scenario2total_2030)), "Emissions after climate action 2030: {} Kg".format(round(EAC2_2030))), shared_xaxes=False, shared_yaxes=False)

            # Categories to display on the positive side
            positive_categories = ["Agriculture", "Waste", "Transport", "Foreign transport", "Work machinery", "Electricity and DH", "Own heating", "Product use", "Industry"]
            
            # Plot stacked bar chart for BAU Scenario
            for i in range(len(categories)):
                if categories[i] in positive_categories:
                    fig.add_trace(
                        go.Bar(x=years, y=values1[i], name=categories[i], hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=1, col=1
                    )
                else:
                    fig.add_trace(
                        go.Bar(x=years, y=[-val for val in values1[i]], name=categories[i], hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=1, col=1
                    )
            
            # Plot stacked bar chart for Scenario
            for i in range(len(categories)):
                if categories[i] in positive_categories:
                    fig.add_trace(
                        go.Bar(x=years, y=values2[i], showlegend=False, hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=2, col=1
                    )
                else:
                    fig.add_trace(
                        go.Bar(x=years, y=[-val for val in values2[i]], showlegend=False, hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=2, col=1
                    )
                    
            # Compute the net emissions for each year
            netzero_emissions_values = []
            for year in range(len(years)):
                positive_sum = sum(values2[i][year] for i in range(len(categories)) if categories[i] in positive_categories)
                negative_sum = sum(values2[i][year] for i in range(len(categories)) if categories[i] not in positive_categories)
                netzero_emissions_values.append(positive_sum - negative_sum)
                    
            # Plot line chart for Netzero emissions
            fig.add_trace(
                go.Scatter(x=years, y=netzero_emissions_values, name="Net emissions", mode='lines', hovertemplate="Variable: Net emissions<br>Value: %{y}<extra></extra>", marker=dict(color='#000080'), line=dict(width=3)),
                row=2, col=1
            )
            
            # Add labels and titles
            fig.update_layout(
                barmode="relative",
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Emissions profile in {} (Kg of CO2-eq)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='Kg of CO2-eq',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                    #tickformat=".0f",  # Format tick labels as decimal numbers
                    #ticksuffix=" Kg"  # Add "Kg" suffix to tick labels
                ),
                height=800
            )
            
            # Automatically determine the y-axis range for both charts based on the data
            fig.update_yaxes(row=1, col=1, autorange=True)
            fig.update_yaxes(row=2, col=1, autorange=True)
            
            # Update x-axis labels and tick values for both charts
            fig.update_xaxes(title_text="Years", ticktext=[str(year) for year in years], tickvals=years, row=1, col=1)
            fig.update_xaxes(title_text="Years", ticktext=[str(year) for year in years], tickvals=years, row=2, col=1)
            
            # Update y-axis label for the second chart
            fig.update_yaxes(title_text="Kg of CO2-eq", row=2, col=1)
            
            # Update y-axis label for the second chart
            fig.update_yaxes(title_text="Kg of CO2-eq", row=2, col=1)
            
         
            data_exp = {
            "Sectors": categories,
            "Input1": values1,
            "Input2": values2}

            fig_output = fig
            data_em_output = pd.DataFrame.from_dict(data_exp, orient='index').to_dict('records')

    if scenario == "Scenario 2 - Pessimistic Scenario" and emissions_output == "Per capita emissions" and ci_dropdown == 'Improved air quality':
            ##################################Co-impacts###################################################################

            # 2030 emission value from the provided array
            agr_emission_2030 = agriculture_values[-1] - agriculture_values[0] # Last value in the array

            # Calculate reduced emissions and total cost
            agr_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = agr_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                agr_total_cost += (-cost)

            # 2030 emission value from the provided array
            trans_emission_2030 = transport_values[-1] - transport_values[0]# Last value in the array

            # Calculate reduced emissions and total cost
            trans_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = trans_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                trans_total_cost += (-cost)

            # 2030 emission value from the provided array
            waste_emission_2030 = waste_values[-1] - waste_values[0]   # Last value in the array

            # Calculate reduced emissions and total cost
            waste_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = waste_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                waste_total_cost += (-cost)

            # 2030 emission value from the provided array
            ft_emission_2030 = foreign_transport_values[-1] - foreign_transport_values[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            ft_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = ft_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                ft_total_cost += (-cost)

            # 2030 emission value from the provided array
            wm_emission_2030 = work_machines_values[-1] - work_machines_values[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            wm_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = wm_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                wm_total_cost += (-cost)

            # 2030 emission value from the provided array
            el_emission_2030 = el_dh_values[-1] - el_dh_values[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            el_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = el_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                el_total_cost += (-cost)

            # 2030 emission value from the provided array
            oh_emission_2030 = own_heating_values[-1] - own_heating_values[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            oh_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = oh_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                oh_total_cost += (-cost)

            # 2030 emission value from the provided array
            pu_emission_2030 = product_use_values[-1] - product_use_values[0] # Last value in the array

            # Calculate reduced emissions and total cost
            pu_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = pu_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                pu_total_cost += (-cost)

            # 2030 emission value from the provided array
            ind_emission_2030 = industry_values[-1] - industry_values[0] # Last value in the array

            # Calculate reduced emissions and total cost
            ind_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = ind_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                ind_total_cost += (-cost)


            # Given total costs for each sector
            sectors = {
                'Agriculture': agr_total_cost,
                'Transport': trans_total_cost,
                'Waste': waste_total_cost,
                'Foreign Transport': ft_total_cost,
                'Work Machines': wm_total_cost,
                'Electric DH': el_total_cost,
                'Own Heating': oh_total_cost,
                'Product Use': pu_total_cost,
                'Industry': ind_total_cost
            }

            # Actors and their share
            actors_share = {
                'Total':1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share


            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Per Capita - Cumulative Co-benefits of improved air quality in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Per capita - Cumulative co-benefits of improved air quality 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df

    elif scenario == "Scenario 2 - Pessimistic Scenario" and emissions_output == "Per capita emissions" and ci_dropdown == 'Reduced noise pollution':
            ##################################Co-impacts###################################################################

            growth_perc2030 = 1
            growth_perc2019 = 1

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
            bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
            heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
            light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
            air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
            other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)

            car_values = np.full(num_years, cars_2019)
            bus_values = np.full(num_years, buses_2019)
            heavy_truck_values = np.full(num_years, heavy_trucks_2019)
            light_truck_values = np.full(num_years, light_trucks_2019)
            air_transport_values = np.full(num_years, air_transport_2019)
            other_transport_values = np.full(num_years, other_transport_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment
                bus_values[i] = bus_values[i - 1] + bus_growth_increment
                heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
                light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
                air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
                other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment

            # Apply the levers
            for i in range(num_years):
                current_year = 2021 + i
                pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (2030 - RC_year) if current_year >= RC_year else 0
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0
                el_car_value = ((el_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 00
                electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Calculate the values for each type of transport
                car_values[i] *= (1 - ((pt_car_value + act_trans_value + (el_car_value * caremission_intensity_EV)))) #####refernce available only for electric cars
                bus_values[i] *= (1 - ((el_bus_value * busemission_intensity_EV)))
                heavy_truck_values[i] *= (1 - (((electric_heavy_value * HT_emission_intensity_EV))))
                light_truck_values[i] *= (1 - (((electric_light_value * LT_emission_intensity_EV))))

            ###############computational part of co-benefits#####################
            # 2030 emission value from the provided array
            Car_emission_per_emission = car_values[-1] - car_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            car_per_km_emission= Car_emission_per_km/Car_emission_per_emission ########unit is value/kms
            caremission_per_km = 1/car_per_km_emission ###unit is kms
            Total_cb_np_cars = caremission_per_km * Cobenefits_np_cars

            bus_emission_per_emission = bus_values[-1] - bus_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            bus_per_km_emission= bus_emission_per_km/bus_emission_per_emission ########unit is value/kms
            busemission_per_km = 1/bus_per_km_emission ###unit is kms
            Total_cb_np_buses = busemission_per_km * Cobenefits_np_buses

            ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
            htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
            Total_cb_np_ht = htemission_per_km * Cobenefits_np_ht

            lt_emission_per_emission =  light_truck_values[-1] -  light_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
            ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
            Total_cb_np_lt = ltemission_per_km * Cobenefits_np_lt

            transport_cp_np = -(Total_cb_np_cars + Total_cb_np_buses + Total_cb_np_ht + Total_cb_np_lt)

            # Given total costs for each sector
            sectors = {
                'Agriculture': 0,
                'Transport': transport_cp_np,
                'Waste': 0,
                'Foreign Transport': 0,
                'Work Machines': 0,
                'Electric DH': 0,
                'Own Heating': 0,
                'Product Use': 0,
                'Industry': 0
            }

            # Actors and their share
            actors_share = {
                'Total':1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share


            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Per Capita - Cummulative Co-benefits of reduced noise pollution in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Per capita - Cumulative co-benefits of reduced noise pollution 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df

    elif scenario == "Scenario 2 - Pessimistic Scenario" and emissions_output == "Per capita emissions" and ci_dropdown == 'Improved traffic safety':
            ##################################Co-impacts###################################################################

            growth_perc2030 = 1
            growth_perc2019 = 1

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
            bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
            heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
            light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
            air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
            other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)

            car_values = np.full(num_years, cars_2019)
            bus_values = np.full(num_years, buses_2019)
            heavy_truck_values = np.full(num_years, heavy_trucks_2019)
            light_truck_values = np.full(num_years, light_trucks_2019)
            air_transport_values = np.full(num_years, air_transport_2019)
            other_transport_values = np.full(num_years, other_transport_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment
                bus_values[i] = bus_values[i - 1] + bus_growth_increment
                heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
                light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
                air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
                other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment

            # Apply the levers
            for i in range(num_years):
                current_year = 2021 + i
                pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (2030 - RC_year) if current_year >= RC_year else 0
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0
                el_car_value = ((el_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 00
                electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Calculate the values for each type of transport
                car_values[i] *= (1 - ((pt_car_value + act_trans_value + (el_car_value * caremission_intensity_EV)))) #####refernce available only for electric cars
                bus_values[i] *= (1 - ((el_bus_value * busemission_intensity_EV)))
                heavy_truck_values[i] *= (1 - (((electric_heavy_value * HT_emission_intensity_EV))))
                light_truck_values[i] *= (1 - (((electric_light_value * LT_emission_intensity_EV))))

            ###############computational part of co-benefits#####################
            # 2030 emission value from the provided array
            Car_emission_per_emission = car_values[-1] - car_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            car_per_km_emission= Car_emission_per_km/Car_emission_per_emission ########unit is value/kms
            caremission_per_km = 1/car_per_km_emission ###unit is kms
            Total_cb_ts_cars = caremission_per_km * Cobenefits_ts_cars

            bus_emission_per_emission = bus_values[-1] - bus_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            bus_per_km_emission= bus_emission_per_km/bus_emission_per_emission ########unit is value/kms
            busemission_per_km = 1/bus_per_km_emission ###unit is kms
            Total_cb_ts_buses = busemission_per_km * Cobenefits_ts_buses

            ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
            htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
            Total_cb_ts_ht = htemission_per_km * Cobenefits_ts_ht

            lt_emission_per_emission =  light_truck_values[-1] -  light_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
            ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
            Total_cb_ts_lt = ltemission_per_km * Cobenefits_ts_lt

            transport_cp_ts = -(Total_cb_ts_cars + Total_cb_ts_buses + Total_cb_ts_ht + Total_cb_ts_lt)

            # Given total costs for each sector
            sectors = {
                'Agriculture': 0,
                'Transport': transport_cp_ts,
                'Waste': 0,
                'Foreign Transport': 0,
                'Work Machines': 0,
                'Electric DH': 0,
                'Own Heating': 0,
                'Product Use': 0,
                'Industry': 0
            }

            # Actors and their share
            actors_share = {
                'Total':1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share


            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Per Capita - Cummulative Co-benefits of improved traffic safety in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )


            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Per capita - Cumulative co-benefits of improved traffic safety 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df

    elif scenario == "Scenario 2 - Pessimistic Scenario" and emissions_output == "Per capita emissions" and ci_dropdown == 'Improved physical health':
            ##################################Co-impacts###################################################################

            growth_perc2030 = 1
            growth_perc2019 = 1

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)

            car_values = np.full(num_years, cars_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment

            # Apply the levers
            for i in range(num_years):
                current_year = 2021 + i
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0

                # Calculate the values for each type of transport
                car_values[i] *= (1 - ((act_trans_value))) #####refernce available only for electric cars

            ###############computational part of co-benefits#####################
            # 2030 emission value from the provided array
            Car_emission_per_emission = car_values[-1] - car_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            car_per_km_emission= Car_emission_per_km/Car_emission_per_emission ########unit is value/kms
            caremission_per_km = 1/car_per_km_emission ###unit is kms
            Total_cb_at_cars = caremission_per_km * Cobenefits_at_cars

            transport_cp_at = -Total_cb_at_cars

            # Given total costs for each sector
            sectors = {
                'Agriculture': 0,
                'Transport': transport_cp_at,
                'Waste': 0,
                'Foreign Transport': 0,
                'Work Machines': 0,
                'Electric DH': 0,
                'Own Heating': 0,
                'Product Use': 0,
                'Industry': 0
            }

            # Actors and their share
            actors_share = {
                'Total':1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share


            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Per Capita - Cummulative Co-benefits of improved physical health (active transport) in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Per capita - Cumulative co-benefits of improved physical health 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df

    if scenario == "Scenario 2 - Pessimistic Scenario" and emissions_output == "Per capita emissions" and ci_dropdown == 'Total':
        ##################################Co-impacts###################################################################

        ########################Air quality ###################################
        # 2030 emission value from the provided array
        agr_emission_2030 = agriculture_values[-1] - agriculture_values[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        agr_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = agr_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            agr_total_cost += (-cost)

        # 2030 emission value from the provided array
        trans_emission_2030 = transport_values[-1] - transport_values[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        trans_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = trans_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            trans_total_cost += (-cost)

        # 2030 emission value from the provided array
        waste_emission_2030 = waste_values[-1] - waste_values[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        waste_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = waste_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            waste_total_cost += (-cost)

        # 2030 emission value from the provided array
        ft_emission_2030 = foreign_transport_values[-1] - foreign_transport_values[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        ft_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = ft_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            ft_total_cost += (-cost)

        # 2030 emission value from the provided array
        wm_emission_2030 = work_machines_values[-1] - work_machines_values[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        wm_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = wm_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            wm_total_cost += (-cost)

        # 2030 emission value from the provided array
        el_emission_2030 = el_dh_values[-1] - el_dh_values[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        el_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = el_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            el_total_cost += (-cost)

        # 2030 emission value from the provided array
        oh_emission_2030 = own_heating_values[-1] - own_heating_values[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        oh_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = oh_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            oh_total_cost += (-cost)

        # 2030 emission value from the provided array
        pu_emission_2030 = product_use_values[-1] - product_use_values[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        pu_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = pu_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            pu_total_cost += (-cost)

        # 2030 emission value from the provided array
        ind_emission_2030 = industry_values[-1] - industry_values[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        ind_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = ind_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            ind_total_cost += (-cost)

        ###########################Noise pollution ############################
        growth_perc2030 = 1
        # Initialize the number of years in the simulation
        num_years = 2030 - 2021 + 1

        # Calculate the annual growth increment for each type of transport
        car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
        bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
        heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
        light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
        air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
        other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)

        car_values = np.full(num_years, cars_2019)
        bus_values = np.full(num_years, buses_2019)
        heavy_truck_values = np.full(num_years, heavy_trucks_2019)
        light_truck_values = np.full(num_years, light_trucks_2019)
        air_transport_values = np.full(num_years, air_transport_2019)
        other_transport_values = np.full(num_years, other_transport_2019)

        # Apply the linear growth from 2019 to 2030
        for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
            car_values[i] = car_values[i - 1] + car_growth_increment
            bus_values[i] = bus_values[i - 1] + bus_growth_increment
            heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
            light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
            air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
            other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment

        # Apply the levers
        for i in range(num_years):
            current_year = 2021 + i
            pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (
                        2030 - RC_year) if current_year >= RC_year else 0
            act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (
                        2030 - AT_year) if current_year >= AT_year else 0
            el_car_value = ((el_car / 100) * (current_year - start_year)) / (
                        2030 - start_year) if current_year >= start_year else 0
            el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (
                        2030 - start_year) if current_year >= start_year else 00
            electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (
                        2030 - start_year) if current_year >= start_year else 0
            electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (
                        2030 - start_year) if current_year >= start_year else 0

            # Calculate the values for each type of transport
            car_values[i] *= (1 - ((pt_car_value + act_trans_value + (
                        el_car_value * caremission_intensity_EV))))  #####refernce available only for electric cars
            bus_values[i] *= (1 - ((el_bus_value * busemission_intensity_EV)))
            heavy_truck_values[i] *= (1 - (((electric_heavy_value * HT_emission_intensity_EV))))
            light_truck_values[i] *= (1 - (((electric_light_value * LT_emission_intensity_EV))))

        ###############computational part of co-benefits#####################
        # 2030 emission value from the provided array
        Car_emission_per_emission = car_values[-1] - car_values[
            0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        car_per_km_emission = Car_emission_per_km / Car_emission_per_emission  ########unit is value/kms
        caremission_per_km = 1 / car_per_km_emission  ###unit is kms
        Total_cb_np_cars = caremission_per_km * Cobenefits_np_cars

        bus_emission_per_emission = bus_values[-1] - bus_values[
            0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        bus_per_km_emission = bus_emission_per_km / bus_emission_per_emission  ########unit is value/kms
        busemission_per_km = 1 / bus_per_km_emission  ###unit is kms
        Total_cb_np_buses = busemission_per_km * Cobenefits_np_buses

        ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[
            0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
        htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
        Total_cb_np_ht = htemission_per_km * Cobenefits_np_ht

        lt_emission_per_emission = light_truck_values[-1] - light_truck_values[
            0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
        ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
        Total_cb_np_lt = ltemission_per_km * Cobenefits_np_lt

        transport_cp_np = -(Total_cb_np_cars + Total_cb_np_buses + Total_cb_np_ht + Total_cb_np_lt)

        #######################Traffic safety##################

        ###############computational part of co-benefits#####################
        # 2030 emission value from the provided array
        Car_emission_per_emission = car_values[-1] - car_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        car_per_km_emission = Car_emission_per_km / Car_emission_per_emission  ########unit is value/kms
        caremission_per_km = 1 / car_per_km_emission  ###unit is kms
        Total_cb_ts_cars = caremission_per_km * Cobenefits_ts_cars

        bus_emission_per_emission = bus_values[-1] - bus_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        bus_per_km_emission = bus_emission_per_km / bus_emission_per_emission  ########unit is value/kms
        busemission_per_km = 1 / bus_per_km_emission  ###unit is kms
        Total_cb_ts_buses = busemission_per_km * Cobenefits_ts_buses

        ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
        htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
        Total_cb_ts_ht = htemission_per_km * Cobenefits_ts_ht

        lt_emission_per_emission = light_truck_values[-1] - light_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
        ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
        Total_cb_ts_lt = ltemission_per_km * Cobenefits_ts_lt

        transport_cp_ts = -(Total_cb_ts_cars + Total_cb_ts_buses + Total_cb_ts_ht + Total_cb_ts_lt)

        #############Improved physical health ##############

        # Initialize the number of years in the simulation
        num_years = 2030 - 2021 + 1

        # Calculate the annual growth increment for each type of transport
        car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)

        car_values = np.full(num_years, cars_2019)

        # Apply the linear growth from 2019 to 2030
        for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
            car_values[i] = car_values[i - 1] + car_growth_increment

        # Apply the levers
        for i in range(num_years):
            current_year = 2021 + i
            act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0

            # Calculate the values for each type of transport
            car_values[i] *= (1 - ((act_trans_value)))  #####refernce available only for electric cars

        ###############computational part of co-benefits#####################
        # 2030 emission value from the provided array
        Car_emission_per_emission = car_values[-1] - car_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        car_per_km_emission = Car_emission_per_km / Car_emission_per_emission  ########unit is value/kms
        caremission_per_km = 1 / car_per_km_emission  ###unit is kms
        Total_cb_at_cars = caremission_per_km * Cobenefits_at_cars

        transport_cp_at = -Total_cb_at_cars

        Transport = trans_total_cost + transport_cp_at + transport_cp_np + transport_cp_ts

        # Given total costs for each sector
        sectors = {
            'Agriculture': agr_total_cost,
            'Transport': Transport,
            'Waste': waste_total_cost,
            'Foreign Transport': ft_total_cost,
            'Work Machines': wm_total_cost,
            'Electric DH': el_total_cost,
            'Own Heating': oh_total_cost,
            'Product Use': pu_total_cost,
            'Industry': ind_total_cost
        }

        # Actors and their share
        actors_share = {
            'Total': 1,
            'Citizens': 0.4,
            'Civil soceity': 0,
            'Financial institutions': 0,
            'Industry': 0,
            'Municipal governments': 0.6,
            'Superordinate governments': 0,
            'Utility companies': 0

        }

        # Determine the share of each actor
        actors_values = {}
        for actor, share in actors_share.items():
            for sector, cost in sectors.items():
                if sector not in actors_values:
                    actors_values[sector] = {}
                actors_values[sector][actor] = cost * share

        # Define color mapping for sectors
        sector_colors = {
            'Agriculture': "#ef553b",
            'Waste': "#FECB52",
            'Transport': "#e377c2",
            'Foreign Transport': '#AB63FA',
            'Work Machines': '#FFA15A',
            'Electric DH': "#9467bd",
            'Own Heating': "#ff7f0e",
            'Product Use': '#B6E880',
            'Industry': "#1f77b4"
        }

        # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
        fig_ci = go.Figure()

        for sector in sectors.keys():
            fig_ci.add_trace(go.Bar(
                x=list(actors_share.keys()),
                y=[actors_values[sector][actor] for actor in actors_share.keys()],
                name=sector,
                marker_color=sector_colors[sector]
            ))

        fig_ci.update_layout(
            barmode='stack',
            margin=dict(l=40, r=20, b=10, t=60),
            autosize=True,
            title_text="Per Capita - Total Cumulative Co-benefits in {} (SEK) - 2030".format(mun),
            title_font=dict(size=18, color="darkred"),
            xaxis_title="Actors",
            yaxis_title="SEK",
            yaxis=dict(
                showgrid=True,
                gridcolor='lightgray',
                gridwidth=0.5
            )
        )

        def create_dataframe(sectors, actors_share, actors_values):
            unique_sectors = list(sectors.keys())
            unique_actors = list(actors_share.keys())

            # Constructing a Data Dictionary
            data_exp = {"Sectors": unique_sectors}
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    actor_values.append(actors_values[sector].get(actor, 0))
                data_exp[actor] = actor_values

            # Converting Dictionary to DataFrame
            df = pd.DataFrame.from_dict(data_exp)

            # Reordering the DataFrame Columns
            df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

            # Inserting a new row at the beginning
            new_row = ["Per capita - Total Cumulative co-benefits 2030"] + [""] * (len(df.columns) - 1)
            df.loc[-1] = new_row  # adding a row
            df.index = df.index + 1  # shifting index
            df = df.sort_index()  # sorting by index

            # Return the serialized DataFrame
            return df.to_dict(orient='records')

        df = create_dataframe(sectors, actors_share, actors_values)

        fig_ci_output = fig_ci
        data_ci_output = df

    elif scenario == "Scenario 2 - Pessimistic Scenario" and emissions_output == "Municipality emissions":
            start_year = 2021
            end_year = 2030
            num_years = end_year - start_year + 1
         
        
            growth_perc2030= 1.1683
            growth_perc2019 = 1
        
            growth_rate_per_year = (growth_perc2030-growth_perc2019)/(end_year-start_year)
        
            transport_values1 = [transport_2019]

            # Calculate the annual growth increment required to achieve the target growth
            annual_growth_increment = (growth_perc2030 * transport_2019 - transport_2019) / (num_years - 1)
            
            # Calculate the transport values for the years 2019 to 2030
            for i in range(num_years - 1):
                interpolated_value = transport_values1[-1] + annual_growth_increment
                transport_values1.append(interpolated_value)

            # Create a list to store the multiplied values
            transport_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                transport_value = transport_values1[year - start_year]  # Index adjustment
                multiplied_value = transport_value * population
                transport_population_values.append(multiplied_value)
        
            # Repeat the above code for other variables
        
            industry_values1 = [industry_2019]

            # Calculate the annual growth increment required to achieve the target growth
            annual_growth_increment = (growth_perc2030 * industry_2019 - industry_2019) / (num_years - 1)
            
            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = industry_values1[-1] + annual_growth_increment
                industry_values1.append(next_value)

            # Create a list to store the multiplied values
            industry_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                industry_value = industry_values1[year - start_year]  # Index adjustment
                multiplied_value = industry_value * population
                industry_population_values.append(multiplied_value)
                            
            agriculture_values1 = [agriculture_2019]
            
            # Calculate the annual growth increment required to achieve the target growth
            annual_growth_increment = (growth_perc2030 * agriculture_2019 - agriculture_2019) / (num_years - 1)
            
            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = agriculture_values1[-1] + annual_growth_increment
                agriculture_values1.append(next_value)

            # Create a list to store the multiplied values
            agriculture_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                agriculture_value = agriculture_values1[year - start_year]  # Index adjustment
                multiplied_value = agriculture_value * population
                agriculture_population_values.append(multiplied_value)


                ## El DH lever
                
            el_dh_values1 = [el_dh_2019]

            # Calculate the annual growth increment required to achieve the target growth
            annual_growth_increment = (growth_perc2030 * el_dh_2019 - el_dh_2019) / (num_years - 1)

            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = el_dh_values1[-1] + annual_growth_increment
                el_dh_values1.append(next_value)

            # Create a list to store the multiplied values
            el_dh_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                el_dh_value = el_dh_values1[year - start_year]  # Index adjustment
                multiplied_value = el_dh_value * population
                el_dh_population_values.append(multiplied_value)
    
            own_heating_values1 = [own_heating_2019]
            # Calculate the annual growth increment required to achieve the target growth
            annual_growth_increment = (growth_perc2030 * own_heating_2019 - own_heating_2019) / (num_years - 1)
            
            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = own_heating_values1[-1] + annual_growth_increment
                own_heating_values1.append(next_value)

            # Create a list to store the multiplied values
            own_heating_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                own_heating_value = own_heating_values1[year - start_year]  # Index adjustment
                multiplied_value = own_heating_value * population
                own_heating_population_values.append(multiplied_value)


            ## work_machinesLevers
            work_machines_values1 = [work_machines_2019]
            annual_growth_increment = (growth_perc2030 * work_machines_2019 - work_machines_2019) / (num_years - 1)

            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = work_machines_values1[-1] + annual_growth_increment
                work_machines_values1.append(next_value)


            # Create a list to store the multiplied values
            work_machines_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                work_machines_value = work_machines_values1[year - start_year]  # Index adjustment
                multiplied_value = work_machines_value * population
                work_machines_population_values.append(multiplied_value)
            
            product_use_values1 = [product_use_2019]
            annual_growth_increment = (growth_perc2030 * product_use_2019 - product_use_2019) / (num_years - 1)
            
            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = product_use_values1[-1] + annual_growth_increment
                product_use_values1.append(next_value)

            # Create a list to store the multiplied values
            product_use_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                product_use_value = product_use_values1[year - start_year]  # Index adjustment
                multiplied_value = product_use_value * population
                product_use_population_values.append(multiplied_value)
    
            waste_values1 = [waste_2019]
            annual_growth_increment = (growth_perc2030 * waste_2019 - waste_2019) / (num_years - 1)
            
            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = waste_values1[-1] + annual_growth_increment
                waste_values1.append(next_value)

            # Create a list to store the multiplied values
            waste_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                waste_value = waste_values1[year - start_year]  # Index adjustment
                multiplied_value = waste_value * population
                waste_population_values.append(multiplied_value)
    
            foreign_transport_values1 = [foreign_transport_2019]
            annual_growth_increment = (growth_perc2030 * foreign_transport_2019 - foreign_transport_2019) / (num_years - 1)
            
            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = foreign_transport_values1[-1] + annual_growth_increment
                foreign_transport_values1.append(next_value)

            # Create a list to store the multiplied values
            foreign_transport_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                foreign_transport_value = foreign_transport_values1[year - start_year]  # Index adjustment
                multiplied_value = foreign_transport_value * population
                foreign_transport_population_values.append(multiplied_value)
                
            Negatives_values1 = [Negatives_2019]
            for i in range(num_years - 1):
                interpolated_value = Negatives_values1[-1] * (1 + (1-1)/(end_year-start_year))
                Negatives_values1.append(interpolated_value)

            # Create a list to store the multiplied values
            Negatives_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                Negatives_value = Negatives_values1[year - start_year]  # Index adjustment
                multiplied_value = Negatives_value * population
                Negatives_population_values.append(multiplied_value)
                ################Lever###########################

            ## transportLevers
            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
            bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
            heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
            light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
            air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
            other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)

            # Initialize the lists for each type of transport
            car_values = np.full(num_years, cars_2019)
            bus_values = np.full(num_years, buses_2019)
            heavy_truck_values = np.full(num_years, heavy_trucks_2019)
            light_truck_values = np.full(num_years, light_trucks_2019)
            air_transport_values = np.full(num_years, air_transport_2019)
            other_transport_values = np.full(num_years, other_transport_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1,num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment
                bus_values[i] = bus_values[i - 1] + bus_growth_increment
                heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
                light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
                air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
                other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                current_year = 2021 + i

                # Calculate lever values for the current year
                pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (
                            2030 - RC_year) if current_year >= RC_year else 0
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (
                            2030 - AT_year) if current_year >= AT_year else 0
                el_car_value = ((el_car / 100) * (current_year - start_year)) / (
                            2030 - start_year) if current_year >= start_year else 0
                ph_car_value = ((ph_car / 100) * (current_year - start_year)) / (
                            2030 - start_year) if current_year >= start_year else 0
                hydr_car_value = ((hydr_car / 100) * (current_year - start_year)) / (
                            2030 - start_year) if current_year >= start_year else 0
                ren_bus_value = ((ren_bus / 100) * (current_year - RENB_year)) / (
                            2030 - RENB_year) if current_year >= RENB_year else 0
                el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (
                            2030 - start_year) if current_year >= start_year else 0
                LBG_heavy_value = ((LBG_heavy / 100) * (current_year - start_year)) / (
                            2030 - start_year) if current_year >= start_year else 0
                electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (
                            2030 - start_year) if current_year >= start_year else 0
                LBG_light_value = ((LBG_light / 100) * (current_year - start_year)) / (
                            2030 - start_year) if current_year >= start_year else 0
                electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (
                            2030 - start_year) if current_year >= start_year else 0
                air_transp_value = ((air_transp / 100) * (current_year - AIT_year)) / (
                            2030 - AIT_year) if current_year >= AIT_year else 0

                # Apply the lever effects
                car_values[i] *= (1 - ((pt_car_value + act_trans_value + el_car_value * caremission_intensity_EV + ph_car_value * caremission_intensity_PIH + hydr_car_value * caremission_intensity_Hydrogen)))
                bus_values[i] *= (1 - ((ren_bus_value * busemission_intensity_ren + el_bus_value * busemission_intensity_EV)))
                heavy_truck_values[i] *= (1 -((LBG_heavy_value * HT_emission_intensity_LBG + electric_heavy_value * HT_emission_intensity_EV)))
                light_truck_values[i] *= (1 -((LBG_light_value * LT_emission_intensity_LBG + electric_light_value * LT_emission_intensity_EV)))
                air_transport_values[i] *= (1 -air_transp_value)
                other_transport_values[i] *= (1 -(pt_car_value + act_trans_value))

            # The total emissions are the sum of all types of transport
            transport_values = car_values + bus_values + heavy_truck_values + light_truck_values + air_transport_values + other_transport_values

            # Create a list to store the multiplied values
            transport_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                transport_value = transport_values[year - start_year]  # Index adjustment
                multiplied_value = transport_value * population
                transport_population_values1.append(multiplied_value)

            # industryLevers

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for the industry
            industry_growth_increment = ((growth_perc2030 - 1) * industry_2019) / (num_years - 1)

            # Initialize the list for the industry values
            industry_values = np.full(num_years, industry_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1,num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                industry_values[i] = industry_values[i - 1] + industry_growth_increment

            # Apply the levers to the linearly interpolated values
            for i in range(1,num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                current_year = 2021 + i

                # Calculate lever values for the current year
                ccs_value = ((CCS_industry / 100) * (current_year - ccs_year)) / (2030 - ccs_year) if current_year >= ccs_year else 0
                Hyd_value = ((H2_industry / 100) * (current_year - Hyd_year)) / (2030 - Hyd_year) if current_year >= Hyd_year else 0

                # Apply the lever effects
                industry_values[i] *= (1 - ((ccs_value * ccs_emission_intensity) + (Hyd_value * hyd_emission_intensity)))

            # Create a list to store the multiplied values
            industry_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                industry_value = industry_values[year - start_year]  # Index adjustment
                multiplied_value = industry_value * population
                industry_population_values1.append(multiplied_value)

            ## agricultureLevers
            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment
            annual_growth_increment = ((growth_perc2030 - 1) * agriculture_2019) / (num_years - 1)

            # Initialize the list for the agriculture values
            agriculture_values = np.full(num_years, agriculture_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                agriculture_values[i] = agriculture_values[i - 1] + annual_growth_increment  # Linear growth

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i  # Current year in the simulation

                agr_value = ((agr / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Apply the lever effect
                agriculture_values[i] *= (1 - ((agr_value) * agr_emission_intensity))

            # Create a list to store the multiplied values
            agriculture_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                agriculture_value = agriculture_values[year - start_year]  # Index adjustment
                multiplied_value = agriculture_value * population
                agriculture_population_values1.append(multiplied_value)

                ## el_dhLevers
            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for el_dh
            annual_growth_increment = ((growth_perc2030 - 1) * el_dh_2019) / (num_years - 1)

            # Initialize the list for the el_dh values
            el_dh_values = np.full(num_years, el_dh_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                el_dh_values[i] = el_dh_values[i - 1] + annual_growth_increment

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i

                # Calculate lever effects
                wind_value = ((wind / 100) * (current_year - W_year)) / (2030 - W_year) if current_year >= W_year else 0
                rtsolar_value = ((rtsolar / 100) * (current_year - RS_year)) / ( 2030 - RS_year) if current_year >= RS_year else 0
                csolar_value = ((csolar / 100) * (current_year - CS_year)) / (2030 - CS_year) if current_year >= CS_year else 0
                DH_heatpumps_value = ((DH_heatpumps / 100) * (current_year - DHP_year)) / ( 2030 - DHP_year) if current_year >= DHP_year else 0
                ccsw_value = ((ccsw / 100) * (current_year - CCSW_year)) / (2030 - CCSW_year) if current_year >= CCSW_year else 0
                ind_temp_red_value = ((ind_temp_red / 100) * (current_year - start_year)) / ( 2030 - start_year) if current_year >= start_year else 0
                sn_measure_value = ((sn_measure / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                BAT_appl_value = ((BAT_appl / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                el_dh_values[i] *= (((1 - ((BAT_appl_value * BAT_energy_consumption_impact) + (
                            ind_temp_red_value * Ind_temp_impact) + (sn_measure_value * SN_eff_impact))) * ((1 - ((Share_elec_DH) * (
                            ((wind_value * Wind_emissions_intensity)) + ((rtsolar_value * Solar_emission_intensity)) + (
                            (csolar_value) * Solar_emission_intensity)) + ((1 - Share_elec_DH) * ( DH_heatpumps_value) * ((
                            (Share_DH_HP_air * emission_savings_air) + (Share_DH_HP_water * emission_savings_water) + (
                            Share_DH_HP_GT * emission_savings_GT)))))))) * ( 1 - ((ccsw_value) * ccsw_emission_intensity)))


                # Create a list to store the multiplied values
                el_dh_population_values1 = []

                # Iterate over years and calculate multiplied values
                for year in range(start_year, end_year + 1):
                    population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                    el_dh_value = el_dh_values[year - start_year]  # Index adjustment
                    multiplied_value = el_dh_value * population
                    el_dh_population_values1.append(multiplied_value)

            ## own_heatingLevers
            own_heating_growth_2030 = own_heating * growth_perc2030
            own_heating_growth_2019 = own_heating_2019
            own_heating_values = [own_heating_growth_2019]

            num_years = 2030 - 2021

            for i in range(num_years):
                growth_rate_per_year = (own_heating_growth_2030 - own_heating_growth_2019) / num_years
                interpolated_value = own_heating_values[-1] + growth_rate_per_year
                own_heating_values.append(interpolated_value)

            # Create a list to store the multiplied values
            own_heating_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                own_heating_value = own_heating_values[year - start_year]  # Index adjustment
                multiplied_value = own_heating_value * population
                own_heating_population_values1.append(multiplied_value)

            ## work_machinesLevers

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment
            annual_growth_increment = ((growth_perc2030 - 1) * work_machines_2019) / (num_years - 1)

            # Initialize the list for the work_machines values
            work_machines_values = np.full(num_years, work_machines_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                work_machines_values[i] = work_machines_values[i - 1] + annual_growth_increment  # Linear growth

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i  # Current year in the simulation

                wm_value = ((wm / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Apply the lever effect
                work_machines_values[i] *= (1 - ((wm_value)))

            # Create a list to store the multiplied values
            work_machines_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                work_machines_value = work_machines_values[year - start_year]  # Index adjustment
                multiplied_value = work_machines_value * population
                work_machines_population_values1.append(multiplied_value)

            ## product_useLevers
            product_use_growth_2030 = product_use * growth_perc2030
            product_use_growth_2019 = product_use_2019
            product_use_values = [product_use_growth_2019]

            num_years = 2030 - 2021

            for i in range(num_years):
                growth_rate_per_year = (product_use_growth_2030 - product_use_growth_2019) / num_years
                interpolated_value = product_use_values[-1] + growth_rate_per_year
                product_use_values.append(interpolated_value)

            # Create a list to store the multiplied values
            product_use_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                product_use_value = product_use_values[year - start_year]  # Index adjustment
                multiplied_value = product_use_value * population
                product_use_population_values1.append(multiplied_value)

            ## wasteLevers
            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for the industry
            annual_growth_increment = ((growth_perc2030 - 1) * waste_2019) / (num_years - 1)

            # Initialize the list for the waste values
            waste_values = np.full(num_years, waste_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                waste_values[i] = waste_values[i - 1] + annual_growth_increment

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i

                cmu_value = ((cmu / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Apply the lever effect
                waste_values[i] *= (1 - (cmu_value * Share_landfill_samecity))

            # Create a list to store the multiplied values
            waste_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                waste_value = waste_values[year - start_year]  # Index adjustment
                multiplied_value = waste_value * population
                waste_population_values1.append(multiplied_value)

            ## foreign_transportLevers
            foreign_transport_growth_2030 = foreign_transport * growth_perc2030
            foreign_transport_growth_2019 = foreign_transport_2019
            foreign_transport_values = [foreign_transport_growth_2019]

            num_years = 2030 - 2021

            for i in range(num_years):
                growth_rate_per_year = (foreign_transport_growth_2030 - foreign_transport_growth_2019) / num_years
                interpolated_value = foreign_transport_values[-1] + growth_rate_per_year
                foreign_transport_values.append(interpolated_value)

            # Create a list to store the multiplied values
            foreign_transport_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                foreign_transport_value = foreign_transport_values[year - start_year]  # Index adjustment
                multiplied_value = foreign_transport_value * population
                foreign_transport_population_values1.append(multiplied_value)

            ## NegativesLevers
            Negatives_growth_2030 = Negatives * 1
            Negatives_growth_2019 = Negatives_2019
            Negatives_values = [Negatives_growth_2019]

            num_years = end_year - start_year + 1  # Add 1 to include the end year
            Negatives_values = [Negatives_growth_2019] * num_years

            # Sort the levers by start year
            levers = sorted([(Bioccs_year, bio_ccs), (RW_year, rewetting_emissions), (CC_year, carbon_credit)])

            # Apply the levers
            for lever_start_year, lever_percentage in levers:
                # Calculate the total change based on the lever
                total_change = (Negatives_growth_2030 - Negatives_growth_2019) * lever_percentage / 100

                # Calculate the yearly change
                yearly_change = total_change / (end_year - (lever_start_year + 1) + 1)

                # Apply the yearly change to each year from the year after the start of the lever
                for i in range(lever_start_year - start_year + 1, num_years):
                    Negatives_values[i] += yearly_change * (i - (lever_start_year - start_year + 1) + 1)

            # Create a list to store the multiplied values
            Negatives_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                Negatives_value = Negatives_values[year - start_year]  # Index adjustment
                multiplied_value = Negatives_value * population
                Negatives_population_values1.append(multiplied_value)

                PM1_total_emissions_2030 = (
                                                    transport_population_values[-1] +
                                                    industry_population_values[-1] +
                                                    agriculture_population_values[-1] +
                                                    el_dh_population_values[-1] +
                                                    own_heating_population_values1[-1] +
                                                    work_machines_population_values[-1] +
                                                    product_use_population_values[-1] +
                                                    waste_population_values[-1] +
                                                    foreign_transport_population_values[-1]

                                            ) / 1000000

                PM2_total_emissions_2030 = (
                                                    transport_population_values1[-1] +
                                                    industry_population_values1[-1] +
                                                    agriculture_population_values1[-1] +
                                                    el_dh_population_values1[-1] +
                                                    own_heating_population_values1[-1] +
                                                    work_machines_population_values1[-1] +
                                                    product_use_population_values1[-1] +
                                                    waste_population_values1[-1] +
                                                    foreign_transport_population_values1[-1]

                                            ) / 1000000

                years = list(range(2021, 2031))
                # Create a color scale for the categories
                color_scale = ["#ef553b", "#FECB52", "#e377c2", '#AB63FA', '#FFA15A', "#9467bd",
                               "#ff7f0e", '#B6E880', "#1f77b4", "#d62728"]
    
            categories = ["Agriculture","Waste","Transport", "Foreign transport", "Work machinery", "Electricity and DH",
                   "Own heating","Product use","Industry", "Negatives"]
            values1 = [agriculture_population_values, waste_population_values , transport_population_values, foreign_transport_population_values,
                       work_machines_population_values, el_dh_population_values, own_heating_population_values,product_use_population_values, industry_population_values, Negatives_population_values]
            values2 = [agriculture_population_values1, waste_population_values1, transport_population_values1, foreign_transport_population_values1,
                       work_machines_population_values1, el_dh_population_values1, own_heating_population_values1, product_use_population_values1, industry_population_values1, Negatives_population_values1]
            
          
            # Create a figure with two subplots, each containing a stacked bar chart
            fig = make_subplots(rows=2, cols=1, subplot_titles=(f"Total Forecasted Emissions for 2030: {PM1_total_emissions_2030:.2f}", f"Total Emissions after taking measures for 2030: {PM2_total_emissions_2030:.2f}"), shared_xaxes=False, shared_yaxes=False)

            # Categories to display on the positive side
            positive_categories = ["Agriculture", "Waste", "Transport", "Foreign transport", "Work machinery", "Electricity and DH", "Own heating", "Product use", "Industry"]
            
            # Plot stacked bar chart for BAU Scenario
            for i in range(len(categories)):
                if categories[i] in positive_categories:
                    fig.add_trace(
                        go.Bar(x=years, y=values1[i], name=categories[i], hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=1, col=1
                    )
                else:
                    fig.add_trace(
                        go.Bar(x=years, y=[-val for val in values1[i]], name=categories[i], hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=1, col=1
                    )
            
            # Plot stacked bar chart for Scenario
            for i in range(len(categories)):
                if categories[i] in positive_categories:
                    fig.add_trace(
                        go.Bar(x=years, y=values2[i], showlegend=False, hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=2, col=1
                    )
                else:
                    fig.add_trace(
                        go.Bar(x=years, y=[-val for val in values2[i]], showlegend=False, hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=2, col=1
                    )
                    
            # Compute the net emissions for each year
            netzero_emissions_values = []
            for year in range(len(years)):
                positive_sum = sum(values2[i][year] for i in range(len(categories)) if categories[i] in positive_categories)
                negative_sum = sum(values2[i][year] for i in range(len(categories)) if categories[i] not in positive_categories)
                netzero_emissions_values.append(positive_sum - negative_sum)
                    
            # Plot line chart for Netzero emissions
            fig.add_trace(
                go.Scatter(x=years, y=netzero_emissions_values, name="Net emissions", mode='lines', hovertemplate="Variable: Net emissions<br>Value: %{y}<extra></extra>", marker=dict(color='#000080'), line=dict(width=3)),
                row=2, col=1
            )
            
            # Add labels and titles
            fig.update_layout(
                barmode="relative",
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Emissions profile in {} (Ton of CO2-eq)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='Ton of CO2-eq',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                    #tickformat=".0f",  # Format tick labels as decimal numbers
                    #ticksuffix=" Kg"  # Add "Kg" suffix to tick labels
                ),
                height=800
            )
            
            # Automatically determine the y-axis range for both charts based on the data
            fig.update_yaxes(row=1, col=1, autorange=True)
            fig.update_yaxes(row=2, col=1, autorange=True)
            
            # Update x-axis labels and tick values for both charts
            fig.update_xaxes(title_text="Years", ticktext=[str(year) for year in years], tickvals=years, row=1, col=1)
            fig.update_xaxes(title_text="Years", ticktext=[str(year) for year in years], tickvals=years, row=2, col=1)
            
            # Update y-axis label for the second chart
            fig.update_yaxes(title_text="Ton of CO2-eq", row=2, col=1)
            
            # Update y-axis label for the second chart
            fig.update_yaxes(title_text="Ton of CO2-eq", row=2, col=1)
            
            data_exp = {
            "Sectors": categories,
            "Input1": values1,
            "Input2": values2}

            fig_output = fig
            data_em_output = pd.DataFrame.from_dict(data_exp, orient='index').to_dict('records')

    if scenario == "Scenario 2 - Pessimistic Scenario" and emissions_output == "Municipality emissions" and ci_dropdown == 'Improved air quality':
            ##################################Co-impacts###################################################################

            # 2030 emission value from the provided array
            agr_emission_2030 = agriculture_population_values1[-1] - agriculture_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            agr_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = agr_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                agr_total_cost += (-cost)

            # 2030 emission value from the provided array
            trans_emission_2030 = transport_population_values1[-1] - transport_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            trans_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = trans_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                trans_total_cost += (-cost)

            # 2030 emission value from the provided array
            waste_emission_2030 = waste_population_values1[-1] - waste_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            waste_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = waste_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                waste_total_cost += (-cost)

            # 2030 emission value from the provided array
            ft_emission_2030 = foreign_transport_population_values1[-1] - foreign_transport_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            ft_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = ft_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                ft_total_cost += (-cost)

            # 2030 emission value from the provided array
            wm_emission_2030 = work_machines_population_values1[-1] - work_machines_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            wm_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = wm_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                wm_total_cost += (-cost)

            # 2030 emission value from the provided array
            el_emission_2030 = el_dh_population_values1[-1] - el_dh_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            el_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = el_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                el_total_cost += (-cost)

            # 2030 emission value from the provided array
            oh_emission_2030 = own_heating_population_values1[-1] - own_heating_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            oh_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = oh_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                oh_total_cost += (-cost)

            # 2030 emission value from the provided array
            pu_emission_2030 = product_use_population_values1[-1] - product_use_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            pu_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = pu_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                pu_total_cost += (-cost)

            # 2030 emission value from the provided array
            ind_emission_2030 = industry_population_values1[-1] - industry_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            ind_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = ind_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                ind_total_cost += (-cost)

            # Given total costs for each sector
            sectors = {
                'Agriculture': agr_total_cost,
                'Transport': trans_total_cost,
                'Waste': waste_total_cost,
                'Foreign Transport': ft_total_cost,
                'Work Machines': wm_total_cost,
                'Electric DH': el_total_cost,
                'Own Heating': oh_total_cost,
                'Product Use': pu_total_cost,
                'Industry': ind_total_cost
            }

            # Actors and their share
            actors_share = {
                'Total': 1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share

            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Municipality - Cumulative Co-benefits of improved air quality in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Municipality - Cumulative co-benefits of improved air quality 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df

    elif scenario == "Scenario 2 - Pessimistic Scenario" and emissions_output == "Municipality emissions" and ci_dropdown == 'Reduced noise pollution':
            ##################################Co-impacts###################################################################

            growth_perc2030 = 1
            growth_perc2019 = 1

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
            bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
            heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
            light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
            air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
            other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)

            car_values = np.full(num_years, cars_2019)
            bus_values = np.full(num_years, buses_2019)
            heavy_truck_values = np.full(num_years, heavy_trucks_2019)
            light_truck_values = np.full(num_years, light_trucks_2019)
            air_transport_values = np.full(num_years, air_transport_2019)
            other_transport_values = np.full(num_years, other_transport_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment
                bus_values[i] = bus_values[i - 1] + bus_growth_increment
                heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
                light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
                air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
                other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment

            # Apply the levers
            for i in range(num_years):
                current_year = 2021 + i
                pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (2030 - RC_year) if current_year >= RC_year else 0
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0
                el_car_value = ((el_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 00
                electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Calculate the values for each type of transport
                car_values[i] *= (1 - ((pt_car_value + act_trans_value + (el_car_value * caremission_intensity_EV)))) #####refernce available only for electric cars
                bus_values[i] *= (1 - ((el_bus_value * busemission_intensity_EV)))
                heavy_truck_values[i] *= (1 - (((electric_heavy_value * HT_emission_intensity_EV))))
                light_truck_values[i] *= (1 - (((electric_light_value * LT_emission_intensity_EV))))

            ###############computational part of co-benefits#####################
            # 2030 emission value from the provided array
            Car_emission_per_emission = car_values[-1] - car_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            car_per_km_emission= Car_emission_per_km/Car_emission_per_emission ########unit is value/kms
            caremission_per_km = 1/car_per_km_emission ###unit is kms
            Total_cb_np_cars = (caremission_per_km * Cobenefits_np_cars)* pop.loc[str(mun), 20300] ###############20300 means the average population of the each municipality is taken into account

            bus_emission_per_emission = bus_values[-1] - bus_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            bus_per_km_emission= bus_emission_per_km/bus_emission_per_emission ########unit is value/kms
            busemission_per_km = 1/bus_per_km_emission ###unit is kms
            Total_cb_np_buses = (busemission_per_km * Cobenefits_np_buses)* pop.loc[str(mun), 20300] ###############20300 means the average population of the each municipality is taken into account

            ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
            htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
            Total_cb_np_ht = (htemission_per_km * Cobenefits_np_ht)* pop.loc[str(mun), 20300] ###############20300 means the average population of the each municipality is taken into account

            lt_emission_per_emission =  light_truck_values[-1] -  light_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
            ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
            Total_cb_np_lt = (ltemission_per_km * Cobenefits_np_lt)* pop.loc[str(mun), 20300] ###############20300 means the average population of the each municipality is taken into account

            transport_cp_np = -(Total_cb_np_cars + Total_cb_np_buses + Total_cb_np_ht + Total_cb_np_lt)

            # Given total costs for each sector
            sectors = {
                'Agriculture': 0,
                'Transport': transport_cp_np,
                'Waste': 0,
                'Foreign Transport': 0,
                'Work Machines': 0,
                'Electric DH': 0,
                'Own Heating': 0,
                'Product Use': 0,
                'Industry': 0
            }

            # Actors and their share
            actors_share = {
                'Total':1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share


            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Municipality - Cumulative Co-benefits of reduced noise pollution in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Municipality - Cumulative co-benefits of reduced noise pollution 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df

    elif scenario == "Scenario 2 - Pessimistic Scenario" and emissions_output == "Municipality emissions" and ci_dropdown == 'Improved traffic safety':
            ##################################Co-impacts###################################################################

            growth_perc2030 = 1
            growth_perc2019 = 1

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
            bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
            heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
            light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
            air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
            other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)

            car_values = np.full(num_years, cars_2019)
            bus_values = np.full(num_years, buses_2019)
            heavy_truck_values = np.full(num_years, heavy_trucks_2019)
            light_truck_values = np.full(num_years, light_trucks_2019)
            air_transport_values = np.full(num_years, air_transport_2019)
            other_transport_values = np.full(num_years, other_transport_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment
                bus_values[i] = bus_values[i - 1] + bus_growth_increment
                heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
                light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
                air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
                other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment

            # Apply the levers
            for i in range(num_years):
                current_year = 2021 + i
                pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (2030 - RC_year) if current_year >= RC_year else 0
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0
                el_car_value = ((el_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 00
                electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Calculate the values for each type of transport
                car_values[i] *= (1 - ((pt_car_value + act_trans_value + (el_car_value * caremission_intensity_EV)))) #####refernce available only for electric cars
                bus_values[i] *= (1 - ((el_bus_value * busemission_intensity_EV)))
                heavy_truck_values[i] *= (1 - (((electric_heavy_value * HT_emission_intensity_EV))))
                light_truck_values[i] *= (1 - (((electric_light_value * LT_emission_intensity_EV))))

            ###############computational part of co-benefits#####################
            # 2030 emission value from the provided array ###############20300 means the average population of the each municipality is taken into account
            Car_emission_per_emission = car_values[-1] - car_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            car_per_km_emission= Car_emission_per_km/Car_emission_per_emission ########unit is value/kms
            caremission_per_km = 1/car_per_km_emission ###unit is kms
            Total_cb_ts_cars = (caremission_per_km * Cobenefits_ts_cars)* pop.loc[str(mun), 20300]

            bus_emission_per_emission = bus_values[-1] - bus_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            bus_per_km_emission= bus_emission_per_km/bus_emission_per_emission ########unit is value/kms
            busemission_per_km = 1/bus_per_km_emission ###unit is kms
            Total_cb_ts_buses = (busemission_per_km * Cobenefits_ts_buses)* pop.loc[str(mun), 20300]

            ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
            htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
            Total_cb_ts_ht = (htemission_per_km * Cobenefits_ts_ht)* pop.loc[str(mun), 20300]

            lt_emission_per_emission =  light_truck_values[-1] -  light_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
            ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
            Total_cb_ts_lt = (ltemission_per_km * Cobenefits_ts_lt)* pop.loc[str(mun), 20300]

            transport_cp_ts = -(Total_cb_ts_cars + Total_cb_ts_buses + Total_cb_ts_ht + Total_cb_ts_lt)

            # Given total costs for each sector
            sectors = {
                'Agriculture': 0,
                'Transport': transport_cp_ts,
                'Waste': 0,
                'Foreign Transport': 0,
                'Work Machines': 0,
                'Electric DH': 0,
                'Own Heating': 0,
                'Product Use': 0,
                'Industry': 0
            }

            # Actors and their share
            actors_share = {
                'Total':1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share


            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Municipality - Cumulative Co-benefits of improved traffic safety in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Municipality - Cumulative co-benefits of improved traffic safety 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df

    elif scenario == "Scenario 2 - Pessimistic Scenario" and emissions_output == "Municipality emissions" and ci_dropdown == 'Improved physical health':
            ##################################Co-impacts###################################################################
            growth_perc2030 = 1
            growth_perc2019 = 1

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)

            car_values = np.full(num_years, cars_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment

            # Apply the levers
            for i in range(num_years):
                current_year = 2021 + i
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0

                # Calculate the values for each type of transport
                car_values[i] *= (1 - ((act_trans_value))) #####refernce available only for electric cars

            ###############computational part of co-benefits#####################
            # 2030 emission value from the provided array ###############20300 means the average population of the each municipality is taken into account
            Car_emission_per_emission = car_values[-1] - car_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            car_per_km_emission= Car_emission_per_km/Car_emission_per_emission ########unit is value/kms
            caremission_per_km = 1/car_per_km_emission ###unit is kms
            Total_cb_at_cars = (caremission_per_km * Cobenefits_at_cars)* pop.loc[str(mun), 20300]

            transport_cp_at = -Total_cb_at_cars

            # Given total costs for each sector
            sectors = {
                'Agriculture': 0,
                'Transport': transport_cp_at,
                'Waste': 0,
                'Foreign Transport': 0,
                'Work Machines': 0,
                'Electric DH': 0,
                'Own Heating': 0,
                'Product Use': 0,
                'Industry': 0
            }

            # Actors and their share
            actors_share = {
                'Total':1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share


            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Municipality - Cumulative Co-benefits of improved physical health (active transport) in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Municipality - Cumulative co-benefits of improved physical health 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df
    elif scenario == "Scenario 2 - Pessimistic Scenario" and emissions_output == "Municipality emissions" and ci_dropdown == 'Total':
        ##################################Co-impacts###################################################################

        ########################Air quality ###################################
        agr_emission_2030 = agriculture_population_values1[-1] - agriculture_population_values1[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        agr_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = agr_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            agr_total_cost += (-cost)

        # 2030 emission value from the provided array
        trans_emission_2030 = transport_population_values1[-1] - transport_population_values1[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        trans_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = trans_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            trans_total_cost += (-cost)

        # 2030 emission value from the provided array
        waste_emission_2030 = waste_population_values1[-1] - waste_population_values1[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        waste_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = waste_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            waste_total_cost += (-cost)

        # 2030 emission value from the provided array
        ft_emission_2030 = foreign_transport_population_values1[-1] - foreign_transport_population_values1[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        ft_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = ft_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            ft_total_cost += (-cost)

        # 2030 emission value from the provided array
        wm_emission_2030 = work_machines_population_values1[-1] - work_machines_population_values1[
            0]  # Last value in the array

        # Calculate reduced emissions and total cost
        wm_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = wm_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            wm_total_cost += (-cost)

        # 2030 emission value from the provided array
        el_emission_2030 = el_dh_population_values1[-1] - el_dh_population_values1[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        el_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = el_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            el_total_cost += (-cost)

        # 2030 emission value from the provided array
        oh_emission_2030 = own_heating_population_values1[-1] - own_heating_population_values1[
            0]  # Last value in the array

        # Calculate reduced emissions and total cost
        oh_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = oh_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            oh_total_cost += (-cost)

        # 2030 emission value from the provided array
        pu_emission_2030 = product_use_population_values1[-1] - product_use_population_values1[
            0]  # Last value in the array

        # Calculate reduced emissions and total cost
        pu_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = pu_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            pu_total_cost += (-cost)

        # 2030 emission value from the provided array
        ind_emission_2030 = industry_population_values1[-1] - industry_population_values1[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        ind_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = ind_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            ind_total_cost += (-cost)

        ###########################Noise pollution ############################

        growth_perc2030 = 1
        # Initialize the number of years in the simulation
        num_years = 2030 - 2021 + 1

        # Calculate the annual growth increment for each type of transport
        car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
        bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
        heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
        light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
        air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
        other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)

        car_values = np.full(num_years, cars_2019)
        bus_values = np.full(num_years, buses_2019)
        heavy_truck_values = np.full(num_years, heavy_trucks_2019)
        light_truck_values = np.full(num_years, light_trucks_2019)
        air_transport_values = np.full(num_years, air_transport_2019)
        other_transport_values = np.full(num_years, other_transport_2019)

        # Apply the linear growth from 2019 to 2030
        for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
            car_values[i] = car_values[i - 1] + car_growth_increment
            bus_values[i] = bus_values[i - 1] + bus_growth_increment
            heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
            light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
            air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
            other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment

        # Apply the levers
        for i in range(num_years):
            current_year = 2021 + i
            pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (
                        2030 - RC_year) if current_year >= RC_year else 0
            act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (
                        2030 - AT_year) if current_year >= AT_year else 0
            el_car_value = ((el_car / 100) * (current_year - start_year)) / (
                        2030 - start_year) if current_year >= start_year else 0
            el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (
                        2030 - start_year) if current_year >= start_year else 00
            electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (
                        2030 - start_year) if current_year >= start_year else 0
            electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (
                        2030 - start_year) if current_year >= start_year else 0

            # Calculate the values for each type of transport
            car_values[i] *= (1 - ((pt_car_value + act_trans_value + (el_car_value * caremission_intensity_EV))))  #####refernce available only for electric cars
            bus_values[i] *= (1 - ((el_bus_value * busemission_intensity_EV)))
            heavy_truck_values[i] *= (1 - (((electric_heavy_value * HT_emission_intensity_EV))))
            light_truck_values[i] *= (1 - (((electric_light_value * LT_emission_intensity_EV))))

        ###############computational part of co-benefits#####################
        # 2030 emission value from the provided array
        Car_emission_per_emission = car_values[-1] - car_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        car_per_km_emission = Car_emission_per_km / Car_emission_per_emission  ########unit is value/kms
        caremission_per_km = 1 / car_per_km_emission  ###unit is kms
        Total_cb_np_cars = (caremission_per_km * Cobenefits_np_cars)* pop.loc[str(mun), 20300]

        bus_emission_per_emission = bus_values[-1] - bus_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        bus_per_km_emission = bus_emission_per_km / bus_emission_per_emission  ########unit is value/kms
        busemission_per_km = 1 / bus_per_km_emission  ###unit is kms
        Total_cb_np_buses = (busemission_per_km * Cobenefits_np_buses)* pop.loc[str(mun), 20300]

        ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
        htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
        Total_cb_np_ht = (htemission_per_km * Cobenefits_np_ht)* pop.loc[str(mun), 20300]

        lt_emission_per_emission = light_truck_values[-1] - light_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
        ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
        Total_cb_np_lt = (ltemission_per_km * Cobenefits_np_lt)* pop.loc[str(mun), 20300]

        transport_cp_np = -(Total_cb_np_cars + Total_cb_np_buses + Total_cb_np_ht + Total_cb_np_lt)

        #######################Traffic safety##################

        ###############computational part of co-benefits#####################
        # 2030 emission value from the provided array
        Car_emission_per_emission = car_values[-1] - car_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        car_per_km_emission = Car_emission_per_km / Car_emission_per_emission  ########unit is value/kms
        caremission_per_km = 1 / car_per_km_emission  ###unit is kms
        Total_cb_ts_cars = (caremission_per_km * Cobenefits_ts_cars)* pop.loc[str(mun), 20300]

        bus_emission_per_emission = bus_values[-1] - bus_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        bus_per_km_emission = bus_emission_per_km / bus_emission_per_emission  ########unit is value/kms
        busemission_per_km = 1 / bus_per_km_emission  ###unit is kms
        Total_cb_ts_buses = (busemission_per_km * Cobenefits_ts_buses)* pop.loc[str(mun), 20300]

        ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
        htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
        Total_cb_ts_ht = (htemission_per_km * Cobenefits_ts_ht)* pop.loc[str(mun), 20300]

        lt_emission_per_emission = light_truck_values[-1] - light_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
        ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
        Total_cb_ts_lt = (ltemission_per_km * Cobenefits_ts_lt)* pop.loc[str(mun), 20300]

        transport_cp_ts = -(Total_cb_ts_cars + Total_cb_ts_buses + Total_cb_ts_ht + Total_cb_ts_lt)

        #############Improved physical health ##############

        # Initialize the number of years in the simulation
        num_years = 2030 - 2021 + 1

        # Calculate the annual growth increment for each type of transport
        car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)

        car_values = np.full(num_years, cars_2019)

        # Apply the linear growth from 2019 to 2030
        for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
            car_values[i] = car_values[i - 1] + car_growth_increment

        # Apply the levers
        for i in range(num_years):
            current_year = 2021 + i
            act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0

            # Calculate the values for each type of transport
            car_values[i] *= (1 - ((act_trans_value)))  #####refernce available only for electric cars

        ###############computational part of co-benefits#####################
        # 2030 emission value from the provided array
        Car_emission_per_emission = car_values[-1] - car_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        car_per_km_emission = Car_emission_per_km / Car_emission_per_emission  ########unit is value/kms
        caremission_per_km = 1 / car_per_km_emission  ###unit is kms
        Total_cb_at_cars = (caremission_per_km * Cobenefits_at_cars)* pop.loc[str(mun), 20300]

        transport_cp_at = -Total_cb_at_cars

        Transport = trans_total_cost + transport_cp_at + transport_cp_np + transport_cp_ts

        # Given total costs for each sector
        sectors = {
            'Agriculture': agr_total_cost,
            'Transport': Transport,
            'Waste': waste_total_cost,
            'Foreign Transport': ft_total_cost,
            'Work Machines': wm_total_cost,
            'Electric DH': el_total_cost,
            'Own Heating': oh_total_cost,
            'Product Use': pu_total_cost,
            'Industry': ind_total_cost
        }

        # Actors and their share
        actors_share = {
            'Total': 1,
            'Citizens': 0.4,
            'Civil soceity': 0,
            'Financial institutions': 0,
            'Industry': 0,
            'Municipal governments': 0.6,
            'Superordinate governments': 0,
            'Utility companies': 0

        }

        # Determine the share of each actor
        actors_values = {}
        for actor, share in actors_share.items():
            for sector, cost in sectors.items():
                if sector not in actors_values:
                    actors_values[sector] = {}
                actors_values[sector][actor] = cost * share

        # Define color mapping for sectors
        sector_colors = {
            'Agriculture': "#ef553b",
            'Waste': "#FECB52",
            'Transport': "#e377c2",
            'Foreign Transport': '#AB63FA',
            'Work Machines': '#FFA15A',
            'Electric DH': "#9467bd",
            'Own Heating': "#ff7f0e",
            'Product Use': '#B6E880',
            'Industry': "#1f77b4"
        }

        # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
        fig_ci = go.Figure()

        for sector in sectors.keys():
            fig_ci.add_trace(go.Bar(
                x=list(actors_share.keys()),
                y=[actors_values[sector][actor] for actor in actors_share.keys()],
                name=sector,
                marker_color=sector_colors[sector]
            ))

        fig_ci.update_layout(
            barmode='stack',
            margin=dict(l=40, r=20, b=10, t=60),
            autosize=True,
            title_text="Municipality - Total Cumulative Co-benefits in {} (SEK) - 2030".format(mun),
            title_font=dict(size=18, color="darkred"),
            xaxis_title="Actors",
            yaxis_title="SEK",
            yaxis=dict(
                showgrid=True,
                gridcolor='lightgray',
                gridwidth=0.5
            )
        )

        def create_dataframe(sectors, actors_share, actors_values):
            unique_sectors = list(sectors.keys())
            unique_actors = list(actors_share.keys())

            # Constructing a Data Dictionary
            data_exp = {"Sectors": unique_sectors}
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    actor_values.append(actors_values[sector].get(actor, 0))
                data_exp[actor] = actor_values

            # Converting Dictionary to DataFrame
            df = pd.DataFrame.from_dict(data_exp)

            # Reordering the DataFrame Columns
            df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

            # Inserting a new row at the beginning
            new_row = ["Municipality - Total Cumulative co-benefits 2030"] + [""] * (len(df.columns) - 1)
            df.loc[-1] = new_row  # adding a row
            df.index = df.index + 1  # shifting index
            df = df.sort_index()  # sorting by index

            # Return the serialized DataFrame
            return df.to_dict(orient='records')

        df = create_dataframe(sectors, actors_share, actors_values)

        fig_ci_output = fig_ci
        data_ci_output = df

    elif scenario == "Scenario 3 - Optimistic Scenario" and emissions_output == 'Per capita emissions':
            start_year = 2021
            end_year = 2030
            num_years = end_year - start_year + 1
         
        
            growth_perc2030= 0.94
            growth_perc2019 = 1
        
            growth_rate_per_year = (growth_perc2030-growth_perc2019)/(end_year-start_year)
        
            transport_values1 = [transport_2019]

            # Calculate the annual growth increment required to achieve the target growth
            annual_growth_increment = (growth_perc2030 * transport_2019 - transport_2019) / (num_years - 1)
            
            # Calculate the transport values for the years 2019 to 2030
            for i in range(num_years - 1):
                interpolated_value = transport_values1[-1] + annual_growth_increment
                transport_values1.append(interpolated_value)
        
            # Repeat the above code for other variables
        
            industry_values1 = [industry_2019]

            # Calculate the annual growth increment required to achieve the target growth
            annual_growth_increment = (growth_perc2030 * industry_2019 - industry_2019) / (num_years - 1)
            
            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = industry_values1[-1] + annual_growth_increment
                industry_values1.append(next_value)                   
                            
            agriculture_values1 = [agriculture_2019]
            
            # Calculate the annual growth increment required to achieve the target growth
            annual_growth_increment = (growth_perc2030 * agriculture_2019 - agriculture_2019) / (num_years - 1)
            
            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = agriculture_values1[-1] + annual_growth_increment
                agriculture_values1.append(next_value)
                
                
            el_dh_values1 = [el_dh_2019]
    
            # Calculate the annual growth increment required to achieve the target growth
            annual_growth_increment = (growth_perc2030 * el_dh_2019 - el_dh_2019) / (num_years - 1)
            
            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = el_dh_values1[-1] + annual_growth_increment
                el_dh_values1.append(next_value)
                
    
            own_heating_values1 = [own_heating_2019]
            # Calculate the annual growth increment required to achieve the target growth
            annual_growth_increment = (growth_perc2030 * own_heating_2019 - own_heating_2019) / (num_years - 1)
            
            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = own_heating_values1[-1] + annual_growth_increment
                own_heating_values1.append(next_value)
    
            work_machines_values1 = [work_machines_2019]
            annual_growth_increment = (growth_perc2030 * work_machines_2019 - work_machines_2019) / (num_years - 1)
            
            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = work_machines_values1[-1] + annual_growth_increment
                work_machines_values1.append(next_value)
                
            
            product_use_values1 = [product_use_2019]
            annual_growth_increment = (growth_perc2030 * product_use_2019 - product_use_2019) / (num_years - 1)
            
            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = product_use_values1[-1] + annual_growth_increment
                product_use_values1.append(next_value)
                
    
            waste_values1 = [waste_2019]
            annual_growth_increment = (growth_perc2030 * waste_2019 - waste_2019) / (num_years - 1)
            
            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = waste_values1[-1] + annual_growth_increment
                waste_values1.append(next_value)
    
            foreign_transport_values1 = [foreign_transport_2019]
            annual_growth_increment = (growth_perc2030 * foreign_transport_2019 - foreign_transport_2019) / (num_years - 1)
            
            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = foreign_transport_values1[-1] + annual_growth_increment
                foreign_transport_values1.append(next_value)
                
            Negatives_values1 = [Negatives_2019]
            for i in range(num_years - 1):
                interpolated_value = Negatives_values1[-1] * (1 + (1-1)/(end_year-start_year))
                Negatives_values1.append(interpolated_value)
               
                ################Lever###########################
           
            ## transportLevers    
            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
            bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
            heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
            light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
            air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
            other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)

            # Initialize the lists for each type of transport
            car_values = np.full(num_years, cars_2019)
            bus_values = np.full(num_years, buses_2019)
            heavy_truck_values = np.full(num_years, heavy_trucks_2019)
            light_truck_values = np.full(num_years, light_trucks_2019)
            air_transport_values = np.full(num_years, air_transport_2019)
            other_transport_values = np.full(num_years, other_transport_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment
                bus_values[i] = bus_values[i - 1] + bus_growth_increment
                heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
                light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
                air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
                other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                current_year = 2021 + i

                # Calculate lever values for the current year
                pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (2030 - RC_year) if current_year >= RC_year else 0
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0
                el_car_value = ((el_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                ph_car_value = ((ph_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                hydr_car_value = ((hydr_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                ren_bus_value = ((ren_bus / 100) * (current_year - RENB_year)) / (2030 - RENB_year) if current_year >= RENB_year else 0
                el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                LBG_heavy_value = ((LBG_heavy / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                LBG_light_value = ((LBG_light / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                air_transp_value = ((air_transp / 100) * (current_year - AIT_year)) / (2030 - AIT_year) if current_year >= AIT_year else 0

                # Apply the lever effects
                car_values[i] *= (1 - ((pt_car_value + act_trans_value + el_car_value * caremission_intensity_EV + ph_car_value * caremission_intensity_PIH + hydr_car_value * caremission_intensity_Hydrogen)))
                bus_values[i] *= (1 - ((ren_bus_value * busemission_intensity_ren + el_bus_value * busemission_intensity_EV)))
                heavy_truck_values[i] *= (1 - ((LBG_heavy_value * HT_emission_intensity_LBG + electric_heavy_value * HT_emission_intensity_EV)))
                light_truck_values[i] *= (1 - ((LBG_light_value * LT_emission_intensity_LBG + electric_light_value * LT_emission_intensity_EV)))
                air_transport_values[i] *= (1 - air_transp_value)
                other_transport_values[i] *= (1 - (pt_car_value + act_trans_value))

            # The total emissions are the sum of all types of transport
            transport_values = car_values + bus_values + heavy_truck_values + light_truck_values + air_transport_values + other_transport_values
     # industryLevers

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for the industry
            industry_growth_increment = ((growth_perc2030 - 1) * industry_2019) / (num_years - 1)

            # Initialize the list for the industry values
            industry_values = np.full(num_years, industry_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                industry_values[i] = industry_values[i - 1] + industry_growth_increment

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                current_year = 2021 + i

                # Calculate lever values for the current year
                ccs_value = ((CCS_industry / 100) * (current_year - ccs_year)) / (2030 - ccs_year) if current_year >= ccs_year else 0
                Hyd_value = ((H2_industry / 100) * (current_year - Hyd_year)) / (2030 - Hyd_year) if current_year >= Hyd_year else 0

                # Apply the lever effects
                industry_values[i] *= (1 - ((ccs_value * ccs_emission_intensity) + (Hyd_value * hyd_emission_intensity)))

            # The total emissions are in industry_values
            Industry_total_values = industry_values

            ## agricultureLevers
            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment
            annual_growth_increment = ((growth_perc2030 - 1) * agriculture_2019) / (num_years - 1)

            # Initialize the list for the agriculture values
            agriculture_values = np.full(num_years, agriculture_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                agriculture_values[i] = agriculture_values[i - 1] + annual_growth_increment  # Linear growth

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i  # Current year in the simulation

                agr_value = ((agr / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Apply the lever effect
                agriculture_values[i] *= (1 - ((agr_value) * agr_emission_intensity))


            ## el_dhLevers
            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for el_dh
            annual_growth_increment = ((growth_perc2030 - 1) * el_dh_2019) / (num_years - 1)

            # Initialize the list for the el_dh values
            el_dh_values = np.full(num_years, el_dh_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                el_dh_values[i] = el_dh_values[i - 1] + annual_growth_increment

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i

                # Calculate lever effects
                wind_value = ((wind / 100) * (current_year - W_year)) / ( 2030 - W_year) if current_year >= W_year else 0
                rtsolar_value = ((rtsolar / 100) * (current_year - RS_year)) / ( 2030 - RS_year) if current_year >= RS_year else 0
                csolar_value = ((csolar / 100) * (current_year - CS_year)) / (2030 - CS_year) if current_year >= CS_year else 0
                DH_heatpumps_value = ((DH_heatpumps / 100) * (current_year -DHP_year)) / (2030 - DHP_year) if current_year >= DHP_year else 0
                ccsw_value = ((ccsw / 100) * (current_year - CCSW_year)) / (2030 - CCSW_year) if current_year >= CCSW_year else 0
                ind_temp_red_value = ((ind_temp_red / 100) * (current_year -start_year)) / (2030 - start_year) if current_year >= start_year else 0
                sn_measure_value = ((sn_measure/ 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                BAT_appl_value = ((BAT_appl / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0


                el_dh_values[i] *= (((1 - ((BAT_appl_value * BAT_energy_consumption_impact) + (ind_temp_red_value* Ind_temp_impact)  + (
                sn_measure_value* SN_eff_impact))) * ((1 - ( (Share_elec_DH) * (((wind_value* Wind_emissions_intensity)) + ((rtsolar_value* Solar_emission_intensity)) + (
                    (csolar_value) * Solar_emission_intensity)) + ((1 - Share_elec_DH) * (DH_heatpumps_value) * (((Share_DH_HP_air * emission_savings_air) + (Share_DH_HP_water * emission_savings_water) + (
                Share_DH_HP_GT * emission_savings_GT)))))))) * (1 -((ccsw_value) * ccsw_emission_intensity)))

            ## own_heatingLevers
            own_heating_growth_2030 = own_heating*growth_perc2030
            own_heating_growth_2019 = own_heating_2019
            own_heating_values = [own_heating_growth_2019]

            num_years = 2030 - 2021

            for i in range(num_years):
                growth_rate_per_year = (own_heating_growth_2030 - own_heating_growth_2019) / num_years
                interpolated_value = own_heating_values[-1] + growth_rate_per_year
                own_heating_values.append(interpolated_value)

            ## work_machinesLevers

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment
            annual_growth_increment = ((growth_perc2030 - 1) * work_machines_2019) / (num_years - 1)

            # Initialize the list for the work_machines values
            work_machines_values = np.full(num_years, work_machines_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                work_machines_values[i] = work_machines_values[i - 1] + annual_growth_increment  # Linear growth

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i  # Current year in the simulation

                wm_value = ((wm / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Apply the lever effect
                work_machines_values[i] *= (1 - ((wm_value)))

            ## product_useLevers
            product_use_growth_2030 = product_use*growth_perc2030
            product_use_growth_2019 = product_use_2019
            product_use_values = [product_use_growth_2019]

            num_years = 2030 - 2021

            for i in range(num_years):
                growth_rate_per_year = (product_use_growth_2030 - product_use_growth_2019) / num_years
                interpolated_value = product_use_values[-1] + growth_rate_per_year
                product_use_values.append(interpolated_value)

            ## wasteLevers
            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for the industry
            annual_growth_increment = ((growth_perc2030 - 1) * waste_2019) / (num_years - 1)

            # Initialize the list for the waste values
            waste_values = np.full(num_years, waste_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                waste_values[i] = waste_values[i - 1] + annual_growth_increment

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i

                cmu_value = ((cmu / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Apply the lever effect
                waste_values[i] *= (1 - (cmu_value * Share_landfill_samecity))

            ## foreign_transportLevers
            foreign_transport_growth_2030 = foreign_transport*growth_perc2030
            foreign_transport_growth_2019 = foreign_transport_2019
            foreign_transport_values = [foreign_transport_growth_2019]

            num_years = 2030 - 2021

            for i in range(num_years):
                growth_rate_per_year = (foreign_transport_growth_2030 - foreign_transport_growth_2019) / num_years
                interpolated_value = foreign_transport_values[-1] + growth_rate_per_year
                foreign_transport_values.append(interpolated_value)

            ## NegativesLevers
            Negatives_growth_2030 = Negatives*1
            Negatives_growth_2019 = Negatives_2019
            Negatives_values = [Negatives_growth_2019]

            num_years = end_year - start_year + 1  # Add 1 to include the end year
            Negatives_values = [Negatives_growth_2019] * num_years

            # Sort the levers by start year
            levers = sorted([(Bioccs_year, bio_ccs), (RW_year, rewetting_emissions), (CC_year, carbon_credit)])

            # Apply the levers
            for lever_start_year, lever_percentage in levers:
                # Calculate the total change based on the lever
                total_change = (Negatives_growth_2030 - Negatives_growth_2019) * lever_percentage / 100

                # Calculate the yearly change
                yearly_change = total_change / (end_year - (lever_start_year + 1) + 1)

                # Apply the yearly change to each year from the year after the start of the lever
                for i in range(lever_start_year - start_year + 1, num_years):
                    Negatives_values[i] += yearly_change * (i - (lever_start_year - start_year + 1) + 1)

                
                years = list(range(2021, 2031))
                # Create a color scale for the categories
                color_scale = ["#ef553b", "#FECB52", "#e377c2", '#AB63FA', '#FFA15A', "#9467bd",
                               "#ff7f0e", '#B6E880', "#1f77b4", "#d62728"]
    
            categories = ["Agriculture","Waste","Transport", "Foreign transport", "Work machinery", "Electricity and DH",
                   "Own heating","Product use","Industry", "Negatives"]
            values1 = [agriculture_values1, waste_values1, transport_values1, foreign_transport_values1,
                       work_machines_values1, el_dh_values1, own_heating_values1, product_use_values1, industry_values1, Negatives_values1]
            values2 = [agriculture_values,  waste_values, transport_values, foreign_transport_values,
                       work_machines_values, el_dh_values, own_heating_values, product_use_values, industry_values, Negatives_values]
            
          
            # Create a figure with two subplots, each containing a stacked bar chart
            fig = make_subplots(rows=2, cols=1, subplot_titles=("Forecasted emissions 2030: {} Kg".format(round(scenario3total_2030)), "Emissions after climate action 2030: {} Kg".format(round(EAC3_2030))), shared_xaxes=False, shared_yaxes=False)

            # Categories to display on the positive side
            positive_categories = ["Agriculture", "Waste", "Transport", "Foreign transport", "Work machinery", "Electricity and DH", "Own heating", "Product use", "Industry"]
            
            # Plot stacked bar chart for BAU Scenario
            for i in range(len(categories)):
                if categories[i] in positive_categories:
                    fig.add_trace(
                        go.Bar(x=years, y=values1[i], name=categories[i], hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=1, col=1
                    )
                else:
                    fig.add_trace(
                        go.Bar(x=years, y=[-val for val in values1[i]], name=categories[i], hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=1, col=1
                    )
            
            # Plot stacked bar chart for Scenario
            for i in range(len(categories)):
                if categories[i] in positive_categories:
                    fig.add_trace(
                        go.Bar(x=years, y=values2[i], showlegend=False, hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=2, col=1
                    )
                else:
                    fig.add_trace(
                        go.Bar(x=years, y=[-val for val in values2[i]], showlegend=False, hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=2, col=1
                    )
                    
            # Compute the net emissions for each year
            netzero_emissions_values = []
            for year in range(len(years)):
                positive_sum = sum(values2[i][year] for i in range(len(categories)) if categories[i] in positive_categories)
                negative_sum = sum(values2[i][year] for i in range(len(categories)) if categories[i] not in positive_categories)
                netzero_emissions_values.append(positive_sum - negative_sum)
                    
            # Plot line chart for Netzero emissions
            fig.add_trace(
                go.Scatter(x=years, y=netzero_emissions_values, name="Net emissions", mode='lines', hovertemplate="Variable: Net emissions<br>Value: %{y}<extra></extra>", marker=dict(color='#000080'), line=dict(width=3)),
                row=2, col=1
            )
            
            # Add labels and titles
            fig.update_layout(
                barmode="relative",
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Emissions profile in {} (Kg of CO2-eq)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='Kg of CO2-eq',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                    #tickformat=".0f",  # Format tick labels as decimal numbers
                    #ticksuffix=" Kg"  # Add "Kg" suffix to tick labels
                ),
                height=800
            )
            
            # Automatically determine the y-axis range for both charts based on the data
            fig.update_yaxes(row=1, col=1, autorange=True)
            fig.update_yaxes(row=2, col=1, autorange=True)
            
            # Update x-axis labels and tick values for both charts
            fig.update_xaxes(title_text="Years", ticktext=[str(year) for year in years], tickvals=years, row=1, col=1)
            fig.update_xaxes(title_text="Years", ticktext=[str(year) for year in years], tickvals=years, row=2, col=1)
            
            # Update y-axis label for the second chart
            fig.update_yaxes(title_text="Kg of CO2-eq", row=2, col=1)
            
            # Update y-axis label for the second chart
            fig.update_yaxes(title_text="Kg of CO2-eq", row=2, col=1)
        
            data_exp = {
            "Sectors": categories,
            "Input1": values1,
            "Input2": values2}

            fig_output = fig
            data_em_output = pd.DataFrame.from_dict(data_exp, orient='index').to_dict('records')


    if scenario == "Scenario 3 - Optimistic Scenario" and emissions_output == "Per capita emissions" and ci_dropdown == 'Improved air quality':
            ##################################Co-impacts###################################################################

            # 2030 emission value from the provided array
            agr_emission_2030 = agriculture_values[-1] - agriculture_values[0] # Last value in the array

            # Calculate reduced emissions and total cost
            agr_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = agr_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                agr_total_cost += (-cost)

            # 2030 emission value from the provided array
            trans_emission_2030 = transport_values[-1] - transport_values[0]# Last value in the array

            # Calculate reduced emissions and total cost
            trans_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = trans_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                trans_total_cost += (-cost)

            # 2030 emission value from the provided array
            waste_emission_2030 = waste_values[-1] - waste_values[0]   # Last value in the array

            # Calculate reduced emissions and total cost
            waste_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = waste_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                waste_total_cost += (-cost)

            # 2030 emission value from the provided array
            ft_emission_2030 = foreign_transport_values[-1] - foreign_transport_values[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            ft_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = ft_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                ft_total_cost += (-cost)

            # 2030 emission value from the provided array
            wm_emission_2030 = work_machines_values[-1] - work_machines_values[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            wm_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = wm_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                wm_total_cost += (-cost)

            # 2030 emission value from the provided array
            el_emission_2030 = el_dh_values[-1] - el_dh_values[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            el_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = el_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                el_total_cost += (-cost)

            # 2030 emission value from the provided array
            oh_emission_2030 = own_heating_values[-1] - own_heating_values[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            oh_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = oh_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                oh_total_cost += (-cost)

            # 2030 emission value from the provided array
            pu_emission_2030 = product_use_values[-1] - product_use_values[0] # Last value in the array

            # Calculate reduced emissions and total cost
            pu_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = pu_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                pu_total_cost += (-cost)

            # 2030 emission value from the provided array
            ind_emission_2030 = industry_values[-1] - industry_values[0] # Last value in the array

            # Calculate reduced emissions and total cost
            ind_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = ind_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                ind_total_cost += (-cost)


            # Given total costs for each sector
            sectors = {
                'Agriculture': agr_total_cost,
                'Transport': trans_total_cost,
                'Waste': waste_total_cost,
                'Foreign Transport': ft_total_cost,
                'Work Machines': wm_total_cost,
                'Electric DH': el_total_cost,
                'Own Heating': oh_total_cost,
                'Product Use': pu_total_cost,
                'Industry': ind_total_cost
            }

            # Actors and their share
            actors_share = {
                'Total':1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share


            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Per Capita - Cumulative Co-benefits of improved air quality in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Per capita - Cumulative co-benefits of improved air quality 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df

    elif scenario == "Scenario 3 - Optimistic Scenario" and emissions_output == "Per capita emissions" and ci_dropdown == 'Reduced noise pollution':
            ##################################Co-impacts###################################################################
            growth_perc2030 = 1
            growth_perc2019 = 1

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
            bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
            heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
            light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
            air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
            other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)

            car_values = np.full(num_years, cars_2019)
            bus_values = np.full(num_years, buses_2019)
            heavy_truck_values = np.full(num_years, heavy_trucks_2019)
            light_truck_values = np.full(num_years, light_trucks_2019)
            air_transport_values = np.full(num_years, air_transport_2019)
            other_transport_values = np.full(num_years, other_transport_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment
                bus_values[i] = bus_values[i - 1] + bus_growth_increment
                heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
                light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
                air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
                other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment

            # Apply the levers
            for i in range(num_years):
                current_year = 2021 + i
                pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (2030 - RC_year) if current_year >= RC_year else 0
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0
                el_car_value = ((el_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 00
                electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Calculate the values for each type of transport
                car_values[i] *= (1 - ((pt_car_value + act_trans_value + (el_car_value * caremission_intensity_EV)))) #####refernce available only for electric cars
                bus_values[i] *= (1 - ((el_bus_value * busemission_intensity_EV)))
                heavy_truck_values[i] *= (1 - (((electric_heavy_value * HT_emission_intensity_EV))))
                light_truck_values[i] *= (1 - (((electric_light_value * LT_emission_intensity_EV))))

            ###############computational part of co-benefits#####################
            # 2030 emission value from the provided array
            Car_emission_per_emission = car_values[-1] - car_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            car_per_km_emission= Car_emission_per_km/Car_emission_per_emission ########unit is value/kms
            caremission_per_km = 1/car_per_km_emission ###unit is kms
            Total_cb_np_cars = caremission_per_km * Cobenefits_np_cars

            bus_emission_per_emission = bus_values[-1] - bus_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            bus_per_km_emission= bus_emission_per_km/bus_emission_per_emission ########unit is value/kms
            busemission_per_km = 1/bus_per_km_emission ###unit is kms
            Total_cb_np_buses = busemission_per_km * Cobenefits_np_buses

            ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
            htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
            Total_cb_np_ht = htemission_per_km * Cobenefits_np_ht

            lt_emission_per_emission =  light_truck_values[-1] -  light_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
            ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
            Total_cb_np_lt = ltemission_per_km * Cobenefits_np_lt

            transport_cp_np = -(Total_cb_np_cars + Total_cb_np_buses + Total_cb_np_ht + Total_cb_np_lt)

            # Given total costs for each sector
            sectors = {
                'Agriculture': 0,
                'Transport': transport_cp_np,
                'Waste': 0,
                'Foreign Transport': 0,
                'Work Machines': 0,
                'Electric DH': 0,
                'Own Heating': 0,
                'Product Use': 0,
                'Industry': 0
            }

            # Actors and their share
            actors_share = {
                'Total':1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share


            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Per Capita - Cumulative Co-benefits of reduced noise pollution in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Per capita - Cumulative co-benefits of reduced noise pollution 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df

    elif scenario == "Scenario 3 - Optimistic Scenario" and emissions_output == "Per capita emissions" and ci_dropdown == 'Improved traffic safety':
            ##################################Co-impacts###################################################################

            growth_perc2030 = 1
            growth_perc2019 = 1

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
            bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
            heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
            light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
            air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
            other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)

            car_values = np.full(num_years, cars_2019)
            bus_values = np.full(num_years, buses_2019)
            heavy_truck_values = np.full(num_years, heavy_trucks_2019)
            light_truck_values = np.full(num_years, light_trucks_2019)
            air_transport_values = np.full(num_years, air_transport_2019)
            other_transport_values = np.full(num_years, other_transport_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment
                bus_values[i] = bus_values[i - 1] + bus_growth_increment
                heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
                light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
                air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
                other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment

            # Apply the levers
            for i in range(num_years):
                current_year = 2021 + i
                pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (2030 - RC_year) if current_year >= RC_year else 0
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0
                el_car_value = ((el_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 00
                electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Calculate the values for each type of transport
                car_values[i] *= (1 - ((pt_car_value + act_trans_value + (el_car_value * caremission_intensity_EV)))) #####refernce available only for electric cars
                bus_values[i] *= (1 - ((el_bus_value * busemission_intensity_EV)))
                heavy_truck_values[i] *= (1 - (((electric_heavy_value * HT_emission_intensity_EV))))
                light_truck_values[i] *= (1 - (((electric_light_value * LT_emission_intensity_EV))))

            ###############computational part of co-benefits#####################
            # 2030 emission value from the provided array
            Car_emission_per_emission = car_values[-1] - car_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            car_per_km_emission= Car_emission_per_km/Car_emission_per_emission ########unit is value/kms
            caremission_per_km = 1/car_per_km_emission ###unit is kms
            Total_cb_ts_cars = caremission_per_km * Cobenefits_ts_cars

            bus_emission_per_emission = bus_values[-1] - bus_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            bus_per_km_emission= bus_emission_per_km/bus_emission_per_emission ########unit is value/kms
            busemission_per_km = 1/bus_per_km_emission ###unit is kms
            Total_cb_ts_buses = busemission_per_km * Cobenefits_ts_buses

            ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
            htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
            Total_cb_ts_ht = htemission_per_km * Cobenefits_ts_ht

            lt_emission_per_emission =  light_truck_values[-1] -  light_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
            ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
            Total_cb_ts_lt = ltemission_per_km * Cobenefits_ts_lt

            transport_cp_ts = -(Total_cb_ts_cars + Total_cb_ts_buses + Total_cb_ts_ht + Total_cb_ts_lt)

            # Given total costs for each sector
            sectors = {
                'Agriculture': 0,
                'Transport': transport_cp_ts,
                'Waste': 0,
                'Foreign Transport': 0,
                'Work Machines': 0,
                'Electric DH': 0,
                'Own Heating': 0,
                'Product Use': 0,
                'Industry': 0
            }

            # Actors and their share
            actors_share = {
                'Total':1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share


            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Per Capita - Cummulative Co-benefits of improved traffic safety in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Per capita - Cumulative co-benefits of improved traffic safety 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df

    elif scenario == "Scenario 3 - Optimistic Scenario" and emissions_output == "Per capita emissions" and ci_dropdown == 'Improved physical health':
            ##################################Co-impacts###################################################################

            growth_perc2030 = 1
            growth_perc2019 = 1

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)

            car_values = np.full(num_years, cars_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment

            # Apply the levers
            for i in range(num_years):
                current_year = 2021 + i
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0

                # Calculate the values for each type of transport
                car_values[i] *= (1 - ((act_trans_value))) #####refernce available only for electric cars

            ###############computational part of co-benefits#####################
            # 2030 emission value from the provided array
            Car_emission_per_emission = car_values[-1] - car_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            car_per_km_emission= Car_emission_per_km/Car_emission_per_emission ########unit is value/kms
            caremission_per_km = 1/car_per_km_emission ###unit is kms
            Total_cb_at_cars = caremission_per_km * Cobenefits_at_cars

            transport_cp_at = -Total_cb_at_cars

            # Given total costs for each sector
            sectors = {
                'Agriculture': 0,
                'Transport': transport_cp_at,
                'Waste': 0,
                'Foreign Transport': 0,
                'Work Machines': 0,
                'Electric DH': 0,
                'Own Heating': 0,
                'Product Use': 0,
                'Industry': 0
            }

            # Actors and their share
            actors_share = {
                'Total':1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share


            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Per Capita - Cummulative Co-benefits of improved physical health (active transport) in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Per capita - Cumulative co-benefits of improved physical health 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df

    elif scenario == "Scenario 3 - Optimistic Scenario" and emissions_output == "Per capita emissions" and ci_dropdown == 'Total':
        ##################################Co-impacts###################################################################

        ########################Air quality ###################################
        # 2030 emission value from the provided array
        agr_emission_2030 = agriculture_values[-1] - agriculture_values[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        agr_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = agr_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            agr_total_cost += (-cost)

        # 2030 emission value from the provided array
        trans_emission_2030 = transport_values[-1] - transport_values[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        trans_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = trans_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            trans_total_cost += (-cost)

        # 2030 emission value from the provided array
        waste_emission_2030 = waste_values[-1] - waste_values[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        waste_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = waste_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            waste_total_cost += (-cost)

        # 2030 emission value from the provided array
        ft_emission_2030 = foreign_transport_values[-1] - foreign_transport_values[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        ft_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = ft_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            ft_total_cost += (-cost)

        # 2030 emission value from the provided array
        wm_emission_2030 = work_machines_values[-1] - work_machines_values[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        wm_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = wm_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            wm_total_cost += (-cost)

        # 2030 emission value from the provided array
        el_emission_2030 = el_dh_values[-1] - el_dh_values[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        el_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = el_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            el_total_cost += (-cost)

        # 2030 emission value from the provided array
        oh_emission_2030 = own_heating_values[-1] - own_heating_values[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        oh_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = oh_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            oh_total_cost += (-cost)

        # 2030 emission value from the provided array
        pu_emission_2030 = product_use_values[-1] - product_use_values[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        pu_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = pu_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            pu_total_cost += (-cost)

        # 2030 emission value from the provided array
        ind_emission_2030 = industry_values[-1] - industry_values[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        ind_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = ind_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            ind_total_cost += (-cost)

        ###########################Noise pollution ############################
        growth_perc2030 = 1
        # Initialize the number of years in the simulation
        num_years = 2030 - 2021 + 1

        # Calculate the annual growth increment for each type of transport
        car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
        bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
        heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
        light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
        air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
        other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)

        car_values = np.full(num_years, cars_2019)
        bus_values = np.full(num_years, buses_2019)
        heavy_truck_values = np.full(num_years, heavy_trucks_2019)
        light_truck_values = np.full(num_years, light_trucks_2019)
        air_transport_values = np.full(num_years, air_transport_2019)
        other_transport_values = np.full(num_years, other_transport_2019)

        # Apply the linear growth from 2019 to 2030
        for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
            car_values[i] = car_values[i - 1] + car_growth_increment
            bus_values[i] = bus_values[i - 1] + bus_growth_increment
            heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
            light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
            air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
            other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment

        # Apply the levers
        for i in range(num_years):
            current_year = 2021 + i
            pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (
                        2030 - RC_year) if current_year >= RC_year else 0
            act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (
                        2030 - AT_year) if current_year >= AT_year else 0
            el_car_value = ((el_car / 100) * (current_year - start_year)) / (
                        2030 - start_year) if current_year >= start_year else 0
            el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (
                        2030 - start_year) if current_year >= start_year else 00
            electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (
                        2030 - start_year) if current_year >= start_year else 0
            electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (
                        2030 - start_year) if current_year >= start_year else 0

            # Calculate the values for each type of transport
            car_values[i] *= (1 - ((pt_car_value + act_trans_value + (
                        el_car_value * caremission_intensity_EV))))  #####refernce available only for electric cars
            bus_values[i] *= (1 - ((el_bus_value * busemission_intensity_EV)))
            heavy_truck_values[i] *= (1 - (((electric_heavy_value * HT_emission_intensity_EV))))
            light_truck_values[i] *= (1 - (((electric_light_value * LT_emission_intensity_EV))))

        ###############computational part of co-benefits#####################
        # 2030 emission value from the provided array
        Car_emission_per_emission = car_values[-1] - car_values[
            0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        car_per_km_emission = Car_emission_per_km / Car_emission_per_emission  ########unit is value/kms
        caremission_per_km = 1 / car_per_km_emission  ###unit is kms
        Total_cb_np_cars = caremission_per_km * Cobenefits_np_cars

        bus_emission_per_emission = bus_values[-1] - bus_values[
            0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        bus_per_km_emission = bus_emission_per_km / bus_emission_per_emission  ########unit is value/kms
        busemission_per_km = 1 / bus_per_km_emission  ###unit is kms
        Total_cb_np_buses = busemission_per_km * Cobenefits_np_buses

        ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[
            0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
        htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
        Total_cb_np_ht = htemission_per_km * Cobenefits_np_ht

        lt_emission_per_emission = light_truck_values[-1] - light_truck_values[
            0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
        ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
        Total_cb_np_lt = ltemission_per_km * Cobenefits_np_lt

        transport_cp_np = -(Total_cb_np_cars + Total_cb_np_buses + Total_cb_np_ht + Total_cb_np_lt)

        #######################Traffic safety##################

        ###############computational part of co-benefits#####################
        # 2030 emission value from the provided array
        Car_emission_per_emission = car_values[-1] - car_values[
            0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        car_per_km_emission = Car_emission_per_km / Car_emission_per_emission  ########unit is value/kms
        caremission_per_km = 1 / car_per_km_emission  ###unit is kms
        Total_cb_ts_cars = caremission_per_km * Cobenefits_ts_cars

        bus_emission_per_emission = bus_values[-1] - bus_values[
            0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        bus_per_km_emission = bus_emission_per_km / bus_emission_per_emission  ########unit is value/kms
        busemission_per_km = 1 / bus_per_km_emission  ###unit is kms
        Total_cb_ts_buses = busemission_per_km * Cobenefits_ts_buses

        ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[
            0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
        htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
        Total_cb_ts_ht = htemission_per_km * Cobenefits_ts_ht

        lt_emission_per_emission = light_truck_values[-1] - light_truck_values[
            0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
        ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
        Total_cb_ts_lt = ltemission_per_km * Cobenefits_ts_lt

        transport_cp_ts = -(Total_cb_ts_cars + Total_cb_ts_buses + Total_cb_ts_ht + Total_cb_ts_lt)

        #############Improved physical health ##############

        # Initialize the number of years in the simulation
        num_years = 2030 - 2021 + 1

        # Calculate the annual growth increment for each type of transport
        car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)

        car_values = np.full(num_years, cars_2019)

        # Apply the linear growth from 2019 to 2030
        for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
            car_values[i] = car_values[i - 1] + car_growth_increment

        # Apply the levers
        for i in range(num_years):
            current_year = 2021 + i
            act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (
                        2030 - AT_year) if current_year >= AT_year else 0

            # Calculate the values for each type of transport
            car_values[i] *= (1 - ((act_trans_value)))  #####refernce available only for electric cars

        ###############computational part of co-benefits#####################
        # 2030 emission value from the provided array
        Car_emission_per_emission = car_values[-1] - car_values[
            0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        car_per_km_emission = Car_emission_per_km / Car_emission_per_emission  ########unit is value/kms
        caremission_per_km = 1 / car_per_km_emission  ###unit is kms
        Total_cb_at_cars = caremission_per_km * Cobenefits_at_cars

        transport_cp_at = -Total_cb_at_cars

        Transport = trans_total_cost + transport_cp_at + transport_cp_np + transport_cp_ts

        # Given total costs for each sector
        sectors = {
            'Agriculture': agr_total_cost,
            'Transport': Transport,
            'Waste': waste_total_cost,
            'Foreign Transport': ft_total_cost,
            'Work Machines': wm_total_cost,
            'Electric DH': el_total_cost,
            'Own Heating': oh_total_cost,
            'Product Use': pu_total_cost,
            'Industry': ind_total_cost
        }

        # Actors and their share
        actors_share = {
            'Total': 1,
            'Citizens': 0.4,
            'Civil soceity': 0,
            'Financial institutions': 0,
            'Industry': 0,
            'Municipal governments': 0.6,
            'Superordinate governments': 0,
            'Utility companies': 0

        }

        # Determine the share of each actor
        actors_values = {}
        for actor, share in actors_share.items():
            for sector, cost in sectors.items():
                if sector not in actors_values:
                    actors_values[sector] = {}
                actors_values[sector][actor] = cost * share

        # Define color mapping for sectors
        sector_colors = {
            'Agriculture': "#ef553b",
            'Waste': "#FECB52",
            'Transport': "#e377c2",
            'Foreign Transport': '#AB63FA',
            'Work Machines': '#FFA15A',
            'Electric DH': "#9467bd",
            'Own Heating': "#ff7f0e",
            'Product Use': '#B6E880',
            'Industry': "#1f77b4"
        }

        # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
        fig_ci = go.Figure()

        for sector in sectors.keys():
            fig_ci.add_trace(go.Bar(
                x=list(actors_share.keys()),
                y=[actors_values[sector][actor] for actor in actors_share.keys()],
                name=sector,
                marker_color=sector_colors[sector]
            ))

        fig_ci.update_layout(
            barmode='stack',
            margin=dict(l=40, r=20, b=10, t=60),
            autosize=True,
            title_text="Per Capita - Total Cumulative Co-benefits in {} (SEK) - 2030".format(mun),
            title_font=dict(size=18, color="darkred"),
            xaxis_title="Actors",
            yaxis_title="SEK",
            yaxis=dict(
                showgrid=True,
                gridcolor='lightgray',
                gridwidth=0.5
            )
        )

        def create_dataframe(sectors, actors_share, actors_values):
            unique_sectors = list(sectors.keys())
            unique_actors = list(actors_share.keys())

            # Constructing a Data Dictionary
            data_exp = {"Sectors": unique_sectors}
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    actor_values.append(actors_values[sector].get(actor, 0))
                data_exp[actor] = actor_values

            # Converting Dictionary to DataFrame
            df = pd.DataFrame.from_dict(data_exp)

            # Reordering the DataFrame Columns
            df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

            # Inserting a new row at the beginning
            new_row = ["Per capita - Total Cumulative co-benefits 2030"] + [""] * (len(df.columns) - 1)
            df.loc[-1] = new_row  # adding a row
            df.index = df.index + 1  # shifting index
            df = df.sort_index()  # sorting by index

            # Return the serialized DataFrame
            return df.to_dict(orient='records')

        df = create_dataframe(sectors, actors_share, actors_values)

        fig_ci_output = fig_ci
        data_ci_output = df

    elif scenario == "Scenario 3 - Optimistic Scenario" and emissions_output == "Municipality emissions":
            start_year = 2021
            end_year = 2030
            num_years = end_year - start_year + 1

            growth_perc2030= 0.94
            growth_perc2019 = 1
        
            growth_rate_per_year = (growth_perc2030-growth_perc2019)/(end_year-start_year)

            transport_values1 = [transport_2019]

            # Calculate the annual growth increment required to achieve the target growth
            annual_growth_increment = (growth_perc2030 * transport_2019 - transport_2019) / (num_years - 1)

            # Calculate the transport values for the years 2019 to 2030
            for i in range(num_years - 1):
                interpolated_value = transport_values1[-1] + annual_growth_increment
                transport_values1.append(interpolated_value)

            # Create a list to store the multiplied values
            transport_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                transport_value = transport_values1[year - start_year]  # Index adjustment
                multiplied_value = transport_value * population
                transport_population_values.append(multiplied_value)

            # Repeat the above code for other variables

            industry_values1 = [industry_2019]

            # Calculate the annual growth increment required to achieve the target growth
            annual_growth_increment = (growth_perc2030 * industry_2019 - industry_2019) / (num_years - 1)

            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = industry_values1[-1] + annual_growth_increment
                industry_values1.append(next_value)

            # Create a list to store the multiplied values
            industry_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                industry_value = industry_values1[year - start_year]  # Index adjustment
                multiplied_value = industry_value * population
                industry_population_values.append(multiplied_value)

            agriculture_values1 = [agriculture_2019]

            # Calculate the annual growth increment required to achieve the target growth
            annual_growth_increment = (growth_perc2030 * agriculture_2019 - agriculture_2019) / (num_years - 1)

            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = agriculture_values1[-1] + annual_growth_increment
                agriculture_values1.append(next_value)

            # Create a list to store the multiplied values
            agriculture_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                agriculture_value = agriculture_values1[year - start_year]  # Index adjustment
                multiplied_value = agriculture_value * population
                agriculture_population_values.append(multiplied_value)

            el_dh_values1 = [el_dh_2019]

            # Calculate the annual growth increment required to achieve the target growth
            annual_growth_increment = (growth_perc2030 * el_dh_2019 - el_dh_2019) / (num_years - 1)

            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = el_dh_values1[-1] + annual_growth_increment
                el_dh_values1.append(next_value)

            # Create a list to store the multiplied values
            el_dh_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                el_dh_value = el_dh_values1[year - start_year]  # Index adjustment
                multiplied_value = el_dh_value * population
                el_dh_population_values.append(multiplied_value)

            own_heating_values1 = [own_heating_2019]
            # Calculate the annual growth increment required to achieve the target growth
            annual_growth_increment = (growth_perc2030 * own_heating_2019 - own_heating_2019) / (num_years - 1)

            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = own_heating_values1[-1] + annual_growth_increment
                own_heating_values1.append(next_value)

            # Create a list to store the multiplied values
            own_heating_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                own_heating_value = own_heating_values1[year - start_year]  # Index adjustment
                multiplied_value = own_heating_value * population
                own_heating_population_values.append(multiplied_value)

            ## work_machinesLevers
            work_machines_values1 = [work_machines_2019]
            annual_growth_increment = (growth_perc2030 * work_machines_2019 - work_machines_2019) / (num_years - 1)

            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = work_machines_values1[-1] + annual_growth_increment
                work_machines_values1.append(next_value)

            # Create a list to store the multiplied values
            work_machines_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                work_machines_value = work_machines_values1[year - start_year]  # Index adjustment
                multiplied_value = work_machines_value * population
                work_machines_population_values.append(multiplied_value)

            product_use_values1 = [product_use_2019]
            annual_growth_increment = (growth_perc2030 * product_use_2019 - product_use_2019) / (num_years - 1)

            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = product_use_values1[-1] + annual_growth_increment
                product_use_values1.append(next_value)

            # Create a list to store the multiplied values
            product_use_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                product_use_value = product_use_values1[year - start_year]  # Index adjustment
                multiplied_value = product_use_value * population
                product_use_population_values.append(multiplied_value)

            waste_values1 = [waste_2019]
            annual_growth_increment = (growth_perc2030 * waste_2019 - waste_2019) / (num_years - 1)

            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = waste_values1[-1] + annual_growth_increment
                waste_values1.append(next_value)

            # Create a list to store the multiplied values
            waste_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                waste_value = waste_values1[year - start_year]  # Index adjustment
                multiplied_value = waste_value * population
                waste_population_values.append(multiplied_value)

            foreign_transport_values1 = [foreign_transport_2019]
            annual_growth_increment = (growth_perc2030 * foreign_transport_2019 - foreign_transport_2019) / (
                        num_years - 1)

            # Calculate the industry values for the years 2019 to 2030
            for i in range(num_years - 1):
                next_value = foreign_transport_values1[-1] + annual_growth_increment
                foreign_transport_values1.append(next_value)

            # Create a list to store the multiplied values
            foreign_transport_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                foreign_transport_value = foreign_transport_values1[year - start_year]  # Index adjustment
                multiplied_value = foreign_transport_value * population
                foreign_transport_population_values.append(multiplied_value)

            Negatives_values1 = [Negatives_2019]
            for i in range(num_years - 1):
                interpolated_value = Negatives_values1[-1] * (1 + (1-1)/(end_year-start_year))
                Negatives_values1.append(interpolated_value)

            # Create a list to store the multiplied values
            Negatives_population_values = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                Negatives_value = Negatives_values1[year - start_year]  # Index adjustment
                multiplied_value = Negatives_value * population
                Negatives_population_values.append(multiplied_value)

                ################Lever###########################
           
            ## transportLevers    
            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
            bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
            heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
            light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
            air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
            other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)

            # Initialize the lists for each type of transport
            car_values = np.full(num_years, cars_2019)
            bus_values = np.full(num_years, buses_2019)
            heavy_truck_values = np.full(num_years, heavy_trucks_2019)
            light_truck_values = np.full(num_years, light_trucks_2019)
            air_transport_values = np.full(num_years, air_transport_2019)
            other_transport_values = np.full(num_years, other_transport_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1,num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment
                bus_values[i] = bus_values[i - 1] + bus_growth_increment
                heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
                light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
                air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
                other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                current_year = 2021 + i

                # Calculate lever values for the current year
                pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (
                            2030 - RC_year) if current_year >= RC_year else 0
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (
                            2030 - AT_year) if current_year >= AT_year else 0
                el_car_value = ((el_car / 100) * (current_year - start_year)) / (
                            2030 - start_year) if current_year >= start_year else 0
                ph_car_value = ((ph_car / 100) * (current_year - start_year)) / (
                            2030 - start_year) if current_year >= start_year else 0
                hydr_car_value = ((hydr_car / 100) * (current_year - start_year)) / (
                            2030 - start_year) if current_year >= start_year else 0
                ren_bus_value = ((ren_bus / 100) * (current_year - RENB_year)) / (
                            2030 - RENB_year) if current_year >= RENB_year else 0
                el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (
                            2030 - start_year) if current_year >= start_year else 0
                LBG_heavy_value = ((LBG_heavy / 100) * (current_year - start_year)) / (
                            2030 - start_year) if current_year >= start_year else 0
                electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (
                            2030 - start_year) if current_year >= start_year else 0
                LBG_light_value = ((LBG_light / 100) * (current_year - start_year)) / (
                            2030 - start_year) if current_year >= start_year else 0
                electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (
                            2030 - start_year) if current_year >= start_year else 0
                air_transp_value = ((air_transp / 100) * (current_year - AIT_year)) / (
                            2030 - AIT_year) if current_year >= AIT_year else 0

                # Apply the lever effects
                car_values[i] *= (1 - ((pt_car_value + act_trans_value + el_car_value * caremission_intensity_EV + ph_car_value * caremission_intensity_PIH + hydr_car_value * caremission_intensity_Hydrogen)))
                bus_values[i] *= (1 - ((ren_bus_value * busemission_intensity_ren + el_bus_value * busemission_intensity_EV)))
                heavy_truck_values[i] *= (1 -((LBG_heavy_value * HT_emission_intensity_LBG + electric_heavy_value * HT_emission_intensity_EV)))
                light_truck_values[i] *= (1 -((LBG_light_value * LT_emission_intensity_LBG + electric_light_value * LT_emission_intensity_EV)))
                air_transport_values[i] *= (1 -air_transp_value)
                other_transport_values[i] *= (1 -(pt_car_value + act_trans_value))

            # The total emissions are the sum of all types of transport
            transport_values = car_values + bus_values + heavy_truck_values + light_truck_values + air_transport_values + other_transport_values

            # Create a list to store the multiplied values
            transport_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                transport_value = transport_values[year - start_year]  # Index adjustment
                multiplied_value = transport_value * population
                transport_population_values1.append(multiplied_value)

            # industryLevers

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for the industry
            industry_growth_increment = ((growth_perc2030 - 1) * industry_2019) / (num_years - 1)

            # Initialize the list for the industry values
            industry_values = np.full(num_years, industry_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1,num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                industry_values[i] = industry_values[i - 1] + industry_growth_increment

            # Apply the levers to the linearly interpolated values
            for i in range(1,num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                current_year = 2021 + i

                # Calculate lever values for the current year
                ccs_value = ((CCS_industry / 100) * (current_year - ccs_year)) / (2030 - ccs_year) if current_year >= ccs_year else 0
                Hyd_value = ((H2_industry / 100) * (current_year - Hyd_year)) / (2030 - Hyd_year) if current_year >= Hyd_year else 0

                # Apply the lever effects
                industry_values[i] *= (1 - ((ccs_value * ccs_emission_intensity) + (Hyd_value * hyd_emission_intensity)))

            # Create a list to store the multiplied values
            industry_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                industry_value = industry_values[year - start_year]  # Index adjustment
                multiplied_value = industry_value * population
                industry_population_values1.append(multiplied_value)

            ## agricultureLevers
            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment
            annual_growth_increment = ((growth_perc2030 - 1) * agriculture_2019) / (num_years - 1)

            # Initialize the list for the agriculture values
            agriculture_values = np.full(num_years, agriculture_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                agriculture_values[i] = agriculture_values[i - 1] + annual_growth_increment  # Linear growth

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i  # Current year in the simulation

                agr_value = ((agr / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Apply the lever effect
                agriculture_values[i] *= (1 - ((agr_value) * agr_emission_intensity))

            # Create a list to store the multiplied values
            agriculture_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                agriculture_value = agriculture_values[year - start_year]  # Index adjustment
                multiplied_value = agriculture_value * population
                agriculture_population_values1.append(multiplied_value)

            ## el_dhLevers
            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for el_dh
            annual_growth_increment = ((growth_perc2030 - 1) * el_dh_2019) / (num_years - 1)

            # Initialize the list for the el_dh values
            el_dh_values = np.full(num_years, el_dh_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                el_dh_values[i] = el_dh_values[i - 1] + annual_growth_increment

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i

                # Calculate lever effects
                wind_value = ((wind / 100) * (current_year - W_year)) / (
                            2030 - W_year) if current_year >= W_year else 0
                rtsolar_value = ((rtsolar / 100) * (current_year - RS_year)) / (
                            2030 - RS_year) if current_year >= RS_year else 0
                csolar_value = ((csolar / 100) * (current_year - CS_year)) / (
                            2030 - CS_year) if current_year >= CS_year else 0
                DH_heatpumps_value = ((DH_heatpumps / 100) * (current_year - DHP_year)) / (
                            2030 - DHP_year) if current_year >= DHP_year else 0
                ccsw_value = ((ccsw / 100) * (current_year - CCSW_year)) / (
                            2030 - CCSW_year) if current_year >= CCSW_year else 0
                ind_temp_red_value = ((ind_temp_red / 100) * (current_year - start_year)) / (
                            2030 - start_year) if current_year >= start_year else 0
                sn_measure_value = ((sn_measure / 100) * (current_year - start_year)) / (
                            2030 - start_year) if current_year >= start_year else 0
                BAT_appl_value = ((BAT_appl / 100) * (current_year - start_year)) / (
                            2030 - start_year) if current_year >= start_year else 0

                el_dh_values[i] *= (((1 - ((BAT_appl_value * BAT_energy_consumption_impact) + (
                            ind_temp_red_value * Ind_temp_impact) + (
                                                   sn_measure_value * SN_eff_impact))) * ((1 - ((Share_elec_DH) * (
                            ((wind_value * Wind_emissions_intensity)) + (
                    (rtsolar_value * Solar_emission_intensity)) + (
                                    (csolar_value) * Solar_emission_intensity)) + ((1 - Share_elec_DH) * (
                    DH_heatpumps_value) * (((Share_DH_HP_air * emission_savings_air) + (
                            Share_DH_HP_water * emission_savings_water) + (
                                                    Share_DH_HP_GT * emission_savings_GT)))))))) * (
                                                1 - ((ccsw_value) * ccsw_emission_intensity)))

            # Create a list to store the multiplied values
            el_dh_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                el_dh_value = el_dh_values[year - start_year]  # Index adjustment
                multiplied_value = el_dh_value * population
                el_dh_population_values1.append(multiplied_value)

            ## own_heatingLevers
            own_heating_growth_2030 = own_heating * growth_perc2030
            own_heating_growth_2019 = own_heating_2019
            own_heating_values = [own_heating_growth_2019]

            num_years = 2030 - 2021

            for i in range(num_years):
                growth_rate_per_year = (own_heating_growth_2030 - own_heating_growth_2019) / num_years
                interpolated_value = own_heating_values[-1] + growth_rate_per_year
                own_heating_values.append(interpolated_value)

            # Create a list to store the multiplied values
            own_heating_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                own_heating_value = own_heating_values[year - start_year]  # Index adjustment
                multiplied_value = own_heating_value * population
                own_heating_population_values1.append(multiplied_value)

            ## work_machinesLevers
            ## work_machinesLevers

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment
            annual_growth_increment = ((growth_perc2030 - 1) * work_machines_2019) / (num_years - 1)

            # Initialize the list for the work_machines values
            work_machines_values = np.full(num_years, work_machines_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                work_machines_values[i] = work_machines_values[i - 1] + annual_growth_increment  # Linear growth

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i  # Current year in the simulation

                wm_value = ((wm / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Apply the lever effect
                work_machines_values[i] *= (1 - ((wm_value)))

            # Create a list to store the multiplied values
            work_machines_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                work_machines_value = work_machines_values[year - start_year]  # Index adjustment
                multiplied_value = work_machines_value * population
                work_machines_population_values1.append(multiplied_value)

            ## product_useLevers
            product_use_growth_2030 = product_use * growth_perc2030
            product_use_growth_2019 = product_use_2019
            product_use_values = [product_use_growth_2019]

            num_years = 2030 - 2021

            for i in range(num_years):
                growth_rate_per_year = (product_use_growth_2030 - product_use_growth_2019) / num_years
                interpolated_value = product_use_values[-1] + growth_rate_per_year
                product_use_values.append(interpolated_value)

            # Create a list to store the multiplied values
            product_use_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                product_use_value = product_use_values[year - start_year]  # Index adjustment
                multiplied_value = product_use_value * population
                product_use_population_values1.append(multiplied_value)

            ## wasteLevers
            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for the industry
            annual_growth_increment = ((growth_perc2030 - 1) * waste_2019) / (num_years - 1)

            # Initialize the list for the waste values
            waste_values = np.full(num_years, waste_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):
                waste_values[i] = waste_values[i - 1] + annual_growth_increment

            # Apply the levers to the linearly interpolated values
            for i in range(1, num_years):
                current_year = 2021 + i

                cmu_value = ((cmu / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Apply the lever effect
                waste_values[i] *= (1 - (cmu_value * Share_landfill_samecity))

            # Create a list to store the multiplied values
            waste_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                waste_value = waste_values[year - start_year]  # Index adjustment
                multiplied_value = waste_value * population
                waste_population_values1.append(multiplied_value)

            ## foreign_transportLevers
            foreign_transport_growth_2030 = foreign_transport * growth_perc2030
            foreign_transport_growth_2019 = foreign_transport_2019
            foreign_transport_values = [foreign_transport_growth_2019]

            num_years = 2030 - 2021

            for i in range(num_years):
                growth_rate_per_year = (foreign_transport_growth_2030 - foreign_transport_growth_2019) / num_years
                interpolated_value = foreign_transport_values[-1] + growth_rate_per_year
                foreign_transport_values.append(interpolated_value)

            # Create a list to store the multiplied values
            foreign_transport_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                foreign_transport_value = foreign_transport_values[year - start_year]  # Index adjustment
                multiplied_value = foreign_transport_value * population
                foreign_transport_population_values1.append(multiplied_value)

            ## NegativesLevers
            Negatives_growth_2030 = Negatives * 1
            Negatives_growth_2019 = Negatives_2019
            Negatives_values = [Negatives_growth_2019]

            num_years = end_year - start_year + 1  # Add 1 to include the end year
            Negatives_values = [Negatives_growth_2019] * num_years

            # Sort the levers by start year
            levers = sorted([(Bioccs_year, bio_ccs), (RW_year, rewetting_emissions), (CC_year, carbon_credit)])

            # Apply the levers
            for lever_start_year, lever_percentage in levers:
                # Calculate the total change based on the lever
                total_change = (Negatives_growth_2030 - Negatives_growth_2019) * lever_percentage / 100

                # Calculate the yearly change
                yearly_change = total_change / (end_year - (lever_start_year + 1) + 1)

                # Apply the yearly change to each year from the year after the start of the lever
                for i in range(lever_start_year - start_year + 1, num_years):
                    Negatives_values[i] += yearly_change * (i - (lever_start_year - start_year + 1) + 1)

            # Create a list to store the multiplied values
            Negatives_population_values1 = []

            # Iterate over years and calculate multiplied values
            for year in range(start_year, end_year + 1):
                population = pop.loc[mun, year]  # Replace 'mun' with the actual municipality identifier
                Negatives_value = Negatives_values[year - start_year]  # Index adjustment
                multiplied_value = Negatives_value * population
                Negatives_population_values1.append(multiplied_value)

                OP1_total_emissions_2030 = (
                                                    transport_population_values[-1] +
                                                    industry_population_values[-1] +
                                                    agriculture_population_values[-1] +
                                                    el_dh_population_values[-1] +
                                                    own_heating_population_values1[-1] +
                                                    work_machines_population_values[-1] +
                                                    product_use_population_values[-1] +
                                                    waste_population_values[-1] +
                                                    foreign_transport_population_values[-1]
                                            ) / 1000000

                OP2_total_emissions_2030 = (
                                                    transport_population_values1[-1] +
                                                    industry_population_values1[-1] +
                                                    agriculture_population_values1[-1] +
                                                    el_dh_population_values1[-1] +
                                                    own_heating_population_values1[-1] +
                                                    work_machines_population_values1[-1] +
                                                    product_use_population_values1[-1] +
                                                    waste_population_values1[-1] +
                                                    foreign_transport_population_values1[-1]
                                            ) / 1000000
            
                
                years = list(range(2021, 2031))
                # Create a color scale for the categories
                color_scale = ["#ef553b", "#FECB52", "#e377c2", '#AB63FA', '#FFA15A', "#9467bd",
                               "#ff7f0e", '#B6E880', "#1f77b4", "#d62728"]
    
            categories = ["Agriculture","Waste","Transport", "Foreign transport", "Work machinery", "Electricity and DH",
                   "Own heating","Product use","Industry", "Negatives"]
            values1 = [agriculture_population_values,waste_population_values, transport_population_values, foreign_transport_population_values,
                       work_machines_population_values, el_dh_population_values, own_heating_population_values, product_use_population_values, industry_population_values, Negatives_population_values]
            values2 = [agriculture_population_values1, waste_population_values1, transport_population_values1, foreign_transport_population_values1,
                       work_machines_population_values1, el_dh_population_values1, own_heating_population_values1, product_use_population_values1, industry_population_values1, Negatives_population_values1]
            
          
            # Create a figure with two subplots, each containing a stacked bar chart
            fig = make_subplots(rows=2, cols=1, subplot_titles=(f"Total Forecasted Emissions for 2030: {OP1_total_emissions_2030:.2f}", f"Total Emissions after taking measures for 2030: {OP2_total_emissions_2030:.2f}"), shared_xaxes=False, shared_yaxes=False)

            # Categories to display on the positive side
            positive_categories = ["Agriculture", "Waste", "Transport", "Foreign transport", "Work machinery", "Electricity and DH", "Own heating", "Product use", "Industry"]
            
            # Plot stacked bar chart for BAU Scenario
            for i in range(len(categories)):
                if categories[i] in positive_categories:
                    fig.add_trace(
                        go.Bar(x=years, y=values1[i], name=categories[i], hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=1, col=1
                    )
                else:
                    fig.add_trace(
                        go.Bar(x=years, y=[-val for val in values1[i]], name=categories[i], hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=1, col=1
                    )
            
            # Plot stacked bar chart for Scenario
            for i in range(len(categories)):
                if categories[i] in positive_categories:
                    fig.add_trace(
                        go.Bar(x=years, y=values2[i], showlegend=False, hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=2, col=1
                    )
                else:
                    fig.add_trace(
                        go.Bar(x=years, y=[-val for val in values2[i]], showlegend=False, hovertemplate="Variable: " + categories[i] + "<br>Value: %{y}<extra></extra>", marker=dict(color=color_scale[i])),
                        row=2, col=1
                    )
                    
            # Compute the net emissions for each year
            netzero_emissions_values = []
            for year in range(len(years)):
                positive_sum = sum(values2[i][year] for i in range(len(categories)) if categories[i] in positive_categories)
                negative_sum = sum(values2[i][year] for i in range(len(categories)) if categories[i] not in positive_categories)
                netzero_emissions_values.append(positive_sum - negative_sum)
                    
            # Plot line chart for Netzero emissions
            fig.add_trace(
                go.Scatter(x=years, y=netzero_emissions_values, name="Net emissions", mode='lines', hovertemplate="Variable: Net emissions<br>Value: %{y}<extra></extra>", marker=dict(color='#000080'), line=dict(width=3)),
                row=2, col=1
            )
            
            # Add labels and titles
            fig.update_layout(
                barmode="relative",
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Emissions profile in {} (Ton of CO2-eq)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='Ton of CO2-eq',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                    #tickformat=".0f",  # Format tick labels as decimal numbers
                    #ticksuffix=" Kg"  # Add "Kg" suffix to tick labels
                ),
                height=800
            )
            
            # Automatically determine the y-axis range for both charts based on the data
            fig.update_yaxes(row=1, col=1, autorange=True)
            fig.update_yaxes(row=2, col=1, autorange=True)
            
            # Update x-axis labels and tick values for both charts
            fig.update_xaxes(title_text="Years", ticktext=[str(year) for year in years], tickvals=years, row=1, col=1)
            fig.update_xaxes(title_text="Years", ticktext=[str(year) for year in years], tickvals=years, row=2, col=1)
            
            # Update y-axis label for the second chart
            fig.update_yaxes(title_text="Ton of CO2-eq", row=2, col=1)
            
            # Update y-axis label for the second chart
            fig.update_yaxes(title_text="Ton of CO2-eq", row=2, col=1)
            
            data_exp = {
            "Sectors": categories,
            "Input1": values1,
            "Input2": values2}

            fig_output = fig
            data_em_output = pd.DataFrame.from_dict(data_exp, orient='index').to_dict('records')

    if scenario == "Scenario 3 - Optimistic Scenario" and emissions_output == "Municipality emissions" and ci_dropdown == 'Improved air quality':
            ##################################Co-impacts###################################################################

            # 2030 emission value from the provided array
            agr_emission_2030 = agriculture_population_values1[-1] - agriculture_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            agr_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = agr_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                agr_total_cost += (-cost)

            # 2030 emission value from the provided array
            trans_emission_2030 = transport_population_values1[-1] - transport_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            trans_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = trans_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                trans_total_cost += (-cost)

            # 2030 emission value from the provided array
            waste_emission_2030 = waste_population_values1[-1] - waste_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            waste_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = waste_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                waste_total_cost += (-cost)

            # 2030 emission value from the provided array
            ft_emission_2030 = foreign_transport_population_values1[-1] - foreign_transport_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            ft_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = ft_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                ft_total_cost += (-cost)

            # 2030 emission value from the provided array
            wm_emission_2030 = work_machines_population_values1[-1] - work_machines_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            wm_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = wm_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                wm_total_cost += (-cost)

            # 2030 emission value from the provided array
            el_emission_2030 = el_dh_population_values1[-1] - el_dh_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            el_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = el_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                el_total_cost += (-cost)

            # 2030 emission value from the provided array
            oh_emission_2030 = own_heating_population_values1[-1] - own_heating_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            oh_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = oh_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                oh_total_cost += (-cost)

            # 2030 emission value from the provided array
            pu_emission_2030 = product_use_population_values1[-1] - product_use_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            pu_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = pu_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                pu_total_cost += (-cost)

            # 2030 emission value from the provided array
            ind_emission_2030 = industry_population_values1[-1] - industry_population_values1[0]  # Last value in the array

            # Calculate reduced emissions and total cost
            ind_total_cost = 0
            for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
                reduced_emission = ind_emission_2030 * emission_factors[ef_key]
                cost = reduced_emission * cost_factors[cost_key]
                ind_total_cost += (-cost)

            # Given total costs for each sector
            sectors = {
                'Agriculture': agr_total_cost,
                'Transport': trans_total_cost,
                'Waste': waste_total_cost,
                'Foreign Transport': ft_total_cost,
                'Work Machines': wm_total_cost,
                'Electric DH': el_total_cost,
                'Own Heating': oh_total_cost,
                'Product Use': pu_total_cost,
                'Industry': ind_total_cost
            }

            # Actors and their share
            actors_share = {
                'Total': 1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share

            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Municipality - Cumulative Co-benefits of improved air quality in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Municipality - Cumulative co-benefits of improved air quality 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df

    elif scenario == "Scenario 3 - Optimistic Scenario" and emissions_output == "Municipality emissions" and ci_dropdown == 'Reduced noise pollution':
            ##################################Co-impacts###################################################################

            growth_perc2030 = 1
            growth_perc2019 = 1

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
            bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
            heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
            light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
            air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
            other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)

            car_values = np.full(num_years, cars_2019)
            bus_values = np.full(num_years, buses_2019)
            heavy_truck_values = np.full(num_years, heavy_trucks_2019)
            light_truck_values = np.full(num_years, light_trucks_2019)
            air_transport_values = np.full(num_years, air_transport_2019)
            other_transport_values = np.full(num_years, other_transport_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment
                bus_values[i] = bus_values[i - 1] + bus_growth_increment
                heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
                light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
                air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
                other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment

            # Apply the levers
            for i in range(num_years):
                current_year = 2021 + i
                pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (2030 - RC_year) if current_year >= RC_year else 0
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0
                el_car_value = ((el_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 00
                electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Calculate the values for each type of transport
                car_values[i] *= (1 - ((pt_car_value + act_trans_value + (el_car_value * caremission_intensity_EV)))) #####refernce available only for electric cars
                bus_values[i] *= (1 - ((el_bus_value * busemission_intensity_EV)))
                heavy_truck_values[i] *= (1 - (((electric_heavy_value * HT_emission_intensity_EV))))
                light_truck_values[i] *= (1 - (((electric_light_value * LT_emission_intensity_EV))))

            ###############computational part of co-benefits#####################
            # 2030 emission value from the provided array
            Car_emission_per_emission = car_values[-1] - car_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            car_per_km_emission= Car_emission_per_km/Car_emission_per_emission ########unit is value/kms
            caremission_per_km = 1/car_per_km_emission ###unit is kms
            Total_cb_np_cars = (caremission_per_km * Cobenefits_np_cars)* pop.loc[str(mun), 20300] ###############20300 means the average population of the each municipality is taken into account

            bus_emission_per_emission = bus_values[-1] - bus_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            bus_per_km_emission= bus_emission_per_km/bus_emission_per_emission ########unit is value/kms
            busemission_per_km = 1/bus_per_km_emission ###unit is kms
            Total_cb_np_buses = (busemission_per_km * Cobenefits_np_buses)* pop.loc[str(mun), 20300] ###############20300 means the average population of the each municipality is taken into account

            ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
            htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
            Total_cb_np_ht = (htemission_per_km * Cobenefits_np_ht)* pop.loc[str(mun), 20300] ###############20300 means the average population of the each municipality is taken into account

            lt_emission_per_emission =  light_truck_values[-1] -  light_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
            ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
            Total_cb_np_lt = (ltemission_per_km * Cobenefits_np_lt)* pop.loc[str(mun), 20300] ###############20300 means the average population of the each municipality is taken into account

            transport_cp_np = -(Total_cb_np_cars + Total_cb_np_buses + Total_cb_np_ht + Total_cb_np_lt)

            # Given total costs for each sector
            sectors = {
                'Agriculture': 0,
                'Transport': transport_cp_np,
                'Waste': 0,
                'Foreign Transport': 0,
                'Work Machines': 0,
                'Electric DH': 0,
                'Own Heating': 0,
                'Product Use': 0,
                'Industry': 0
            }

            # Actors and their share
            actors_share = {
                'Total':1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share


            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Municipality - Cumulative Co-benefits of reduced noise pollution in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Municipality - Cumulative co-benefits of reduced noise pollution 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df


    elif scenario == "Scenario 3 - Optimistic Scenario" and emissions_output == "Municipality emissions" and ci_dropdown == 'Improved traffic safety':
            ##################################Co-impacts###################################################################

            growth_perc2030 = 1
            growth_perc2019 = 1

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
            bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
            heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
            light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
            air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
            other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)

            car_values = np.full(num_years, cars_2019)
            bus_values = np.full(num_years, buses_2019)
            heavy_truck_values = np.full(num_years, heavy_trucks_2019)
            light_truck_values = np.full(num_years, light_trucks_2019)
            air_transport_values = np.full(num_years, air_transport_2019)
            other_transport_values = np.full(num_years, other_transport_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment
                bus_values[i] = bus_values[i - 1] + bus_growth_increment
                heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
                light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
                air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
                other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment

            # Apply the levers
            for i in range(num_years):
                current_year = 2021 + i
                pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (2030 - RC_year) if current_year >= RC_year else 0
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0
                el_car_value = ((el_car / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 00
                electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0
                electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (2030 - start_year) if current_year >= start_year else 0

                # Calculate the values for each type of transport
                car_values[i] *= (1 - ((pt_car_value + act_trans_value + (el_car_value * caremission_intensity_EV)))) #####refernce available only for electric cars
                bus_values[i] *= (1 - ((el_bus_value * busemission_intensity_EV)))
                heavy_truck_values[i] *= (1 - (((electric_heavy_value * HT_emission_intensity_EV))))
                light_truck_values[i] *= (1 - (((electric_light_value * LT_emission_intensity_EV))))

            ###############computational part of co-benefits#####################
            # 2030 emission value from the provided array ###############20300 means the average population of the each municipality is taken into account
            Car_emission_per_emission = car_values[-1] - car_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            car_per_km_emission= Car_emission_per_km/Car_emission_per_emission ########unit is value/kms
            caremission_per_km = 1/car_per_km_emission ###unit is kms
            Total_cb_ts_cars = (caremission_per_km * Cobenefits_ts_cars)* pop.loc[str(mun), 20300]

            bus_emission_per_emission = bus_values[-1] - bus_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            bus_per_km_emission= bus_emission_per_km/bus_emission_per_emission ########unit is value/kms
            busemission_per_km = 1/bus_per_km_emission ###unit is kms
            Total_cb_ts_buses = (busemission_per_km * Cobenefits_ts_buses)* pop.loc[str(mun), 20300]

            ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
            htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
            Total_cb_ts_ht = (htemission_per_km * Cobenefits_ts_ht)* pop.loc[str(mun), 20300]

            lt_emission_per_emission =  light_truck_values[-1] -  light_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
            lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
            ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
            Total_cb_ts_lt = (ltemission_per_km * Cobenefits_ts_lt)* pop.loc[str(mun), 20300]

            transport_cp_ts = -(Total_cb_ts_cars + Total_cb_ts_buses + Total_cb_ts_ht + Total_cb_ts_lt)

            # Given total costs for each sector
            sectors = {
                'Agriculture': 0,
                'Transport': transport_cp_ts,
                'Waste': 0,
                'Foreign Transport': 0,
                'Work Machines': 0,
                'Electric DH': 0,
                'Own Heating': 0,
                'Product Use': 0,
                'Industry': 0
            }

            # Actors and their share
            actors_share = {
                'Total':1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share


            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Municipality - Cumulative Co-benefits of improved traffic safety in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Municipality - Cumulative co-benefits of improved traffic safety 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df


    elif scenario == "Scenario 3 - Optimistic Scenario" and emissions_output == "Municipality emissions" and ci_dropdown == 'Improved physical health':
            ##################################Co-impacts###################################################################

            growth_perc2030 = 1
            growth_perc2019 = 1

            # Initialize the number of years in the simulation
            num_years = 2030 - 2021 + 1

            # Calculate the annual growth increment for each type of transport
            car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)

            car_values = np.full(num_years, cars_2019)

            # Apply the linear growth from 2019 to 2030
            for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
                car_values[i] = car_values[i - 1] + car_growth_increment

            # Apply the levers
            for i in range(num_years):
                current_year = 2021 + i
                act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0

                # Calculate the values for each type of transport
                car_values[i] *= (1 - ((act_trans_value))) #####refernce available only for electric cars

            ###############computational part of co-benefits#####################
            # 2030 emission value from the provided array ###############20300 means the average population of the each municipality is taken into account
            Car_emission_per_emission = car_values[-1] - car_values[0]# Last value in the array ###emission reduc reduced due to car in KGCO2e
            car_per_km_emission= Car_emission_per_km/Car_emission_per_emission ########unit is value/kms
            caremission_per_km = 1/car_per_km_emission ###unit is kms
            Total_cb_at_cars = (caremission_per_km * Cobenefits_at_cars)* pop.loc[str(mun), 20300]

            transport_cp_at = -Total_cb_at_cars

            # Given total costs for each sector
            sectors = {
                'Agriculture': 0,
                'Transport': transport_cp_at,
                'Waste': 0,
                'Foreign Transport': 0,
                'Work Machines': 0,
                'Electric DH': 0,
                'Own Heating': 0,
                'Product Use': 0,
                'Industry': 0
            }

            # Actors and their share
            actors_share = {
                'Total':1,
                'Citizens': 0.4,
                'Civil soceity': 0,
                'Financial institutions': 0,
                'Industry': 0,
                'Municipal governments': 0.6,
                'Superordinate governments': 0,
                'Utility companies': 0

            }

            # Determine the share of each actor
            actors_values = {}
            for actor, share in actors_share.items():
                for sector, cost in sectors.items():
                    if sector not in actors_values:
                        actors_values[sector] = {}
                    actors_values[sector][actor] = cost * share


            # Define color mapping for sectors
            sector_colors = {
                'Agriculture': "#ef553b",
                'Waste': "#FECB52",
                'Transport': "#e377c2",
                'Foreign Transport': '#AB63FA',
                'Work Machines': '#FFA15A',
                'Electric DH': "#9467bd",
                'Own Heating': "#ff7f0e",
                'Product Use': '#B6E880',
                'Industry': "#1f77b4"
            }

            # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
            fig_ci = go.Figure()

            for sector in sectors.keys():
                fig_ci.add_trace(go.Bar(
                    x=list(actors_share.keys()),
                    y=[actors_values[sector][actor] for actor in actors_share.keys()],
                    name=sector,
                    marker_color=sector_colors[sector]
                ))

            fig_ci.update_layout(
                barmode='stack',
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Municipality - Cumulative Co-benefits of improved physical health (active transport) in {} (SEK) - 2030".format(mun),
                title_font=dict(size=18, color="darkred"),
                xaxis_title="Actors",
                yaxis_title="SEK",
                yaxis=dict(
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5
                )
            )

            def create_dataframe(sectors, actors_share, actors_values):
                unique_sectors = list(sectors.keys())
                unique_actors = list(actors_share.keys())

                # Constructing a Data Dictionary
                data_exp = {"Sectors": unique_sectors}
                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        actor_values.append(actors_values[sector].get(actor, 0))
                    data_exp[actor] = actor_values

                # Converting Dictionary to DataFrame
                df = pd.DataFrame.from_dict(data_exp)

                # Reordering the DataFrame Columns
                df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

                # Inserting a new row at the beginning
                new_row = ["Municipality - Cumulative co-benefits of improved physical health 2030"] + [""] * (len(df.columns) - 1)
                df.loc[-1] = new_row  # adding a row
                df.index = df.index + 1  # shifting index
                df = df.sort_index()  # sorting by index

                # Return the serialized DataFrame
                return df.to_dict(orient='records')

            df = create_dataframe(sectors, actors_share, actors_values)

            fig_ci_output = fig_ci
            data_ci_output = df

    elif scenario == "Scenario 3 - Optimistic Scenario" and emissions_output == "Municipality emissions" and ci_dropdown == 'Total':
        ##################################Co-impacts###################################################################

        ########################Air quality ###################################
        agr_emission_2030 = agriculture_population_values1[-1] - agriculture_population_values1[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        agr_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = agr_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            agr_total_cost += (-cost)

        # 2030 emission value from the provided array
        trans_emission_2030 = transport_population_values1[-1] - transport_population_values1[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        trans_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = trans_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            trans_total_cost += (-cost)

        # 2030 emission value from the provided array
        waste_emission_2030 = waste_population_values1[-1] - waste_population_values1[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        waste_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = waste_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            waste_total_cost += (-cost)

        # 2030 emission value from the provided array
        ft_emission_2030 = foreign_transport_population_values1[-1] - foreign_transport_population_values1[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        ft_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = ft_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            ft_total_cost += (-cost)

        # 2030 emission value from the provided array
        wm_emission_2030 = work_machines_population_values1[-1] - work_machines_population_values1[
            0]  # Last value in the array

        # Calculate reduced emissions and total cost
        wm_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = wm_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            wm_total_cost += (-cost)

        # 2030 emission value from the provided array
        el_emission_2030 = el_dh_population_values1[-1] - el_dh_population_values1[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        el_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = el_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            el_total_cost += (-cost)

        # 2030 emission value from the provided array
        oh_emission_2030 = own_heating_population_values1[-1] - own_heating_population_values1[
            0]  # Last value in the array

        # Calculate reduced emissions and total cost
        oh_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = oh_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            oh_total_cost += (-cost)

        # 2030 emission value from the provided array
        pu_emission_2030 = product_use_population_values1[-1] - product_use_population_values1[
            0]  # Last value in the array

        # Calculate reduced emissions and total cost
        pu_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = pu_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            pu_total_cost += (-cost)

        # 2030 emission value from the provided array
        ind_emission_2030 = industry_population_values1[-1] - industry_population_values1[0]  # Last value in the array

        # Calculate reduced emissions and total cost
        ind_total_cost = 0
        for ef_key, cost_key in zip(emission_factors.keys(), cost_factors.keys()):
            reduced_emission = ind_emission_2030 * emission_factors[ef_key]
            cost = reduced_emission * cost_factors[cost_key]
            ind_total_cost += (-cost)

        ###########################Noise pollution ############################
        growth_perc2030 = 1
        growth_perc2019 = 1
        # Initialize the number of years in the simulation
        num_years = 2030 - 2021 + 1

        # Calculate the annual growth increment for each type of transport
        car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)
        bus_growth_increment = ((growth_perc2030 - 1) * buses_2019) / (num_years - 1)
        heavy_truck_growth_increment = ((growth_perc2030 - 1) * heavy_trucks_2019) / (num_years - 1)
        light_truck_growth_increment = ((growth_perc2030 - 1) * light_trucks_2019) / (num_years - 1)
        air_transport_growth_increment = ((growth_perc2030 - 1) * air_transport_2019) / (num_years - 1)
        other_transport_growth_increment = ((growth_perc2030 - 1) * other_transport_2019) / (num_years - 1)

        car_values = np.full(num_years, cars_2019)
        bus_values = np.full(num_years, buses_2019)
        heavy_truck_values = np.full(num_years, heavy_trucks_2019)
        light_truck_values = np.full(num_years, light_trucks_2019)
        air_transport_values = np.full(num_years, air_transport_2019)
        other_transport_values = np.full(num_years, other_transport_2019)

        # Apply the linear growth from 2019 to 2030
        for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
            car_values[i] = car_values[i - 1] + car_growth_increment
            bus_values[i] = bus_values[i - 1] + bus_growth_increment
            heavy_truck_values[i] = heavy_truck_values[i - 1] + heavy_truck_growth_increment
            light_truck_values[i] = light_truck_values[i - 1] + light_truck_growth_increment
            air_transport_values[i] = air_transport_values[i - 1] + air_transport_growth_increment
            other_transport_values[i] = other_transport_values[i - 1] + other_transport_growth_increment

        # Apply the levers
        for i in range(num_years):
            current_year = 2021 + i
            pt_car_value = ((pt_car / 100) * (current_year - RC_year)) / (
                        2030 - RC_year) if current_year >= RC_year else 0
            act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (
                        2030 - AT_year) if current_year >= AT_year else 0
            el_car_value = ((el_car / 100) * (current_year - start_year)) / (
                        2030 - start_year) if current_year >= start_year else 0
            el_bus_value = ((el_bus / 100) * (current_year - start_year)) / (
                        2030 - start_year) if current_year >= start_year else 00
            electric_heavy_value = ((electric_heavy / 100) * (current_year - start_year)) / (
                        2030 - start_year) if current_year >= start_year else 0
            electric_light_value = ((electric_light / 100) * (current_year - start_year)) / (
                        2030 - start_year) if current_year >= start_year else 0

            # Calculate the values for each type of transport
            car_values[i] *= (1 - ((pt_car_value + act_trans_value + (el_car_value * caremission_intensity_EV))))  #####refernce available only for electric cars
            bus_values[i] *= (1 - ((el_bus_value * busemission_intensity_EV)))
            heavy_truck_values[i] *= (1 - (((electric_heavy_value * HT_emission_intensity_EV))))
            light_truck_values[i] *= (1 - (((electric_light_value * LT_emission_intensity_EV))))

        ###############computational part of co-benefits#####################
        # 2030 emission value from the provided array
        Car_emission_per_emission = car_values[-1] - car_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        car_per_km_emission = Car_emission_per_km / Car_emission_per_emission  ########unit is value/kms
        caremission_per_km = 1 / car_per_km_emission  ###unit is kms
        Total_cb_np_cars = (caremission_per_km * Cobenefits_np_cars)* pop.loc[str(mun), 20300]

        bus_emission_per_emission = bus_values[-1] - bus_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        bus_per_km_emission = bus_emission_per_km / bus_emission_per_emission  ########unit is value/kms
        busemission_per_km = 1 / bus_per_km_emission  ###unit is kms
        Total_cb_np_buses = (busemission_per_km * Cobenefits_np_buses)* pop.loc[str(mun), 20300]

        ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
        htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
        Total_cb_np_ht = (htemission_per_km * Cobenefits_np_ht)* pop.loc[str(mun), 20300]

        lt_emission_per_emission = light_truck_values[-1] - light_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
        ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
        Total_cb_np_lt = (ltemission_per_km * Cobenefits_np_lt)* pop.loc[str(mun), 20300]

        transport_cp_np = -(Total_cb_np_cars + Total_cb_np_buses + Total_cb_np_ht + Total_cb_np_lt)

        #######################Traffic safety##################

        ###############computational part of co-benefits#####################
        # 2030 emission value from the provided array
        Car_emission_per_emission = car_values[-1] - car_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        car_per_km_emission = Car_emission_per_km / Car_emission_per_emission  ########unit is value/kms
        caremission_per_km = 1 / car_per_km_emission  ###unit is kms
        Total_cb_ts_cars = (caremission_per_km * Cobenefits_ts_cars)* pop.loc[str(mun), 20300]

        bus_emission_per_emission = bus_values[-1] - bus_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        bus_per_km_emission = bus_emission_per_km / bus_emission_per_emission  ########unit is value/kms
        busemission_per_km = 1 / bus_per_km_emission  ###unit is kms
        Total_cb_ts_buses = (busemission_per_km * Cobenefits_ts_buses)* pop.loc[str(mun), 20300]

        ht_emission_per_emission = heavy_truck_values[-1] - heavy_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        ht_per_km_emission = ht_emission_per_km / ht_emission_per_emission  ########unit is value/kms
        htemission_per_km = 1 / ht_per_km_emission  ###unit is kms
        Total_cb_ts_ht = (htemission_per_km * Cobenefits_ts_ht)* pop.loc[str(mun), 20300]

        lt_emission_per_emission = light_truck_values[-1] - light_truck_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        lt_per_km_emission = lt_emission_per_km / lt_emission_per_emission  ########unit is value/kms
        ltemission_per_km = 1 / lt_per_km_emission  ###unit is kms
        Total_cb_ts_lt = (ltemission_per_km * Cobenefits_ts_lt)* pop.loc[str(mun), 20300]

        transport_cp_ts = -(Total_cb_ts_cars + Total_cb_ts_buses + Total_cb_ts_ht + Total_cb_ts_lt)

        #############Improved physical health ##############

        # Initialize the number of years in the simulation
        num_years = 2030 - 2021 + 1

        # Calculate the annual growth increment for each type of transport
        car_growth_increment = ((growth_perc2030 - 1) * cars_2019) / (num_years - 1)

        car_values = np.full(num_years, cars_2019)

        # Apply the linear growth from 2019 to 2030
        for i in range(1, num_years):  # Start from index 1 because we already have the value for index 0 (year 2019)
            car_values[i] = car_values[i - 1] + car_growth_increment

        # Apply the levers
        for i in range(num_years):
            current_year = 2021 + i
            act_trans_value = ((act_trans / 100) * (current_year - AT_year)) / (2030 - AT_year) if current_year >= AT_year else 0

            # Calculate the values for each type of transport
            car_values[i] *= (1 - ((act_trans_value)))  #####refernce available only for electric cars

        ###############computational part of co-benefits#####################
        # 2030 emission value from the provided array
        Car_emission_per_emission = car_values[-1] - car_values[0]  # Last value in the array ###emission reduc reduced due to car in KGCO2e
        car_per_km_emission = Car_emission_per_km / Car_emission_per_emission  ########unit is value/kms
        caremission_per_km = 1 / car_per_km_emission  ###unit is kms
        Total_cb_at_cars = (caremission_per_km * Cobenefits_at_cars)* pop.loc[str(mun), 20300]

        transport_cp_at = -Total_cb_at_cars

        Transport = trans_total_cost + transport_cp_at + transport_cp_np + transport_cp_ts

        # Given total costs for each sector
        sectors = {
            'Agriculture': agr_total_cost,
            'Transport': Transport,
            'Waste': waste_total_cost,
            'Foreign Transport': ft_total_cost,
            'Work Machines': wm_total_cost,
            'Electric DH': el_total_cost,
            'Own Heating': oh_total_cost,
            'Product Use': pu_total_cost,
            'Industry': ind_total_cost
        }

        # Actors and their share
        actors_share = {
            'Total': 1,
            'Citizens': 0.4,
            'Civil soceity': 0,
            'Financial institutions': 0,
            'Industry': 0,
            'Municipal governments': 0.6,
            'Superordinate governments': 0,
            'Utility companies': 0

        }

        # Determine the share of each actor
        actors_values = {}
        for actor, share in actors_share.items():
            for sector, cost in sectors.items():
                if sector not in actors_values:
                    actors_values[sector] = {}
                actors_values[sector][actor] = cost * share

        # Define color mapping for sectors
        sector_colors = {
            'Agriculture': "#ef553b",
            'Waste': "#FECB52",
            'Transport': "#e377c2",
            'Foreign Transport': '#AB63FA',
            'Work Machines': '#FFA15A',
            'Electric DH': "#9467bd",
            'Own Heating': "#ff7f0e",
            'Product Use': '#B6E880',
            'Industry': "#1f77b4"
        }

        # Adjusting the plotting process to have actors on the X-axis and sectors stacked with specified colors
        fig_ci = go.Figure()

        for sector in sectors.keys():
            fig_ci.add_trace(go.Bar(
                x=list(actors_share.keys()),
                y=[actors_values[sector][actor] for actor in actors_share.keys()],
                name=sector,
                marker_color=sector_colors[sector]
            ))

        fig_ci.update_layout(
            barmode='stack',
            margin=dict(l=40, r=20, b=10, t=60),
            autosize=True,
            title_text="Municipality - Total Cumulative Co-benefits in {} (SEK) - 2030".format(mun),
            title_font=dict(size=18, color="darkred"),
            xaxis_title="Actors",
            yaxis_title="SEK",
            yaxis=dict(
                showgrid=True,
                gridcolor='lightgray',
                gridwidth=0.5
            )
        )

        def create_dataframe(sectors, actors_share, actors_values):
            unique_sectors = list(sectors.keys())
            unique_actors = list(actors_share.keys())

            # Constructing a Data Dictionary
            data_exp = {"Sectors": unique_sectors}
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    actor_values.append(actors_values[sector].get(actor, 0))
                data_exp[actor] = actor_values

            # Converting Dictionary to DataFrame
            df = pd.DataFrame.from_dict(data_exp)

            # Reordering the DataFrame Columns
            df = df[['Sectors'] + [col for col in df if col != 'Sectors']]

            # Inserting a new row at the beginning
            new_row = ["Municipality - Total Cumulative co-benefits 2030"] + [""] * (len(df.columns) - 1)
            df.loc[-1] = new_row  # adding a row
            df.index = df.index + 1  # shifting index
            df = df.sort_index()  # sorting by index

            # Return the serialized DataFrame
            return df.to_dict(orient='records')

        df = create_dataframe(sectors, actors_share, actors_values)

        fig_ci_output = fig_ci
        data_ci_output = df

    # Show the chart
    return [fig_output, current_fuel_bus, current_fuel_car, current_energymix, no_heat_measure, data_em_output,fig_ci_output,  data_ci_output]


@app.callback(
    Output("download-emissions-tbe-text", "data"),
    [Input("btn-download-emissions-tbe", "n_clicks"), Input("dd-emissions-value2", "data")] +
    [Input(f"slider-{i}", "value") for i in range(27, 58)] + [Input("slider-541", "value")],  # Add the new slider
    [State("scenario-dropdown-list-2", "value"), State("municipality-dropdown", "value")],
    prevent_initial_call=True)
def download_button(n_clicks, emissions_value, *args):

    slider_values = args[:-2]  # Extract slider values from args
    scenario, mun = args[-2:]  # Extract scenario and mun from args
    df = pd.DataFrame(emissions_value).transpose()
    ctx = dash.callback_context
    button_id = ctx.triggered[0]["prop_id"].split(".")[0]
    index_range = range(1, len(df.iloc[:, 0].to_list()) + 1)

    # Define a dictionary to give names to sliders
    slider_names = {
        "slider-27": "Agriculture",
        "slider-28": "Consumption and Material use",
        "slider-29": "Electric bus",
        "slider-30": "HVO bus",
        "slider-31": "Current bus fleet",
        "slider-32": "Air travel",
        "slider-33": "Electric cars",
        "slider-34": "Active transport",
        "slider-35": "Shift to Public transport from cars",
        "slider-36": "Current car fleet",
        "slider-37": "Plug in hybrid cars",
        "slider-38": "Hydrogen cars",
        "slider-39": "Heavy trucks biogas",
        "slider-40": "Heavy trucks electric",
        "slider-41": "Light trucks biogas",
        "slider-42": "Light trucks electric",
        "slider-43": "CCS waste",
        "slider-44": "electricity from wind",
        "slider-45": "electricity from rooftop solar",
        "slider-46": "electricity from centralised solar",
        "slider-47": "Existing energy production mix",
        "slider-48": "DH heat pumps",
        "slider-49": "Reduced indoor temp. 20C",
        "slider-50": "EE measures (S&N)",
        "slider-51": "BAT appliances",
        "slider-52": "No heat measure",
        "slider-53": "Industry CCS",
        "slider-54": "Hydrogen production for Industry",
        "slider-55": "Bio-CCS or DACCS",
        "slider-56": "Rewetting",
        "slider-57": "Carbon credit",
        "slider-541": "Work machinery"
    }

    # Create a DataFrame for the slider values
    df_sliders = pd.DataFrame({
        'Measures': [slider_names.get(f"slider-{i}", f"slider-{i}") for i in list(range(27, 58)) + [541]],
        'Value %': slider_values
    })

    if n_clicks is not None and button_id == "btn-download-emissions-tbe":
        df0 = pd.DataFrame(df.iloc[:, 0].to_list(), columns=["Sector"], index=index_range)  # Added column name "Sector"

        # Adjust the columns to start from 2021 and end at 2030
        df1 = pd.DataFrame(df.iloc[:, 1].to_list(),
                           columns=[f'Forecasted {year}' for year in range(2021, 2031)],
                           index=index_range)

        df2 = pd.DataFrame(df.iloc[:, 2].to_list(),
                           columns=[f'Action plan {year}' for year in range(2021, 2031)],
                           index=index_range)

        df_emissions = pd.concat([df0, df1, df2], axis=1)  # This will be stored in the second sheet

        # We'll now save both DataFrames to separate sheets of an Excel file
        filename = f"Emissions-tbe-{mun}-{scenario}.xlsx"
        with pd.ExcelWriter(filename) as writer:
            df_sliders.to_excel(writer, sheet_name="Implemented measures", index=False)
            df_emissions.to_excel(writer, sheet_name="Emissions Data", index=False)

        # Use dcc to send the Excel file as downloadable data
        return dcc.send_file(filename)

    elif n_clicks in [0, None]:
        raise PreventUpdate

    elif button_id != "btn-download-emissions-tbe":
        raise PreventUpdate


@app.callback(
    Output("download-ci-tbe-text", "data"),  # Adjusted for NPV
    [Input("btn-download-ci-tbe", "n_clicks"), Input("dd-ci-value", "data")],  # Adjusted for NPV
    [State("municipality-dropdown", "value")],
    prevent_initial_call=True)
def download_npv_button(n_clicks, value, mun):  # Adjusted function name for NPV
    ctx = dash.callback_context
    button_id = ctx.triggered[0]["prop_id"].split(".")[0]

    if n_clicks is not None and button_id == "btn-download-ci-tbe":  # Adjusted for NPV
        # Create DataFrame from the received data
        df = pd.DataFrame.from_dict(value)

        # If your DataFrame is transposed, you can transpose it back
        # df = df.transpose()

        return dcc.send_data_frame(df.to_csv,
                                   filename=f'Co-benefits-{mun}-{scenario}.csv',  # Adjusted filename for NPV
                                   header=True,
                                   index=False)

    elif n_clicks in [0, None]:
        raise PreventUpdate

    elif button_id != "btn-download-ci-tbe":  # Adjusted for NPV
        raise PreventUpdate

@app.callback(
    [Output("CAPEX-TBE-graph", "figure"), Output("OPEX-TBE-graph", "figure"), Output("SI-TBE-graph", "figure"),
     Output("NPV-TBE-graph", "figure"),Output("dd-capex-value", "data"), Output("dd-opex-value", "data"),Output("dd-si-value", "data"),Output("dd-NPV-value", "data")],
    [Input("municipality-dropdown", "value"), Input("slider-27", "value"), Input("slider-28", "value"),
     Input("slider-29", "value"), Input("slider-30", "value"), Input("slider-31", "value"), Input("slider-32", "value"),
     Input("slider-33", "value"), Input("slider-34", "value"), Input("slider-35", "value"), Input("slider-36", "value"),
     Input("slider-37", "value"), Input("slider-38", "value"), Input("slider-39", "value"), Input("slider-40", "value"),
     Input("slider-41", "value"),Input("slider-42", "value"), Input("slider-43", "value"),
      Input("slider-44", "value"), Input("slider-45", "value"), Input("slider-46", "value"), Input("slider-47", "value"),
      Input("slider-48", "value"), Input("slider-49", "value"), Input("slider-50", "value"), Input("slider-51", "value"),
      Input("slider-52", "value"), Input("slider-53", "value"), Input("slider-54", "value"), Input("slider-55", "value"),
      Input("slider-56", "value"),Input("slider-57", "value"),  Input("ECoutput-dropdown-list", "value"),Input("ECoutput-dropdown-list-2", "value"),Input("NPV-dropdown-list", "value"), Input('int-input', "value")]
)

def render_page_4(mun, agr, cmu, el_bus, ren_bus, current_fuel_bus, air_transp, el_car, act_trans, pt_car, current_fuel_car, ph_car, hydr_car,
                  LBG_heavy, electric_heavy,LBG_light, electric_light,ccsw, wind, rtsolar, csolar, current_energymix, DH_heatpumps, ind_temp_red, sn_measure,
                  BAT_appl, no_heat_measure,CCS_industry,H2_industry, bio_ccs, rewetting_emissions, carbon_credit, ECout, ECout_year, NPV, interest):

    if agr is None:
        agr = 0
    if cmu is None:
        cmu = 0
    if el_bus is None:
        el_bus = 0
    if ren_bus is None:
        ren_bus = 0
    if current_fuel_bus is None:
        current_fuel_bus = 0
    if air_transp is None:
        air_transp = 0
    if el_car is None:
        el_car = 0
    if act_trans is None:
        act_trans = 0
    if pt_car is None:
        pt_car = 0
    if current_fuel_car is None:
        current_fuel_car = 0
    if ph_car is None:
        ph_car = 0
    if hydr_car is None:
        hydr_car = 0
    if LBG_heavy is None:
        LBG_heavy = 0
    if electric_heavy is None:
        electric_heavy = 0
    if LBG_light is None:
        LBG_light = 0
    if electric_light is None:
        electric_light = 0
    if ccsw is None:
        ccsw = 0
    if wind is None:
        wind = 0
    if rtsolar is None:
        rtsolar = 0
    if csolar is None:
        csolar = 0
    if current_energymix is None:
        current_energymix = 0
    if DH_heatpumps is None:
        DH_heatpumps = 0
    if ind_temp_red is None:
        ind_temp_red = 0
    if sn_measure is None:
        sn_measure = 0
    if BAT_appl is None:
        BAT_appl = 0
    if no_heat_measure is None:
        no_heat_measure = 0
    if CCS_industry is None:
        CCS_industry = 0
    if H2_industry is None:
        H2_industry = 0
    if bio_ccs is None:
        bio_ccs = 0
    if rewetting_emissions is None:
        rewetting_emissions = 0
    if carbon_credit is None:
        carbon_credit = 0

    current_fuel_bus = (100 - el_bus - ren_bus)
    current_fuel_car = (100 - el_car - pt_car - ph_car - hydr_car - act_trans)
    current_energymix = (100 - wind - rtsolar - csolar)
    no_heat_measure = (100 - ind_temp_red - sn_measure - BAT_appl)

    if mun is None:
        fig = go.Figure()
        fig.add_annotation(
            x=2.7,
            y=1.8,
            text="Please make sure to select a municipality before proceeding",
            showarrow=False,
            font=dict(size=20),
            bordercolor="#c7c7c7",
            borderwidth=2,
            borderpad=4,
            bgcolor="#ff7f0e",
            opacity=0.8
        )
        return[go.Figure(data=fig),go.Figure(data=fig),go.Figure(data=fig),go.Figure(data=fig),None, None, None, None]

    elif ECout is None:
        fig = go.Figure()  # Create a figure with an empty scatter trace
        fig.add_annotation(
            x=2.7,
            y=1.8,
            text="Please make sure to select an output 1",
            showarrow=False,
            font=dict(size=20),
            bordercolor="#c7c7c7",
            borderwidth=2,
            borderpad=4,
            bgcolor="#ff7f0e",
            opacity=0.8
        )
        return[fig,fig,fig,fig, None, None, None, None]

    elif ECout_year is None:
        fig = go.Figure()  # Create a figure with an empty scatter trace
        fig.add_annotation(
            x=2.7,
            y=1.8,
            text="Please make sure to select an output 2",
            showarrow=False,
            font=dict(size=20),
            bordercolor="#c7c7c7",
            borderwidth=2,
            borderpad=4,
            bgcolor="#ff7f0e",
            opacity=0.8
        )
        return[fig,fig,fig,fig, None, None, None, None]

    elif NPV is None:
        fig = go.Figure()  # Create a figure with an empty scatter trace
        fig.add_annotation(
            x=2.7,
            y=1.8,
            text="Please make sure to select an output 3",
            showarrow=False,
            font=dict(size=20),
            bordercolor="#c7c7c7",
            borderwidth=2,
            borderpad=4,
            bgcolor="#ff7f0e",
            opacity=0.8
        )
        return[fig,fig,fig,fig, None, None, None, None]

    ## ASSUMPTIONS
    EUR_SEK = 11.34
    USD_SEK = 10.39
    GBP_SEK = 12.96
    diesel_price_per_liter = 25
    petrol_price_per_liter = 21
    diesel_price_per_10km = 0.75 * diesel_price_per_liter
    petrol_price_per_10km = 0.74 * petrol_price_per_liter
    Averge_electricity_price = 95.708 / 100  ########### This value has to be manually overwrite if there is change in the database
    electricity_price_in_2022 = (elpriser.loc[str(mun), "Elnät 2022"]) / 100  # column connected from raw sheet
    electric_price_per_10km = (0.22 * electricity_price_in_2022 *10)
    hydrogen_price_per_10km = (9 * electricity_price_in_2022) / (Averge_electricity_price)
    share_of_petrol_cars_in_fossil_fuel_cars = (cars.loc[str(mun), "Cars-petrol"] / (cars.loc[str(mun), "Cars-petrol"] + cars.loc[str(mun), "Cars-diesel"]))
    fossil_fuel_mix_price_per_10km = (petrol_price_per_10km * share_of_petrol_cars_in_fossil_fuel_cars) + (1 - share_of_petrol_cars_in_fossil_fuel_cars) * diesel_price_per_10km
    average_car_distance_per_year = 1112.05641749505  ############## This value has to be manually overwrite if there is change in the database
    average_light_truck_distance_per_year = 1389.2648167721  ############## This value has to be manually overwrite if there is change in the database
    average_heavy_truck_distance_per_year = 4196.60911136108  ############## This value has to be manually overwrite if there is change in the database
    average_bus_distance_per_year = 4973.194758  ############## This value has to be manually overwrite if there is change in the database
    heavy_truck_fuel_consumption_ratio = 4.4
    plug_in_hybrid_emissions_reduction = ((share_of_petrol_cars_in_fossil_fuel_cars * 0.1)/0.16)+ (1-share_of_petrol_cars_in_fossil_fuel_cars)*(0.07/0.14)
    opex_trucks_biogas_extra_cost_ratio = 3.65
    bus_fuel_consumption_per_km = 3.72
    average_car_lifelength = 17
    average_light_truck_lifelength = 17 / 11 * 9
    average_heavy_truck_lifelength = 16
    average_bus_lifelength = 17 / 11 * 6.25
    bus_emissions_reduction_switching_fuel = 0.206896552  ##### this is bit tricky, we can change it later
    charging_station_share_for_hybrid_vs_electric_cars = 0.50
    share_of_new_electric_cars_causing_early_replacement = 0
    share_of_new_electric_trucks_causing_early_replacement = 0
    share_of_new_electric_buses_causing_early_replacement = 0
    emissions_reduction_biogas_heavy_vehicle_vs_diesel = 0.19
    public_transport_cost_per_month = 1273
    bicycle_price = 6875
    share_of_active_transport_reduction_needing_cycling_infrastructure = 0.20
    cycling_infrastructure_need_per_person_to_switch_to_bike = 0.10
    electric_vehicle_price_increase_in_2030 = 1
    public_subsidy_share_of_public_transport = 0.62  ## direct value is consdiered because formula is not connected anywhere within the sheets
    share_of_region_vs_private_operators_bearing_costs_of_greening_bus_fleet = 0.50
    greening_car_fleet_costs_borne_by_citizens = cars.loc[str(mun), "Privates-cars"] / cars.loc[str(mun), "Number of cars"]
    businesses_share_of_flight_transport_costs = 0.75
    aviation_revenue_per_year_in_sweden = 6.005 / 0.221
    cost_increase_of_renewable_bus_fuel_in_buses = 0.10
    number_of_cars_in_the_city = cars.loc[str(mun), "Number of cars"]
    average_purchase_price_of_fossil_fueled_car = 219500  ## direct value - not connected with the CAPEX sheet, not as followed in excel model
    average_purchase_price_of_electric_car_in_start_year = (479000 + average_purchase_price_of_fossil_fueled_car)/2 ## direct value - not connected with the CAPEX sheet, not as followed in excel model
    cycle_path_cost_per_built_kilometer = 14256000  ## direct value - not connected with the CAPEX sheet, not as followed in excel model
    average_purchase_price_of_plug_in_hybrid_car = 299000  ## direct value - not connected with the CAPEX sheet, not as followed in excel model
    residential_electric_car_charger_investment_cost = 4866.833333   ## direct value - not connected with the CAPEX sheet, not as followed in excel model
    average_purchase_price_of_hydrogen_car = 556078.72749373  ## direct value - not connected with the CAPEX sheet, not as followed in excel model
    infrastructure_cost_per_hydrogen_car = 45360  ## direct value - not connected with the CAPEX sheet, not as followed in excel model
    average_purchase_price_of_fossil_fueled_light_truck = 275541.382124297  ## direct value - not connected with the CAPEX sheet, not as followed in excel model
    average_purchase_price_of_electric_light_truck = (average_purchase_price_of_electric_car_in_start_year/average_purchase_price_of_fossil_fueled_car) * average_purchase_price_of_fossil_fueled_light_truck ## direct value - not connected with the CAPEX sheet, not as followed in excel model
    average_purchase_price_of_biogas_light_truck = 275541.38212430
    ## direct value - not connected with the CAPEX sheet, not as followed in excel model
    number_of_light_trucks_in_the_city = cars.loc[str(mun), "Light lorries"]
    number_of_heavy_trucks_in_the_city = cars.loc[str(mun), "Heavy lorries"]
    number_of_buses_in_city = cars.loc[str(mun), "Number of buses"]
    price_of_biogas_heavy_truck = 3168498.06  ## direct value - not connected with the CAPEX sheet, not as followed in excel model
    price_of_electric_heavy_truck = 7620237.8343  ## direct value - not connected with the CAPEX sheet, not as followed in excel model
    price_of_fossil_fueled_heavy_truck = 2664418.82318182  ## direct value - not connected with the CAPEX sheet, not as followed in excel model
    price_of_electric_bus = 5922300  ## direct value - not connected with the CAPEX sheet, not as followed in excel model
    price_of_renewable_bus = 4675500  ## direct value - not connected with the CAPEX sheet, not as followed in excel model
    price_of_fossil_fueled_bus = 4675500  ## direct value - not connected with the CAPEX sheet, not as followed in excel model (same for the following CAPEX values)
    emission_factor_from_electricity_production_sweden = 49
    average_ets_price_in_2022 = 80.32
    watt_to_watt_hour_conversion = 2747.45976874478
    watt_to_watt_hour_conversion_solar = 986.149584487535
    share_of_electricity_and_district_heating_emissions_from_electricity_production = el_shares.loc[str(mun), "El share"]
    share_of_district_heating_covered_by_air_heat_pumps = 1 / 3
    share_of_district_heating_covered_by_water_heat_pumps = 1 / 3
    share_of_district_heating_covered_by_geothermal_heat_pumps = 1 / 3
    air_heat_pump_emissions_saving = 1
    water_heat_pump_emissions_saving = 1
    geothermal_heat_pump_emissions_saving = 1
    public_utility_companies_share_of_green_energy_production_costs = 0.50
    share_of_rooftop_solar_panels_invested_in_by_households = 0.60
    share_of_rooftop_solar_panels_invested_in_by_industry = 0.20
    share_of_rooftop_solar_panels_invested_in_by_municipal_government = 0.20
    opex_share_of_capex_of_lcoe_for_wind_energy = (4 / 20 + 13 / 62) / 2
    opex_share_of_capex_of_lcoe_for_central_solar_power_plant = (11 / 85 + 3 / 21) / 2
    opex_share_of_capex_of_lcoe_for_rooftop_solar_power = (9 / 109 + 14 / 268) / 2
    wind_power_plant_cost_per_kwh = 5.26543228088322
    central_solar_power_plant_cost_per_kwh = 8.869326727418
    rooftop_solar_power_cost_per_kwh = 195000 / 10681
    heat_pump_air_capex = 650
    heat_pump_water_capex = 650
    heat_pump_geothermal_capex = 2300
    district_heating_full_load_hours_per_year = 3000
    emission_factor_from_heat_production = 122
    district_heating_capex_per_kwh_for_heat_pumps = EUR_SEK / district_heating_full_load_hours_per_year * \
                                                    (heat_pump_air_capex * share_of_district_heating_covered_by_air_heat_pumps + \
                                                                heat_pump_water_capex * share_of_district_heating_covered_by_water_heat_pumps \
                                                                + heat_pump_geothermal_capex * share_of_district_heating_covered_by_geothermal_heat_pumps)
    opex_share_of_capex_for_heat_pumps = 0.01
    cost_increase_of_solar_energy_in_2030 = 1
    cost_increase_of_wind_energy_in_2030 = 1
    impact_from_bat_appliances_on_energy_savings = 0.207483
    single_dwelling_energy_savings_of_reduced_indoor_temperature_below_20_degrees = 0.21  ### needs manual change
    multiple_dwelling_energy_savings_of_reduced_indoor_temperature_below_20_degrees = 0.27  ### needs manual change ... MARCUSSSSS
    impact_from_savvidou_nykvist_measures_on_energy_savings = 0.17  # ((dwellings_ownership.loc[str(mun), "housing cooperatives":"private persons"].sum())*(((reduced_hotwater_consumption_SD+retrofitting_renovation_SD)/2)*(dwellings_size.loc[str(mun), "1-2 dwelling"]/dwellings_size.loc[str(mun), "Total"])*((reduced_hotwater_consumption_MD+retrofitting_renovation_MD)/2)*(dwellings_size.loc[str(mun), "Multi-dwelling"]/dwellings_size.loc[str(mun), "Total"])))
    impact_from_reduced_temperature_to_20_degrees_on_energy_savings = 0.16
    total_building_stock_in_municipality = dwellings_stock.loc[str(mun), "Housing stock"]
    capex_for_bat_investments = 82857  ## needs manual change
    energy_consumption_for_apartment_building = 3500
    energy_consumption_for_house = 8000
    energy_cost_per_year_in_municipality = float((energy_consumption_for_apartment_building * (dwellings_ratio.loc[str(mun), "1,2 Dwellings"])+energy_consumption_for_house * (dwellings_ratio.loc[str(mun), "Multiple dwellings"]))*electricity_price_in_2022)
    capex_of_implementing_sn_measures = float((((1.03*679*0.24)+((1283+1256)*0.84)+(1367+7895)*0.15)*((dwellings_size.loc[str(mun), "1-2 dwelling"])/(dwellings_size.loc[str(mun), "Total"])))+((1-dwellings_size.loc[str(mun), "1-2 dwelling"])/(dwellings_size.loc[str(mun), "Total"]))*((0.38*679*0.24)+((1283+1256)*0.51)+(1367+7895)*0.13))
    share_of_city_landfill_site_waste_from_same_city = 1
    share_of_agricultural_emissions_related_to_methane = 0.53
    ccs_capture_share_of_emissions = 0.90
    fossil_free_share_of_electricity_mix_in_city = 1
    income_per_collected_ton_of_co2e = 0.00
    share_of_emissions_reduced_by_hydrogen_industry = 1
    opex_share_of_total_costs_of_hydrogen_in_a_year = electricity_price_in_2022 / Averge_electricity_price * (3.4 / 8.4 + 3.1 / 4.1) / 2 / 15
    abatement_cost_of_hydrogen_per_ton_of_co2e_removed = (530 + 1345) / 2
    share_of_carbon_credits_counted_towards_negative_emissions_in_net_zero_target = 1
    share_of_bio_ccs_counted_towards_negative_emissions_in_net_zero_target = 1
    share_of_rewetting_counted_towards_negative_emissions_in_net_zero_target = 1
    share_of_rewetting_paid_by_agricultural_industry = 0.5
    share_of_rewetting_paid_by_superordinate_government = 0.25
    share_of_rewetting_paid_by_municipal_government = 0.25
    average_cost_of_beccs = (64 + 108 + 105 + 205 + 64 + 189 + 54 + 173) / 8
    average_cost_of_daccs = (214 + 1071 + 95 + 214) / 4
    share_of_negative_emission_tech_related_to_beccs = 1
    share_of_beccs_costs_related_to_opex_on_annual_basis = (0.4 + 0.5 * 0.3) / 25
    operating_cost_of_ccs_per_captured_ton_of_co2 = 799.47
    capital_cost_of_ccs_per_ton = 3997.35
    cost_increase_of_bio_ccs_in_2030 = 1
    investment_cost_of_rewetting_wetlands = 0
    cost_per_ton_of_co2e_of_rewetting_wetlands = 175
    share_of_rewetting_paid_by_industry = 0.20
    share_of_rewetting_paid_by_superordinate_government = 0.25
    cost_per_ton_of_carbon_credit_compensation = 623.4
    investment_cost_of_rewetting_wetlands_in_lake_or_agricultural_area = 965
    investment_cost_of_rewetting_wetlands_in_forest = 698
    operating_cost_of_rewetting_wetlands_in_lake_or_agricultural_area = 351
    operating_cost_of_rewetting_wetlands_in_forest = 508
    income_of_rewetting_wetlands_in_lake_or_agricultural_area = 0
    income_of_rewetting_wetlands_in_forest = 0
    share_of_rewetting_in_forest_land = 0.33  # represented as a fraction (33% = 0.33)
    average_investment_cost_of_agricultural_measure_per_reduced_tCO2e = 5804
    average_OPEX_of_agricultural_measure_per_reduced_tCO2e = 0
    average_income_of_agricultural_measure_per_reduced_tCO2e = 0
    average_saving_of_agricultural_measure_per_reduced_tCO2e = 0
    average_investment_cost_of_work_machine_measure_per_reduced_tCO2e = 4831
    average_OPEX_of_work_machine_measure_per_reduced_tCO2e = 0
    average_income_of_work_machine_measure_per_reduced_tCO2e = 0
    average_saving_of_work_machine_measure_per_reduced_tCO2e = 0

    ###################  Final Output   ######################

    levers = {
        "Electric cars": el_car / 100,
        "Active transport": act_trans / 100,
        "Reduced car use": pt_car / 100,
        "Plug in hybrid cars": ph_car / 100,
        "Hydrogen cars": hydr_car / 100,
        "Light trucks biogas": LBG_light / 100,
        "Light trucks electric": electric_light / 100,
        "Heavy trucks biogas": LBG_heavy / 100,
        "Heavy trucks electric": electric_heavy / 100,
        "Electric bus": el_bus / 100,
        "HVO bus": ren_bus / 100,
        "Reduced flights": air_transp / 100,
        "Wind": wind / 100,
        "Solar park": csolar / 100,
        "Solar roof": rtsolar / 100,
        "Bio-CCS": bio_ccs / 100,
        "CCS industry": CCS_industry / 100,
        "CCS waste": ccsw / 100,
        "Hydrogen industry": H2_industry / 100,
        "BAT household items": BAT_appl / 100,
        "Indoor temperature": ind_temp_red / 100,
        "EE measures": sn_measure / 100,
        "Rewetting": rewetting_emissions / 100,
        "Methane mgmt": agr / 100,
        "Carbon credits": carbon_credit / 100,
        "Heat pump DH": DH_heatpumps / 100,
        "Recycling": cmu / 100
    }
    # Other attributes
    capex_opex = ['CAPEX', 'OPEX', 'Savings', 'Income']
    actors = ['Citizens', 'Industry', 'Municipal governments', 'Superordinate governments', 'Utility companies',
              'Financial institutions', 'Civil society']
    year = list(range(2021, 2031))

    # Generate all combinations
    combinations = list(itertools.product(levers.keys(), capex_opex, actors, year))

    # Create the DataFrame
    economic_db = pd.DataFrame(combinations, columns=['Lever', 'Cost type', 'Actor', 'Year'])

    # Electric cars:
    electric_cars_citizens = greening_car_fleet_costs_borne_by_citizens  # This comes from the assumptions sheet
    electric_cars_MG = 0.02
    electric_cars_industry = 1 - (electric_cars_citizens + electric_cars_MG)
    electric_cars_SG = 0
    electric_cars_UC = 0
    electric_cars_FI = 0
    electric_cars_CS = 0

    # Active transport:
    active_transport_citizens = 0
    active_transport_industry = 0
    active_transport_MG = 1
    active_transport_SG = 0
    active_transport_UC = 0
    active_transport_FI = 0
    active_transport_CS = 0

    # Reduced car use:
    reduced_car_use_citizens = greening_car_fleet_costs_borne_by_citizens
    reduced_car_use_industry = electric_cars_industry
    reduced_car_use_MG = 0.02
    reduced_car_use_SG = 0
    reduced_car_use_UC = 0
    reduced_car_use_FI = 0
    reduced_car_use_CS = 0

    # Plug-in hybrid cars:
    plugin_hybrid_cars_citizens = greening_car_fleet_costs_borne_by_citizens
    plugin_hybrid_cars_MG = 0.02
    plugin_hybrid_cars_industry = 1 - (plugin_hybrid_cars_citizens + plugin_hybrid_cars_MG)
    plugin_hybrid_cars_SG = 0
    plugin_hybrid_cars_UC = 0
    plugin_hybrid_cars_FI = 0
    plugin_hybrid_cars_CS = 0

    # Hydrogen cars:
    hydrogen_cars_citizens = greening_car_fleet_costs_borne_by_citizens
    hydrogen_cars_MG = 0.02
    hydrogen_cars_industry = 1 - (hydrogen_cars_citizens + hydrogen_cars_MG)
    hydrogen_cars_SG = 0
    hydrogen_cars_UC = 0
    hydrogen_cars_FI = 0
    hydrogen_cars_CS = 0

    # Light trucks biogas:
    light_trucks_biogas_citizens = 0.02
    light_trucks_biogas_industry = 0.95
    light_trucks_biogas_MG = 0.03
    light_trucks_biogas_SG = 0
    light_trucks_biogas_UC = 0
    light_trucks_biogas_FI = 0
    light_trucks_biogas_CS = 0

    # Light trucks electric:
    light_trucks_electric_citizens = 0.02
    light_trucks_electric_industry = 0.95
    light_trucks_electric_MG = 0.03
    light_trucks_electric_SG = 0
    light_trucks_electric_UC = 0
    light_trucks_electric_FI = 0
    light_trucks_electric_CS = 0

    # Heavy trucks biogas:
    heavy_trucks_biogas_citizens = 0
    heavy_trucks_biogas_industry = 0.98
    heavy_trucks_biogas_MG = 0.02
    heavy_trucks_biogas_SG = 0
    heavy_trucks_biogas_UC = 0
    heavy_trucks_biogas_FI = 0
    heavy_trucks_biogas_CS = 0

    # Heavy trucks electric:
    heavy_trucks_electric_citizens = 0
    heavy_trucks_electric_industry = 0.98
    heavy_trucks_electric_MG = 0.02
    heavy_trucks_electric_SG = 0
    heavy_trucks_electric_UC = 0
    heavy_trucks_electric_FI = 0
    heavy_trucks_electric_CS = 0

    # Electric bus:
    electric_bus_citizens = 1 - public_subsidy_share_of_public_transport
    electric_bus_industry = (1 - electric_bus_citizens) * (1 - share_of_region_vs_private_operators_bearing_costs_of_greening_bus_fleet)
    electric_bus_MG = 0
    electric_bus_SG = electric_bus_industry
    electric_bus_UC = 0
    electric_bus_FI = 0
    electric_bus_CS = 0

    # HVO bus:
    hvo_bus_citizens = 1 - public_subsidy_share_of_public_transport
    hvo_bus_industry = (1 - hvo_bus_citizens) / 2
    hvo_bus_MG = 0
    hvo_bus_SG = hvo_bus_industry
    hvo_bus_UC = 0
    hvo_bus_FI = 0
    hvo_bus_CS = 0

    # Reduced flights:
    reduced_flights_citizens = (1 - businesses_share_of_flight_transport_costs)
    reduced_flights_industry = businesses_share_of_flight_transport_costs
    reduced_flights_MG = 0
    reduced_flights_SG = 0
    reduced_flights_UC = 0
    reduced_flights_FI = 0
    reduced_flights_CS = 0

    # Wind:
    wind_citizens = 0
    wind_UC = public_utility_companies_share_of_green_energy_production_costs
    wind_industry = 1 - wind_UC
    wind_MG = 0
    wind_SG = 0
    wind_FI = 0
    wind_CS = 0

    # Solar park:
    solar_park_citizens = 0
    solar_park_UC = public_utility_companies_share_of_green_energy_production_costs
    solar_park_industry = 1 - solar_park_UC
    solar_park_MG = 0
    solar_park_SG = 0
    solar_park_FI = 0
    solar_park_CS = 0

    # Solar roof:
    solar_roof_citizens = share_of_rooftop_solar_panels_invested_in_by_households
    solar_roof_industry = share_of_rooftop_solar_panels_invested_in_by_industry
    solar_roof_MG = share_of_rooftop_solar_panels_invested_in_by_municipal_government
    solar_roof_SG = 0
    solar_roof_UC = 0
    solar_roof_FI = 0
    solar_roof_CS = 0

    # Bio-CCS:
    bio_ccs_citizens = 0
    bio_ccs_industry = 1
    bio_ccs_MG = 0
    bio_ccs_SG = 0
    bio_ccs_UC = 0
    bio_ccs_FI = 0
    bio_ccs_CS = 0

    # CCS industry:
    ccs_industry_citizens = 0
    ccs_industry_industry = 1
    ccs_industry_MG = 0
    ccs_industry_SG = 0
    ccs_industry_UC = 0
    ccs_industry_FI = 0
    ccs_industry_CS = 0

    # CCS waste:
    ccs_waste_citizens = 0
    ccs_waste_industry = 1
    ccs_waste_MG = 0
    ccs_waste_SG = 0
    ccs_waste_UC = 0
    ccs_waste_FI = 0
    ccs_waste_CS = 0

    # Hydrogen industry:
    hydrogen_industry_citizens = 0
    hydrogen_industry_industry = 1
    hydrogen_industry_MG = 0
    hydrogen_industry_SG = 0
    hydrogen_industry_UC = 0
    hydrogen_industry_FI = 0
    hydrogen_industry_CS = 0

    # BAT household items: ############it is connected with raw sheet ownership_dwelling (columns E and F are summed together (housing cooperative and Private person), G and A&B )
    BAT_household_items_citizens = (dwellings_ownership.loc[str(mun), "housing cooperatives":"private persons"].sum())
    BAT_household_items_industry = (dwellings_ownership.loc[str(mun), "Swedish joint-stock companies"])
    BAT_household_items_UC = (dwellings_ownership.loc[str(mun), "state, municipal, region":"municipal housing companies"].sum())
    BAT_household_items_MG = 1 - (BAT_household_items_citizens + BAT_household_items_industry + BAT_household_items_UC)
    BAT_household_items_SG = 0
    BAT_household_items_FI = 0
    BAT_household_items_CS = 0

    # Indoor temperature:
    indoor_temperature_citizens = BAT_household_items_citizens
    indoor_temperature_industry = BAT_household_items_industry
    indoor_temperature_MG = BAT_household_items_MG
    indoor_temperature_SG = 0
    indoor_temperature_UC = BAT_household_items_UC
    indoor_temperature_FI = 0
    indoor_temperature_CS = 0

    # EE measures:
    EE_measures_citizens = BAT_household_items_citizens
    EE_measures_industry = BAT_household_items_industry
    EE_measures_MG = BAT_household_items_MG
    EE_measures_SG = 0
    EE_measures_UC = BAT_household_items_UC
    EE_measures_FI = 0
    EE_measures_CS = 0

    # Rewetting:
    rewetting_citizens = 0
    rewetting_industry = share_of_rewetting_paid_by_agricultural_industry
    rewetting_MG = share_of_rewetting_paid_by_municipal_government
    rewetting_SG = share_of_rewetting_paid_by_superordinate_government
    rewetting_UC = 0
    rewetting_FI = 0
    rewetting_CS = 0

    # Methane mgmt:
    methane_mgmt_citizens = 0
    methane_mgmt_industry = 1
    methane_mgmt_MG = 0
    methane_mgmt_SG = 0
    methane_mgmt_UC = 0
    methane_mgmt_FI = 0
    methane_mgmt_CS = 0

    # Carbon credits:
    carbon_credits_citizens = 0
    carbon_credits_industry = 0
    carbon_credits_MG = 1
    carbon_credits_SG = 0
    carbon_credits_UC = 0
    carbon_credits_FI = 0
    carbon_credits_CS = 0

    # Heat pump DH:
    heat_pump_DH_citizens = 0
    heat_pump_DH_industry = 1 - public_utility_companies_share_of_green_energy_production_costs
    heat_pump_DH_MG = 0
    heat_pump_DH_SG = 0
    heat_pump_DH_UC = public_utility_companies_share_of_green_energy_production_costs
    heat_pump_DH_FI = 0
    heat_pump_DH_CS = 0

    # Recycling:
    recycling_citizens = 0.5
    recycling_industry = 0.5
    recycling_MG = 0
    recycling_SG = 0
    recycling_UC = 0
    recycling_FI = 0
    recycling_CS = 0

    all_levers = list(levers.keys())
    # actors_levers_df
    data = {
        'Lever': all_levers,
        'Citizens': [
           electric_cars_citizens, active_transport_citizens ,reduced_car_use_citizens, plugin_hybrid_cars_citizens, hydrogen_cars_citizens, light_trucks_biogas_citizens, light_trucks_electric_citizens, heavy_trucks_biogas_citizens, heavy_trucks_electric_citizens,
           electric_bus_citizens,hvo_bus_citizens, reduced_flights_citizens,wind_citizens, solar_park_citizens,solar_roof_citizens, bio_ccs_citizens, ccs_industry_citizens, ccs_waste_citizens,hydrogen_industry_citizens,BAT_household_items_citizens,indoor_temperature_citizens,
           EE_measures_citizens, rewetting_citizens,methane_mgmt_citizens,carbon_credits_citizens,heat_pump_DH_citizens, recycling_citizens
        ],
        'Industry': [
            electric_cars_industry , active_transport_industry, reduced_car_use_industry, plugin_hybrid_cars_industry, hydrogen_cars_industry, light_trucks_biogas_industry,light_trucks_electric_industry, heavy_trucks_biogas_industry,heavy_trucks_electric_industry,
            electric_bus_industry,hvo_bus_industry,reduced_flights_industry, wind_industry, solar_park_industry,solar_roof_industry, bio_ccs_industry, ccs_industry_industry, ccs_waste_industry, hydrogen_industry_industry,BAT_household_items_industry,indoor_temperature_industry,
            EE_measures_industry, rewetting_industry, methane_mgmt_industry, carbon_credits_industry, heat_pump_DH_industry, recycling_industry
        ],
        'Municipal governments': [
            electric_cars_MG, active_transport_MG, reduced_car_use_MG, plugin_hybrid_cars_MG, hydrogen_cars_MG, light_trucks_biogas_MG, light_trucks_electric_MG, heavy_trucks_biogas_MG, heavy_trucks_electric_MG,
            electric_bus_MG, hvo_bus_MG, reduced_flights_MG, wind_MG, solar_park_MG,solar_roof_MG, bio_ccs_MG, ccs_industry_MG, ccs_waste_MG, hydrogen_industry_MG, BAT_household_items_MG, indoor_temperature_MG,
            EE_measures_MG, rewetting_MG, methane_mgmt_MG, carbon_credits_MG, heat_pump_DH_MG, recycling_MG
        ],
        'Superordinate governments': [
            electric_cars_SG , active_transport_SG, reduced_car_use_SG, plugin_hybrid_cars_SG, hydrogen_cars_SG, light_trucks_biogas_SG, light_trucks_electric_SG, heavy_trucks_biogas_SG, heavy_trucks_electric_SG,
            electric_bus_SG, hvo_bus_SG, reduced_flights_SG, wind_SG, solar_park_SG, solar_roof_SG, bio_ccs_SG, ccs_industry_SG, ccs_waste_SG, hydrogen_industry_SG, BAT_household_items_SG, indoor_temperature_SG,
            EE_measures_SG, rewetting_SG, methane_mgmt_SG, carbon_credits_SG, heat_pump_DH_SG, recycling_SG
        ],
        'Utility companies': [
            electric_cars_UC , active_transport_UC, reduced_car_use_UC, plugin_hybrid_cars_UC, hydrogen_cars_UC, light_trucks_biogas_UC, light_trucks_electric_UC, heavy_trucks_biogas_UC, heavy_trucks_electric_UC,
            electric_bus_UC, hvo_bus_UC, reduced_flights_UC, wind_UC, solar_park_UC, solar_roof_UC, bio_ccs_UC, ccs_industry_UC, ccs_waste_UC, hydrogen_industry_UC, BAT_household_items_UC,indoor_temperature_UC,
            EE_measures_UC, rewetting_UC, methane_mgmt_UC, carbon_credits_UC, heat_pump_DH_UC, recycling_UC
        ],
        'Financial institutions': [
            electric_cars_FI , active_transport_FI, reduced_car_use_FI, plugin_hybrid_cars_FI, hydrogen_cars_FI, light_trucks_biogas_FI, light_trucks_electric_FI, heavy_trucks_biogas_FI, heavy_trucks_electric_FI,
            electric_bus_FI, hvo_bus_FI,reduced_flights_FI, wind_FI, solar_park_FI,solar_roof_FI, bio_ccs_FI, ccs_industry_FI,ccs_waste_FI, hydrogen_industry_FI, BAT_household_items_FI, indoor_temperature_FI,
            EE_measures_FI, rewetting_FI,methane_mgmt_FI, carbon_credits_FI, heat_pump_DH_FI, recycling_FI
        ],
        'Civil society': [
            electric_cars_CS, active_transport_CS, reduced_car_use_CS, plugin_hybrid_cars_CS, hydrogen_cars_CS, light_trucks_biogas_CS, light_trucks_electric_CS, heavy_trucks_biogas_CS, heavy_trucks_electric_CS,
            electric_bus_CS, hvo_bus_CS, reduced_flights_CS, wind_CS, solar_park_CS,solar_roof_CS, bio_ccs_CS, ccs_industry_CS,ccs_waste_CS, hydrogen_industry_CS, BAT_household_items_CS, indoor_temperature_CS,
            EE_measures_CS, rewetting_CS,methane_mgmt_CS, carbon_credits_CS, heat_pump_DH_CS, recycling_CS
        ]
    }

    actors_levers_df = pd.DataFrame(data)

    # Actors levers into db
    original_df = pd.DataFrame(actors_levers_df, columns=['Lever', 'Citizens', 'Industry', 'Municipal governments',
                                                          'Superordinate governments', 'Utility companies',
                                                          'Financial institutions', 'Civil society'])

    # Create an empty DataFrame to store the result
    result_df = pd.DataFrame(columns=['Lever', 'Actor', 'Value'])

    # Loop through each row in the original DataFrame
    for index, row in original_df.iterrows():
        lever = row['Lever']
        # Loop through each actor column and its corresponding value
        for actor in original_df.columns[1:]:
            actor_value = row[actor]
            with warnings.catch_warnings():
                warnings.simplefilter("ignore", category=FutureWarning)
                # Append a new row with the lever, actor, and value
                result_df.loc[len(result_df)] = {'Lever': lever, 'Actor': actor, 'Value': actor_value}

    actors_levers_df_db = result_df
    #print (actors_levers_df_db)

    # Melt the DataFrame to prepare it for the stacked bar chart
    # Melt the DataFrame to prepare it for the stacked bar chart
    actors_levers_melted_df = actors_levers_df_db.melt(id_vars=['Lever', 'Actor'], var_name='Category',value_name='Actor_Value')

    # Create a stacked bar chart using Plotly Express
    fig = px.bar(actors_levers_melted_df,
                 x='Lever',
                 y='Actor_Value',
                 color='Actor',
                 title='Distribution of Actors Across Different Levers',
                 labels={'Lever': 'Levers'},
                 height=600,
                 width=1200)

    # Rotate the x-axis labels for better visibility
    fig.update_layout(xaxis_tickangle=-45)

    # Show the plot
    # return [fig]

    # Create the DataFrame for timing levers
    years = list(range(2021, 2031))
    data = {'Lever': all_levers, '2021': [0.0] * len(all_levers)}

    for year in years:
        lever_values = [(levers[lever] / 9) * (year - 2021) for lever in all_levers]
        data[str(year)] = lever_values

    timing_levers_df = pd.DataFrame(data)
    change_df = timing_levers_df.copy()
    change_df.iloc[:, 1:] = timing_levers_df.iloc[:, 1:].diff(axis=1).fillna(0)

    # CREATING TIMING LEVERS CAPEX
    timing_levers_df_capex = change_df

    # Convert the provided table into a DataFrame
    provided_df = pd.DataFrame(timing_levers_df_capex)

    # Create an empty DataFrame to store the result
    result_df = pd.DataFrame(columns=['Lever', 'Year', 'Cost type', 'Melted_Value'])  # Rename 'Value' to 'Melted_Value'

    for index, row in provided_df.iterrows():
        lever = row['Lever']
        for year in provided_df.columns[1:]:
            sek_value = row[year]
            with warnings.catch_warnings():
                warnings.simplefilter("ignore", category=FutureWarning)
                result_df.loc[len(result_df)] = [lever, int(year), 'CAPEX', sek_value]

    timing_levers_df_capex_db = result_df
    #print (timing_levers_df_capex_db)
    # Melt the DataFrame for visualization
    timing_levers_df_capex_melted = timing_levers_df_capex_db.melt(id_vars=['Lever', 'Year'],value_vars=['Melted_Value'], var_name='Cost type',value_name='Value')

    # Filter for the desired years
    years_range = range(2021, 2031)
    timing_levers_df_capex_melted_filtered = timing_levers_df_capex_melted[
        timing_levers_df_capex_melted['Year'].isin(years_range)]

    # Create the line chart
    fig = px.line(timing_levers_df_capex_melted_filtered, x="Year", y="Value", color="Lever",title="Projection of Levers from 2020 to 2030 (CAPEX)")
    fig.update_xaxes(type='category')  # Ensure the years are treated as categories
    #return [fig]

    # OPEX is taken from this table:
    cumulative_df = timing_levers_df_capex.copy()
    cumulative_df.iloc[:, 2:] = change_df.iloc[:, 2:].cumsum(axis=1)

    # CREATING TIMING LEVERS OPEX
    timing_levers_df_opex = cumulative_df

    # Convert the provided table into a DataFrame
    provided_df_opex = pd.DataFrame(timing_levers_df_opex)

    # Create an empty DataFrame to store the result
    result_df_opex = pd.DataFrame(columns=['Lever', 'Year', 'Cost type', 'Value'])

    for index, row in provided_df_opex.iterrows():
        lever = row['Lever']
        for year in provided_df_opex.columns[1:]:
            sek_value = row[year]
            with warnings.catch_warnings():
                warnings.simplefilter("ignore", category=FutureWarning)
                result_df_opex = pd.concat([result_df_opex, pd.DataFrame({'Lever': [lever], 'Year': [int(year)], 'Cost type': ['OPEX'], 'Value': [sek_value]})],ignore_index=True)

    timing_levers_df_opex_db = result_df_opex
    #print (timing_levers_df_opex_db)
    # Melt the DataFrame for visualization
    timing_levers_df_opex_melted = timing_levers_df_opex_db.melt(id_vars=['Lever', 'Year', 'Cost type'],value_vars=['Value'], var_name='Dummy',value_name='Melted_Value')

    # Filter for the desired years
    timing_levers_df_opex_melted_filtered = timing_levers_df_opex_melted[timing_levers_df_opex_melted['Year'].isin(years_range)]

    # Create the line chart for OPEX
    fig_opex = px.line(timing_levers_df_opex_melted_filtered, x="Year", y="Melted_Value", color="Lever", title="Projection of Levers from 2020 to 2030 (OPEX)")
    fig_opex.update_xaxes(type='category')  # Ensure the years are treated as categories

    #return [fig_opex]

    # Convert the provided table into a DataFrame
    provided_df = pd.DataFrame(timing_levers_df_opex)

    # Create an empty list to store the dictionaries
    savings_data = []

    for index, row in provided_df.iterrows():
        lever = row['Lever']
        for year in provided_df.columns[1:]:
            sek_value = row[year]
            with warnings.catch_warnings():
                warnings.simplefilter("ignore", category=FutureWarning)
                savings_data.append({'Lever': lever, 'Year': int(year),'Cost type': 'Savings', 'Value': sek_value})

    # Create the DataFrame from the list of dictionaries
    timing_levers_df_savings_db = pd.DataFrame(savings_data)
    #print (timing_levers_df_savings_db)

    # Melt the DataFrame for visualization
    timing_levers_df_savings_melted = timing_levers_df_savings_db.melt(id_vars=['Lever', 'Year', 'Cost type'],value_vars=['Value'], var_name='Dummy',value_name='Melted_Value')

    # Filter for the desired years
    years_range = range(2021, 2031)
    timing_levers_df_savings_melted_filtered = timing_levers_df_savings_melted[timing_levers_df_savings_melted['Year'].isin(years_range)]

    # Create the line chart for Savings
    fig_savings = px.line(timing_levers_df_savings_melted_filtered, x="Year", y="Melted_Value", color="Lever",title="Projection of Levers from 2020 to 2030 (Savings)")
    fig_savings.update_xaxes(type='category')  # Ensure the years are treated as categories
    #return [fig_savings]

    # Convert the provided table into a DataFrame
    provided_df = pd.DataFrame(timing_levers_df_opex)

    # Create an empty list to store the dictionaries
    income_data = []

    for index, row in provided_df.iterrows():
        lever = row['Lever']
        for year in provided_df.columns[1:]:
            sek_value = row[year]
            with warnings.catch_warnings():
                warnings.simplefilter("ignore", category=FutureWarning)
                income_data.append({'Lever': lever, 'Year': int(year),
                                    'Cost type': 'Income', 'Value': sek_value})

    # Create the DataFrame from the list of dictionaries
    timing_levers_df_income_db = pd.DataFrame(income_data)
    #print (timing_levers_df_income_db)

    # Melt the DataFrame for visualization
    timing_levers_df_income_melted = timing_levers_df_income_db.melt(id_vars=['Lever', 'Year', 'Cost type'],value_vars=['Value'], var_name='Dummy',value_name='Melted_Value')

    # Filter for the desired years
    timing_levers_df_income_melted_filtered = timing_levers_df_income_melted[timing_levers_df_income_melted['Year'].isin(years_range)]

    # Create the line chart for Income
    fig_income = px.line(timing_levers_df_income_melted_filtered, x="Year", y="Melted_Value", color="Lever",title="Projection of Levers from 2020 to 2030 (Income)")
    fig_income.update_xaxes(type='category')  # Ensure the years are treated as categories

    # If you want to return both the Savings and Income charts, you can do:
    #return [fig_income]

    # capex_opex_df
    # CAPEX OPEX DB

    capex_opex_df = {
        'Lever': all_levers,
        'Unit': [None] * 27,
        'CAPEX': [None] * 27,
        'OPEX': [None] * 27,
        'Savings': [None] * 27,
        'Income': [None] * 27
    }

    capex_opex_df = pd.DataFrame(capex_opex_df)

    capex_opex_df = pd.DataFrame(capex_opex_df)

    capex_opex_df.at[0, 'Unit'] = number_of_cars_in_the_city
    capex_opex_df.at[0, 'CAPEX'] = share_of_new_electric_cars_causing_early_replacement * (average_purchase_price_of_electric_car_in_start_year + residential_electric_car_charger_investment_cost) + ((1 - share_of_new_electric_cars_causing_early_replacement) * (
                                           average_purchase_price_of_electric_car_in_start_year+ residential_electric_car_charger_investment_cost - average_purchase_price_of_fossil_fueled_car))
    capex_opex_df.at[0, 'OPEX'] = electric_price_per_10km * average_car_distance_per_year
    capex_opex_df.at[0, 'Savings'] = (share_of_petrol_cars_in_fossil_fuel_cars * petrol_price_per_10km +(1 - share_of_petrol_cars_in_fossil_fuel_cars) * diesel_price_per_10km) * average_car_distance_per_year * -1
    capex_opex_df.at[0, 'Income'] = 0

    capex_opex_df.at[1, 'Unit'] = average_car_lifelength
    capex_opex_df.at[1, 'CAPEX'] = average_purchase_price_of_fossil_fueled_car * -1 + bicycle_price + cycle_path_cost_per_built_kilometer \
                      * share_of_active_transport_reduction_needing_cycling_infrastructure \
                      * cycling_infrastructure_need_per_person_to_switch_to_bike
    capex_opex_df.at[1, 'OPEX'] = 0
    capex_opex_df.at[1, 'Savings'] = (share_of_petrol_cars_in_fossil_fuel_cars * petrol_price_per_10km +(1 - share_of_petrol_cars_in_fossil_fuel_cars) * diesel_price_per_10km) * average_car_distance_per_year * -1
    capex_opex_df.at[1, 'Income'] = 0

    capex_opex_df.at[2, 'Unit'] = number_of_cars_in_the_city
    capex_opex_df.at[2, 'CAPEX'] = - average_purchase_price_of_fossil_fueled_car
    capex_opex_df.at[2, 'OPEX'] = public_transport_cost_per_month * 10
    capex_opex_df.at[2, 'Savings'] = (share_of_petrol_cars_in_fossil_fuel_cars * petrol_price_per_10km +(1 - share_of_petrol_cars_in_fossil_fuel_cars) * diesel_price_per_10km) * average_car_distance_per_year * -1
    capex_opex_df.at[2, 'Income'] = 0

    capex_opex_df.at[3, 'Unit'] = number_of_cars_in_the_city
    capex_opex_df.at[3, 'CAPEX'] = ((average_purchase_price_of_plug_in_hybrid_car + residential_electric_car_charger_investment_cost * charging_station_share_for_hybrid_vs_electric_cars) - average_purchase_price_of_fossil_fueled_car) \
                                   * (1 - share_of_new_electric_cars_causing_early_replacement) + ((average_purchase_price_of_plug_in_hybrid_car + residential_electric_car_charger_investment_cost * charging_station_share_for_hybrid_vs_electric_cars)) \
                                   * (share_of_new_electric_cars_causing_early_replacement)
    capex_opex_df.at[3, 'OPEX'] = ((share_of_petrol_cars_in_fossil_fuel_cars * petrol_price_per_10km +(1 - share_of_petrol_cars_in_fossil_fuel_cars) * diesel_price_per_10km) * average_car_distance_per_year) * plug_in_hybrid_emissions_reduction
    capex_opex_df.at[3, 'Savings'] = (share_of_petrol_cars_in_fossil_fuel_cars * petrol_price_per_10km +(1 - share_of_petrol_cars_in_fossil_fuel_cars) * diesel_price_per_10km) * average_car_distance_per_year * -1
    capex_opex_df.at[3, 'Income'] = 0

    capex_opex_df.at[4, 'Unit'] = number_of_cars_in_the_city
    capex_opex_df.at[4, 'CAPEX'] = ((average_purchase_price_of_hydrogen_car + infrastructure_cost_per_hydrogen_car)
                                    - average_purchase_price_of_fossil_fueled_car) * (1 - share_of_new_electric_cars_causing_early_replacement) + \
                                   ((average_purchase_price_of_hydrogen_car + infrastructure_cost_per_hydrogen_car)) \
                                   * (share_of_new_electric_cars_causing_early_replacement)
    capex_opex_df.at[4, 'OPEX'] = hydrogen_price_per_10km * average_car_distance_per_year
    capex_opex_df.at[4, 'Savings'] = (share_of_petrol_cars_in_fossil_fuel_cars * petrol_price_per_10km +(1 - share_of_petrol_cars_in_fossil_fuel_cars) * diesel_price_per_10km) * average_car_distance_per_year * -1
    capex_opex_df.at[4, 'Income'] = 0

    capex_opex_df.at[5, 'Unit'] = number_of_light_trucks_in_the_city
    capex_opex_df.at[5, 'CAPEX'] = (average_purchase_price_of_biogas_light_truck - average_purchase_price_of_fossil_fueled_light_truck) * (1 - share_of_new_electric_trucks_causing_early_replacement) + \
                                   (average_purchase_price_of_biogas_light_truck) * (share_of_new_electric_trucks_causing_early_replacement)
    capex_opex_df.at[5, 'OPEX'] = average_light_truck_distance_per_year * (fossil_fuel_mix_price_per_10km + opex_trucks_biogas_extra_cost_ratio)
    capex_opex_df.at[5, 'Savings'] = average_light_truck_distance_per_year * fossil_fuel_mix_price_per_10km * -1
    capex_opex_df.at[5, 'Income'] = 0

    capex_opex_df.at[6, 'Unit'] = number_of_light_trucks_in_the_city
    capex_opex_df.at[6, 'CAPEX'] = ((average_purchase_price_of_electric_light_truck + residential_electric_car_charger_investment_cost)
                                    - average_purchase_price_of_fossil_fueled_light_truck) * (1 - share_of_new_electric_trucks_causing_early_replacement) + \
                                   ((average_purchase_price_of_electric_light_truck + residential_electric_car_charger_investment_cost)) * \
                                   (share_of_new_electric_trucks_causing_early_replacement)
    capex_opex_df.at[6, 'OPEX'] = average_light_truck_distance_per_year * electric_price_per_10km
    capex_opex_df.at[6, 'Savings'] = average_light_truck_distance_per_year * fossil_fuel_mix_price_per_10km * -1
    capex_opex_df.at[6, 'Income'] = 0

    capex_opex_df.at[7, 'Unit'] = number_of_heavy_trucks_in_the_city
    capex_opex_df.at[7, 'CAPEX'] = (price_of_biogas_heavy_truck - price_of_fossil_fueled_heavy_truck) * \
                                   (1 - share_of_new_electric_trucks_causing_early_replacement) + (price_of_biogas_heavy_truck) * \
                                   share_of_new_electric_trucks_causing_early_replacement
    capex_opex_df.at[7, 'OPEX'] = average_heavy_truck_distance_per_year * (fossil_fuel_mix_price_per_10km + opex_trucks_biogas_extra_cost_ratio) * heavy_truck_fuel_consumption_ratio
    capex_opex_df.at[7, 'Savings'] = average_heavy_truck_distance_per_year * fossil_fuel_mix_price_per_10km * heavy_truck_fuel_consumption_ratio * -1
    capex_opex_df.at[7, 'Income'] = 0

    capex_opex_df.at[8, 'Unit'] = number_of_heavy_trucks_in_the_city
    capex_opex_df.at[8, 'CAPEX'] = (price_of_electric_heavy_truck - price_of_fossil_fueled_heavy_truck) * (1 - share_of_new_electric_trucks_causing_early_replacement) + \
                                   (price_of_electric_heavy_truck) * (share_of_new_electric_trucks_causing_early_replacement)
    capex_opex_df.at[8, 'OPEX'] = average_heavy_truck_distance_per_year * electric_price_per_10km * heavy_truck_fuel_consumption_ratio
    capex_opex_df.at[8, 'Savings'] = average_heavy_truck_distance_per_year * fossil_fuel_mix_price_per_10km * heavy_truck_fuel_consumption_ratio * -1
    capex_opex_df.at[8, 'Income'] = 0

    capex_opex_df.at[9, 'Unit'] = number_of_buses_in_city
    capex_opex_df.at[9, 'CAPEX'] = (price_of_electric_bus - price_of_fossil_fueled_bus) * (1 - share_of_new_electric_buses_causing_early_replacement) + \
                                   (price_of_electric_bus) * (share_of_new_electric_buses_causing_early_replacement)
    capex_opex_df.at[9, 'OPEX'] = bus_fuel_consumption_per_km * diesel_price_per_liter * average_bus_distance_per_year * electric_price_per_10km / fossil_fuel_mix_price_per_10km
    capex_opex_df.at[9, 'Savings'] = bus_fuel_consumption_per_km * diesel_price_per_liter * average_bus_distance_per_year * -1
    capex_opex_df.at[9, 'Income'] = 0

    capex_opex_df.at[10, 'Unit'] = number_of_buses_in_city
    capex_opex_df.at[10, 'CAPEX'] = (price_of_renewable_bus - price_of_fossil_fueled_bus) * (1 - share_of_new_electric_buses_causing_early_replacement) + \
                                    (price_of_renewable_bus) * (share_of_new_electric_buses_causing_early_replacement)
    capex_opex_df.at[10, 'OPEX'] = bus_fuel_consumption_per_km * diesel_price_per_liter * average_bus_distance_per_year * (1 + cost_increase_of_renewable_bus_fuel_in_buses)
    capex_opex_df.at[10, 'Savings'] = bus_fuel_consumption_per_km * diesel_price_per_liter * average_bus_distance_per_year * -1
    capex_opex_df.at[10, 'Income'] = 0

    capex_opex_df.at[11, 'Unit'] = 0
    capex_opex_df.at[11, 'CAPEX'] = 0
    capex_opex_df.at[11, 'OPEX'] = 0
    capex_opex_df.at[11, 'Savings'] = 0
    capex_opex_df.at[11, 'Income'] = 0

    capex_opex_df.at[12, 'Unit'] = float((tbe_emissions.loc[str(mun), "Electricity and district heating"]) *share_of_electricity_and_district_heating_emissions_from_electricity_production * 1000000 /
                                         emission_factor_from_electricity_production_sweden)
    capex_opex_df.at[12, 'CAPEX'] = wind_power_plant_cost_per_kwh
    capex_opex_df.at[12, 'OPEX'] = wind_power_plant_cost_per_kwh * opex_share_of_capex_of_lcoe_for_wind_energy
    capex_opex_df.at[12, 'Savings'] = 0
    capex_opex_df.at[12, 'Income'] = electricity_price_in_2022 * -1

    capex_opex_df.at[13, 'Unit'] = float((tbe_emissions.loc[str(mun), "Electricity and district heating"]) *
                                         share_of_electricity_and_district_heating_emissions_from_electricity_production * 1000000 /
                                         emission_factor_from_electricity_production_sweden)
    capex_opex_df.at[13, 'CAPEX'] = central_solar_power_plant_cost_per_kwh
    capex_opex_df.at[13, 'OPEX'] = central_solar_power_plant_cost_per_kwh * opex_share_of_capex_of_lcoe_for_central_solar_power_plant
    capex_opex_df.at[13, 'Savings'] = 0
    capex_opex_df.at[13, 'Income'] = electricity_price_in_2022 * -1

    capex_opex_df.at[14, 'Unit'] = float((tbe_emissions.loc[str(mun), "Electricity and district heating"]) *
                                         share_of_electricity_and_district_heating_emissions_from_electricity_production * 1000000 /
                                         emission_factor_from_electricity_production_sweden)
    capex_opex_df.at[14, 'CAPEX'] = rooftop_solar_power_cost_per_kwh
    capex_opex_df.at[14, 'OPEX'] = rooftop_solar_power_cost_per_kwh * opex_share_of_capex_of_lcoe_for_rooftop_solar_power
    capex_opex_df.at[14, 'Savings'] = 0
    capex_opex_df.at[14, 'Income'] = electricity_price_in_2022 * -1

    capex_opex_df.at[15, 'Unit'] = float((tbe_emissions.loc[str(mun), "Total"]))
    capex_opex_df.at[15, 'CAPEX'] = (average_cost_of_beccs * share_of_negative_emission_tech_related_to_beccs + (1 - share_of_negative_emission_tech_related_to_beccs) * average_cost_of_daccs) \
                                    * (1 - share_of_beccs_costs_related_to_opex_on_annual_basis) * USD_SEK
    capex_opex_df.at[15, 'OPEX'] = ((average_cost_of_beccs * share_of_negative_emission_tech_related_to_beccs + (1 - share_of_negative_emission_tech_related_to_beccs) * average_cost_of_daccs)
                                    * (1 - share_of_beccs_costs_related_to_opex_on_annual_basis) * USD_SEK) * \
                                   share_of_beccs_costs_related_to_opex_on_annual_basis
    capex_opex_df.at[15, 'Savings'] = 0
    capex_opex_df.at[15, 'Income'] = 0

    capex_opex_df.at[16, 'Unit'] = tbe_emissions.loc[str(mun), "Industry (energy + processes)"]  ## need to verified
    capex_opex_df.at[16, 'CAPEX'] = capital_cost_of_ccs_per_ton
    capex_opex_df.at[16, 'OPEX'] = operating_cost_of_ccs_per_captured_ton_of_co2
    capex_opex_df.at[16, 'Savings'] = (average_ets_price_in_2022 * EUR_SEK) * -1
    capex_opex_df.at[16, 'Income'] = 0

    capex_opex_df.at[17, 'Unit'] = float((tbe_emissions.loc[str(mun), "Electricity and district heating"]) * ccs_capture_share_of_emissions)
    capex_opex_df.at[17, 'CAPEX'] = capital_cost_of_ccs_per_ton
    capex_opex_df.at[17, 'OPEX'] = operating_cost_of_ccs_per_captured_ton_of_co2
    capex_opex_df.at[17, 'Savings'] = (average_ets_price_in_2022 * EUR_SEK) * -1
    capex_opex_df.at[17, 'Income'] = 0

    capex_opex_df.at[18, 'Unit'] = tbe_emissions.loc[str(mun), "Industry (energy + processes)"]
    capex_opex_df.at[18, 'CAPEX'] = abatement_cost_of_hydrogen_per_ton_of_co2e_removed * EUR_SEK
    capex_opex_df.at[18, 'OPEX'] = abatement_cost_of_hydrogen_per_ton_of_co2e_removed * EUR_SEK * opex_share_of_total_costs_of_hydrogen_in_a_year
    capex_opex_df.at[18, 'Savings'] = (average_ets_price_in_2022 * EUR_SEK) * -1
    capex_opex_df.at[18, 'Income'] = 0

    capex_opex_df.at[19, 'Unit'] = total_building_stock_in_municipality
    capex_opex_df.at[19, 'CAPEX'] = capex_for_bat_investments
    capex_opex_df.at[19, 'OPEX'] = 0
    capex_opex_df.at[19, 'Savings'] = (energy_cost_per_year_in_municipality * impact_from_bat_appliances_on_energy_savings) * -1
    capex_opex_df.at[19, 'Income'] = 0

    capex_opex_df.at[19, 'Unit'] = total_building_stock_in_municipality
    capex_opex_df.at[19, 'CAPEX'] = capex_for_bat_investments
    capex_opex_df.at[19, 'OPEX'] = 0
    capex_opex_df.at[19, 'Savings'] = (energy_cost_per_year_in_municipality * impact_from_bat_appliances_on_energy_savings) * -1
    capex_opex_df.at[19, 'Income'] = 0

    capex_opex_df.at[20, 'Unit'] = total_building_stock_in_municipality
    capex_opex_df.at[20, 'CAPEX'] = 0
    capex_opex_df.at[20, 'OPEX'] = 0
    capex_opex_df.at[20, 'Savings'] = (energy_cost_per_year_in_municipality * impact_from_reduced_temperature_to_20_degrees_on_energy_savings) * -1
    capex_opex_df.at[20, 'Income'] = 0

    capex_opex_df.at[21, 'Unit'] = dwellings_size.loc[str(mun), "Total"]
    capex_opex_df.at[21, 'CAPEX'] = capex_of_implementing_sn_measures
    capex_opex_df.at[21, 'OPEX'] = 0
    capex_opex_df.at[21, 'Savings'] = (energy_cost_per_year_in_municipality * impact_from_savvidou_nykvist_measures_on_energy_savings) * -1
    capex_opex_df.at[21, 'Income'] = 0

    capex_opex_df.at[22, 'Unit'] = tbe_emissions.loc[str(mun),"Passenger cars":"International flights below 1000 m altitude in Swedish airspace"].sum()
    capex_opex_df.at[22, 'CAPEX'] = investment_cost_of_rewetting_wetlands_in_lake_or_agricultural_area -(1-share_of_rewetting_in_forest_land)+ investment_cost_of_rewetting_wetlands_in_forest*share_of_rewetting_in_forest_land
    capex_opex_df.at[22, 'OPEX'] = operating_cost_of_rewetting_wetlands_in_lake_or_agricultural_area * share_of_rewetting_in_forest_land * (1-share_of_rewetting_in_forest_land)* operating_cost_of_rewetting_wetlands_in_forest
    capex_opex_df.at[22, 'Savings'] = 0
    capex_opex_df.at[22, 'Income'] = 0

    capex_opex_df.at[23, 'Unit'] = tbe_emissions.loc[str(mun), "Animal digestion":"Other fertilizers"].sum()
    capex_opex_df.at[23, 'CAPEX'] = average_investment_cost_of_agricultural_measure_per_reduced_tCO2e
    capex_opex_df.at[23, 'OPEX'] = 0
    capex_opex_df.at[23, 'Savings'] = 0
    capex_opex_df.at[23, 'Income'] = 0

    capex_opex_df.at[24, 'Unit'] = tbe_emissions.loc[str(mun),"Passenger cars":"International flights below 1000 m altitude in Swedish airspace"].sum()
    capex_opex_df.at[24, 'CAPEX'] = 0
    capex_opex_df.at[24, 'OPEX'] = cost_per_ton_of_carbon_credit_compensation
    capex_opex_df.at[24, 'Savings'] = 0
    capex_opex_df.at[24, 'Income'] = 0

    capex_opex_df.at[25, 'Unit'] = float((tbe_emissions.loc[str(mun), "Electricity and district heating"]) *
                                         ((1 - share_of_electricity_and_district_heating_emissions_from_electricity_production)* 1000000 / emission_factor_from_heat_production))
    capex_opex_df.at[25, 'CAPEX'] = district_heating_capex_per_kwh_for_heat_pumps
    capex_opex_df.at[25, 'OPEX'] = district_heating_capex_per_kwh_for_heat_pumps * opex_share_of_capex_for_heat_pumps
    capex_opex_df.at[25, 'Savings'] = 0
    capex_opex_df.at[25, 'Income'] = 0

    capex_opex_df.at[26, 'Unit'] = 0
    capex_opex_df.at[26, 'CAPEX'] = 0
    capex_opex_df.at[26, 'OPEX'] = 0
    capex_opex_df.at[26, 'Savings'] = 0
    capex_opex_df.at[26, 'Income'] = 0

    capex_opex_df

    capex_opex_unit = capex_opex_df[['Lever', 'Unit']]
    capex_opex_costs = capex_opex_df.drop(['Unit'], axis=1)
    # Actors levers into db
    original_df = pd.DataFrame(capex_opex_costs, columns=['Lever', 'CAPEX', 'OPEX', 'Savings', 'Income'])

    # Create an empty DataFrame to store the result
    result_df = pd.DataFrame(columns=['Lever', 'Cost type', 'Value'])

    # Create an empty list to store data
    data_to_append = []

    # Loop through each row in the original DataFrame
    for index, row in original_df.iterrows():
        lever = row['Lever']
        # Loop through each actor column and its corresponding value
        for actor in original_df.columns[1:]:
            actor_value = row[actor]
            data_to_append.append({'Lever': lever, 'Cost type': actor, 'Value': actor_value})

    # Convert the list of dictionaries to a DataFrame
    result_df = pd.DataFrame(data_to_append)

    capex_opex_costs_db = result_df
    capex_opex_costs_db = capex_opex_costs_db.fillna(0)

    #with pd.option_context('display.max_columns', None, 'display.width', 1300):
        #print(capex_opex_costs_db)

    ################check the capex,opex, savings and income ###################

    # Melt the DataFrame for plotting
    capex_opex_melted_df = capex_opex_costs_db.melt(
        id_vars=['Lever', 'Cost type'],
        value_vars=['Value'],
        var_name='Metric',
        value_name='Amount'
    )

    # Create the bar chart
    fig = px.bar(
        capex_opex_melted_df,
        x='Lever',
        y='Amount',
        color='Cost type',
        title='Cost Types by Lever',
        labels={'Lever': 'Lever', 'Amount': 'Amount', 'Cost type': 'Cost Type'},
        height=600,
        width=1200
    )

    #return [fig]

    # Modify the existing CAPEX DataFrame column name
    timing_levers_df_capex_db.rename(columns={'Melted_Value': 'Value'}, inplace=True)
    timing_levers_df_opex_db.rename(columns={'Melted_Value': 'Value'}, inplace=True)
    timing_levers_df_savings_db.rename(columns={'Melted_Value': 'Value'}, inplace=True)
    timing_levers_df_income_db.rename(columns={'Melted_Value': 'Value'}, inplace=True)

    combined_df = pd.concat([timing_levers_df_capex_db, timing_levers_df_opex_db, timing_levers_df_savings_db,timing_levers_df_income_db], ignore_index=True)

    timing_levers_db = combined_df

    # Merge the two DataFrames based on 'Lever', 'Year', and 'Cost type' columns
    for lever, unit in zip(capex_opex_unit['Lever'], capex_opex_unit['Unit']): economic_db.loc[economic_db['Lever'] == lever, 'Unit'] = unit

    result = pd.merge(economic_db, capex_opex_costs_db, on=['Lever', 'Cost type'])
    # Convert 'Value' column to numeric type
    result['Value'] = pd.to_numeric(result['Value'], errors='coerce')

    # Convert 'Unit' column to numeric type
    result['Unit'] = pd.to_numeric(result['Unit'], errors='coerce')

    # Create 'New Value' column by multiplying 'Value' and 'Unit'
    result['New Value'] = result['Value'] * result['Unit']

    # Drop unnecessary columns
    result = result.drop(columns=['Value', 'Unit'])

    # Rename 'New Value' column to 'Value'
    result = result.rename(columns={'New Value': 'Value'})

    final_result = pd.merge(result, actors_levers_df_db, on=['Lever', 'Actor'])
    final_result['Value'] = final_result['Value_x'] * final_result['Value_y']
    final_result = final_result.drop(columns=['Value_x', 'Value_y'])

    economic_db = final_result

    timing_levers = pd.DataFrame(timing_levers_db)

    def integrate_timing(row):
        matching_rows = timing_levers[
            (timing_levers['Lever'] == row['Lever']) &
            (timing_levers['Year'] == row['Year']) &
            (timing_levers['Cost type'] == row['Cost type'])
            ]
        if len(matching_rows) > 0:
            row['Value'] *= matching_rows['Value'].values[0]
        return row

    economic_db = economic_db.apply(integrate_timing, axis=1)

    #print(economic_db.head(30))

    lever_sector_mapping = {
        'Active transport': 'Transport',
        'BAT household items': 'Built Environment',
        'Bio-CCS': 'Negative emissions solutions',
        'Carbon credits': 'Negative emissions solutions',
        'CCS industry': 'Industry',
        'CCS waste': 'Energy',
        'EE measures': 'Built Environment',
        'Electric bus': 'Transport',
        'Electric cars': 'Transport',
        'Heat pump DH': 'Energy',
        'Heavy trucks biogas': 'Transport',
        'Heavy trucks electric': 'Transport',
        'HVO bus': 'Transport',
        'Hydrogen cars': 'Transport',
        'Hydrogen industry': 'Industry',
        'Indoor temperature': 'Built Environment',
        'Light trucks biogas': 'Transport',
        'Light trucks electric': 'Transport',
        'Methane mgmt': 'Agriculture (including food) and land use',
        'Plug in hybrid cars': 'Transport',
        'Recycling': 'Consumption and material use',
        'Reduced car use': 'Transport',
        'Reduced flights': 'Transport',
        'Rewetting': 'Negative emissions solutions',
        'Solar park': 'Energy',
        'Solar roof': 'Energy',
        'Wind': 'Energy'
    }

    economic_db['Sector'] = economic_db['Lever'].map(lever_sector_mapping)
    print(economic_db.head(100))

    columns = ["Lever", "Cost type", "Actor", "Year", "Sector", "Value"]
    df = pd.DataFrame(economic_db, columns=columns)

    # Calculate cumulative sum by grouping and applying conditions
    df['Cumulative Value'] = (df.groupby(['Lever', 'Cost type', 'Actor'])['Value'].cumsum())

    economic_db = df
    with pd.option_context('display.max_columns', None, 'display.width', 1300):
        print(economic_db.head(100))

    def calculate_npv(row):
        r = (float(interest) / 100)
        t = row['Year'] - 2021
        return row['Value'] * (1 + r) ** (-t)

    # Assuming you have the dataframe 'economic_db' loaded
    # Filter for CAPEX cost type
    economic_db_NPV = economic_db.copy()

    # Calculate NPV for each row
    economic_db_NPV['NPV'] = economic_db_NPV.apply(calculate_npv, axis=1)
    economic_db_NPV['Cumulative NPV'] = (economic_db_NPV.groupby(['Lever', 'Cost type', 'Actor'])['NPV'].cumsum())

    with pd.option_context('display.max_columns', None, 'display.width', 1300):
        print(economic_db_NPV.head(15))

    # 1. Initialize default return values
    fig_cap = None
    fig_op = None
    fig = None
    fig_npv = None
    df_exp1 = pd.DataFrame()  # Initialize as empty DataFrame
    df_exp = pd.DataFrame()   # Initialize as empty DataFrame
    data_savings = {}         # Initialize as empty dict
    data_income = {}          # Initialize as empty dict
    df_npv_exp = pd.DataFrame()

    if ECout == 'Per capita':
        if ECout_year == '2025':
            economic_db = economic_db

            #########CAPEX#############
            # Filter the data for the year 2030 and cost type 'CAPEX'
            economic_db_2030_cap = economic_db[(economic_db['Year'] == 2025) & (economic_db['Cost type'] == 'CAPEX')]

            # Group by actor and sector and sum the cost
            df_summed_cap = economic_db_2030_cap.groupby(['Actor', 'Sector'], as_index=False)['Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_cap.groupby('Sector'):
                total_value = group['Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_cap
            df_summed_cap = pd.concat([total_df, df_summed_cap], ignore_index=True)

            selected_population = pop.loc[mun, 2025]
            df_summed_cap['Per Capita Value'] = df_summed_cap['Value'] / selected_population

            # Get the population value for the selected municipality and year
            selected_population = pop.loc[mun, 2025]

            # Calculate per capita value by dividing 'Value' by the selected population
            df_summed_cap['Per Capita Value'] = df_summed_cap['Value'] / selected_population

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_cap = px.bar(df_summed_cap, x='Actor', y='Per Capita Value', color='Sector', barmode='stack',
                         color_discrete_map=color_mapping)

            fig_cap.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="CAPEX expenditure 2025 per capita in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df1 = df_summed_cap.groupby('Actor', as_index=False)['Per Capita Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_cap['Sector'].unique())
            unique_actors = df_summed_cap['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Per capita 2025 in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_cap[(df_summed_cap['Actor'] == actor) & (df_summed_cap['Sector'] == sector)]['Per Capita Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp1 = pd.DataFrame.from_dict(data_exp)

            #########OPEX#############

            economic_db_2030_op = economic_db[(economic_db['Year'] == 2025) & (economic_db['Cost type'] == 'OPEX')]

            # Group by actor and sector and sum the cost
            df_summed_op  = economic_db_2030_op .groupby(['Actor', 'Sector'], as_index=False)['Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_op.groupby('Sector'):
                total_value = group['Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_op
            df_summed_op = pd.concat([total_df, df_summed_op], ignore_index=True)

            # Get the population value for the selected municipality and year
            selected_population = pop.loc[mun, 2025] ### need to divide with each years population because its a cumulative

            # Calculate per capita value by dividing 'Value' by the selected population
            df_summed_op ['Per Capita Value'] = df_summed_op ['Value'] / selected_population

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_op  = px.bar(df_summed_op , x='Actor', y='Per Capita Value', color='Sector', barmode='stack',
                         color_discrete_map=color_mapping)

            fig_op.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="OPEX expenditure 2025 per capita in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df = df_summed_op.groupby('Actor', as_index=False)['Per Capita Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_op['Sector'].unique())
            unique_actors = df_summed_op['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Per Capita 2025 in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_op[(df_summed_op['Actor'] == actor) & (df_summed_op['Sector'] == sector)]['Per Capita Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp = pd.DataFrame.from_dict(data_exp)

#####################Savings and Income/###################

            # Filter the data for the year 2030 and cost type 'SI'
            economic_db_2030_si = economic_db[(economic_db['Year'] == 2025) & (economic_db['Cost type'].isin(['Savings', 'Income']))]

            # Group by actor, sector, and cost type and sum the values
            df_summed_si = economic_db_2030_si.groupby(['Actor', 'Sector', 'Cost type'], as_index=False)['Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for (sector, cost_type), group in df_summed_si.groupby(['Sector', 'Cost type']):
                total_value = group['Value'].sum()
                new_row = pd.DataFrame({
                    'Actor': ['Total'],
                    'Sector': [sector],
                    'Cost type': [cost_type],
                    'Value': [total_value]
                })
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_si
            df_summed_si = pd.concat([total_df, df_summed_si], ignore_index=True)

            # Get the population value for the selected municipality and year
            selected_population = pop.loc[mun, 2025]  # Assuming 'pop' is a DataFrame containing population data

            # Calculate per capita value by dividing 'Value' by the selected population
            df_summed_si['Per Capita Value'] = df_summed_si['Value'] / selected_population

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create subplots with 1 row and 2 columns
            fig = sp.make_subplots(rows=1, cols=2, subplot_titles=("Savings", "Income"))

            # Filter data for Savings and add bar trace to subplot 1
            savings_data = df_summed_si[df_summed_si['Cost type'] == 'Savings']
            savings_trace = go.Bar(x=savings_data['Actor'],
                                   y=savings_data['Per Capita Value'],
                                   marker_color=savings_data['Sector'].map(color_mapping),
                                   name='Savings'
                                   )
            fig.add_trace(savings_trace, row=1, col=1)

            # Filter data for Income and add bar trace to subplot 2
            income_data = df_summed_si[df_summed_si['Cost type'] == 'Income']
            income_trace = go.Bar(
                x=income_data['Actor'],
                y=income_data['Per Capita Value'],
                marker_color=income_data['Sector'].map(color_mapping),
                name='Income'
            )
            fig.add_trace(income_trace, row=1, col=2)

            # Update layout for the entire figure
            fig.update_layout(
                title_text="Savings and Income expenditure 2025 per capita in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
                showlegend=False  # Disable the legend as it's not needed for this layout
            )

            data_exp_df = df_summed_si.groupby('Actor', as_index=False)['Per Capita Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_si['Sector'].unique())
            unique_actors = df_summed_si['Actor'].unique()

            # Separate data for 'Savings' and 'Income'
            df_savings = df_summed_si[df_summed_si['Cost type'] == 'Savings']
            df_income = df_summed_si[df_summed_si['Cost type'] == 'Income']

            # Function to create the data structure for export
            def create_data_export(df, unique_sectors):
                data_exp = {"Sectors - Per Capita 2025 in SEK": list(unique_sectors)}
                unique_actors = df['Actor'].unique()

                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        value = df[(df['Actor'] == actor) & (df['Sector'] == sector)]['Per Capita Value']
                        actor_values.append(value.iloc[0] if not value.empty else 0)
                    data_exp[actor] = actor_values

                return pd.DataFrame.from_dict(data_exp).to_dict('records')

            # Create the separate data structures
            data_savings = create_data_export(df_savings, unique_sectors)
            data_income = create_data_export(df_income, unique_sectors)

        elif ECout_year == '2027':
            economic_db = economic_db
            #########CAPEX#############
            # Filter the data for the year 2030 and cost type 'CAPEX'
            economic_db_2030_cap = economic_db[(economic_db['Year'] == 2027) & (economic_db['Cost type'] == 'CAPEX')]

            # Group by actor and sector and sum the cost
            df_summed_cap = economic_db_2030_cap.groupby(['Actor', 'Sector'], as_index=False)['Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_cap.groupby('Sector'):
                total_value = group['Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_cap
            df_summed_cap = pd.concat([total_df, df_summed_cap], ignore_index=True)

            # Get the population value for the selected municipality and year
            selected_population = pop.loc[mun, 2027]

            # Calculate per capita value by dividing 'Value' by the selected population
            df_summed_cap['Per Capita Value'] = df_summed_cap['Value'] / selected_population

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_cap = px.bar(df_summed_cap, x='Actor', y='Per Capita Value', color='Sector', barmode='stack',
                             color_discrete_map=color_mapping)

            fig_cap.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="CAPEX expenditure 2027 per capita in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df1 = df_summed_cap.groupby('Actor', as_index=False)['Per Capita Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_cap['Sector'].unique())
            unique_actors = df_summed_cap['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Per capita 2027 in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_cap[(df_summed_cap['Actor'] == actor) & (df_summed_cap['Sector'] == sector)][
                        'Per Capita Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp1 = pd.DataFrame.from_dict(data_exp)

            #########OPEX#############

            economic_db_2030_op = economic_db[(economic_db['Year'] == 2027) & (economic_db['Cost type'] == 'OPEX')]

            # Group by actor and sector and sum the cost
            df_summed_op = economic_db_2030_op.groupby(['Actor', 'Sector'], as_index=False)['Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_op.groupby('Sector'):
                total_value = group['Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_op
            df_summed_op = pd.concat([total_df, df_summed_op], ignore_index=True)

            # Get the population value for the selected municipality and year
            selected_population = pop.loc[mun, 2027]  ### need to divide with each years population because its a cumulative

            # Calculate per capita value by dividing 'Value' by the selected population
            df_summed_op['Per Capita Value'] = df_summed_op['Value'] / selected_population

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_op = px.bar(df_summed_op, x='Actor', y='Per Capita Value', color='Sector', barmode='stack',
                            color_discrete_map=color_mapping)

            fig_op.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="OPEX expenditure 2027 per capita in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df = df_summed_op.groupby('Actor', as_index=False)['Per Capita Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_op['Sector'].unique())
            unique_actors = df_summed_op['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Per Capita 2027 in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_op[(df_summed_op['Actor'] == actor) & (df_summed_op['Sector'] == sector)][
                        'Per Capita Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp = pd.DataFrame.from_dict(data_exp)

            #####################Savings and Income/###################

            # Filter the data for the year 2030 and cost type 'SI'
            economic_db_2030_si = economic_db[
                (economic_db['Year'] == 2027) & (economic_db['Cost type'].isin(['Savings', 'Income']))]

            # Group by actor, sector, and cost type and sum the values
            df_summed_si = economic_db_2030_si.groupby(['Actor', 'Sector', 'Cost type'], as_index=False)['Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for (sector, cost_type), group in df_summed_si.groupby(['Sector', 'Cost type']):
                total_value = group['Value'].sum()
                new_row = pd.DataFrame({
                    'Actor': ['Total'],
                    'Sector': [sector],
                    'Cost type': [cost_type],
                    'Value': [total_value]
                })
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_si
            df_summed_si = pd.concat([total_df, df_summed_si], ignore_index=True)

            # Get the population value for the selected municipality and year
            selected_population = pop.loc[mun, 2027]  # Assuming 'pop' is a DataFrame containing population data

            # Calculate per capita value by dividing 'Value' by the selected population
            df_summed_si['Per Capita Value'] = df_summed_si['Value'] / selected_population

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create subplots with 1 row and 2 columns
            fig = sp.make_subplots(rows=1, cols=2, subplot_titles=("Savings", "Income"))

            # Filter data for Savings and add bar trace to subplot 1
            savings_data = df_summed_si[df_summed_si['Cost type'] == 'Savings']
            savings_trace = go.Bar(x=savings_data['Actor'],
                                   y=savings_data['Per Capita Value'],
                                   marker_color=savings_data['Sector'].map(color_mapping),
                                   name='Savings'
                                   )
            fig.add_trace(savings_trace, row=1, col=1)

            # Filter data for Income and add bar trace to subplot 2
            income_data = df_summed_si[df_summed_si['Cost type'] == 'Income']
            income_trace = go.Bar(
                x=income_data['Actor'],
                y=income_data['Per Capita Value'],
                marker_color=income_data['Sector'].map(color_mapping),
                name='Income'
            )
            fig.add_trace(income_trace, row=1, col=2)

            # Update layout for the entire figure
            fig.update_layout(
                title_text="Savings and Income expenditure 2027 per capita in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
                showlegend=False  # Disable the legend as it's not needed for this layout
            )

            data_exp_df = df_summed_si.groupby('Actor', as_index=False)['Per Capita Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_si['Sector'].unique())
            unique_actors = df_summed_si['Actor'].unique()

            # Separate data for 'Savings' and 'Income'
            df_savings = df_summed_si[df_summed_si['Cost type'] == 'Savings']
            df_income = df_summed_si[df_summed_si['Cost type'] == 'Income']

            # Function to create the data structure for export
            def create_data_export(df, unique_sectors):
                data_exp = {"Sectors - Per Capita 2027 in SEK": list(unique_sectors)}
                unique_actors = df['Actor'].unique()

                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        value = df[(df['Actor'] == actor) & (df['Sector'] == sector)]['Per Capita Value']
                        actor_values.append(value.iloc[0] if not value.empty else 0)
                    data_exp[actor] = actor_values

                return pd.DataFrame.from_dict(data_exp).to_dict('records')

            # Create the separate data structures
            data_savings = create_data_export(df_savings, unique_sectors)
            data_income = create_data_export(df_income, unique_sectors)

        elif ECout_year == '2030':
            economic_db = economic_db
            #########CAPEX#############
            # Filter the data for the year 2030 and cost type 'CAPEX'
            economic_db_2030_cap = economic_db[(economic_db['Year'] == 2030) & (economic_db['Cost type'] == 'CAPEX')]

            # Group by actor and sector and sum the cost
            df_summed_cap = economic_db_2030_cap.groupby(['Actor', 'Sector'], as_index=False)['Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_cap.groupby('Sector'):
                total_value = group['Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_cap
            df_summed_cap = pd.concat([total_df, df_summed_cap], ignore_index=True)


            # Get the population value for the selected municipality and year
            selected_population = pop.loc[mun, 2030]

            # Calculate per capita value by dividing 'Value' by the selected population
            df_summed_cap['Per Capita Value'] = df_summed_cap['Value'] / selected_population

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_cap = px.bar(df_summed_cap, x='Actor', y='Per Capita Value', color='Sector', barmode='stack',
                             color_discrete_map=color_mapping)

            fig_cap.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="CAPEX expenditure 2030 per capita in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df1 = df_summed_cap.groupby('Actor', as_index=False)['Per Capita Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_cap['Sector'].unique())
            unique_actors = df_summed_cap['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Per capita 2030 in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_cap[(df_summed_cap['Actor'] == actor) & (df_summed_cap['Sector'] == sector)][
                        'Per Capita Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp1 = pd.DataFrame.from_dict(data_exp)

            #########OPEX#############

            economic_db_2030_op = economic_db[(economic_db['Year'] == 2030) & (economic_db['Cost type'] == 'OPEX')]

            # Group by actor and sector and sum the cost
            df_summed_op = economic_db_2030_op.groupby(['Actor', 'Sector'], as_index=False)['Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_op.groupby('Sector'):
                total_value = group['Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_op
            df_summed_op = pd.concat([total_df, df_summed_op], ignore_index=True)

            # Get the population value for the selected municipality and year
            selected_population = pop.loc[mun, 2030]  ### need to divide with each years population because its a cumulative

            # Calculate per capita value by dividing 'Value' by the selected population
            df_summed_op['Per Capita Value'] = df_summed_op['Value'] / selected_population

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_op = px.bar(df_summed_op, x='Actor', y='Per Capita Value', color='Sector', barmode='stack',
                            color_discrete_map=color_mapping)

            fig_op.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="OPEX expenditure 2030 per capita in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df = df_summed_op.groupby('Actor', as_index=False)['Per Capita Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_op['Sector'].unique())
            unique_actors = df_summed_op['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Per Capita 2030 in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_op[(df_summed_op['Actor'] == actor) & (df_summed_op['Sector'] == sector)][
                        'Per Capita Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp = pd.DataFrame.from_dict(data_exp)

            #####################Savings and Income/###################

            # Filter the data for the year 2030 and cost type 'SI'
            economic_db_2030_si = economic_db[(economic_db['Year'] == 2030) & (economic_db['Cost type'].isin(['Savings', 'Income']))]

            # Group by actor, sector, and cost type and sum the values
            df_summed_si = economic_db_2030_si.groupby(['Actor', 'Sector', 'Cost type'], as_index=False)['Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for (sector, cost_type), group in df_summed_si.groupby(['Sector', 'Cost type']):
                total_value = group['Value'].sum()
                new_row = pd.DataFrame({
                    'Actor': ['Total'],
                    'Sector': [sector],
                    'Cost type': [cost_type],
                    'Value': [total_value]
                })
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_si
            df_summed_si = pd.concat([total_df, df_summed_si], ignore_index=True)

            # Get the population value for the selected municipality and year
            selected_population = pop.loc[mun, 2030]  # Assuming 'pop' is a DataFrame containing population data

            # Calculate per capita value by dividing 'Value' by the selected population
            df_summed_si['Per Capita Value'] = df_summed_si['Value'] / selected_population

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create subplots with 1 row and 2 columns
            fig = sp.make_subplots(rows=1, cols=2, subplot_titles=("Savings", "Income"))

            # Filter data for Savings and add bar trace to subplot 1
            savings_data = df_summed_si[df_summed_si['Cost type'] == 'Savings']
            savings_trace = go.Bar(x=savings_data['Actor'],
                                   y=savings_data['Per Capita Value'],
                                   marker_color=savings_data['Sector'].map(color_mapping),
                                   name='Savings'
                                   )
            fig.add_trace(savings_trace, row=1, col=1)

            # Filter data for Income and add bar trace to subplot 2
            income_data = df_summed_si[df_summed_si['Cost type'] == 'Income']
            income_trace = go.Bar(
                x=income_data['Actor'],
                y=income_data['Per Capita Value'],
                marker_color=income_data['Sector'].map(color_mapping),
                name='Income'
            )
            fig.add_trace(income_trace, row=1, col=2)

            # Update layout for the entire figure
            fig.update_layout(
                title_text="Savings and Income expenditure 2030 per capita in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
                showlegend=False  # Disable the legend as it's not needed for this layout
            )

            data_exp_df = df_summed_si.groupby('Actor', as_index=False)['Per Capita Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_si['Sector'].unique())
            unique_actors = df_summed_si['Actor'].unique()

            # Separate data for 'Savings' and 'Income'
            df_savings = df_summed_si[df_summed_si['Cost type'] == 'Savings']
            df_income = df_summed_si[df_summed_si['Cost type'] == 'Income']

            # Function to create the data structure for export
            def create_data_export(df, unique_sectors):
                data_exp = {"Sectors - Per Capita 2030 in SEK": list(unique_sectors)}
                unique_actors = df['Actor'].unique()

                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        value = df[(df['Actor'] == actor) & (df['Sector'] == sector)]['Per Capita Value']
                        actor_values.append(value.iloc[0] if not value.empty else 0)
                    data_exp[actor] = actor_values

                return pd.DataFrame.from_dict(data_exp).to_dict('records')

            # Create the separate data structures
            data_savings = create_data_export(df_savings, unique_sectors)
            data_income = create_data_export(df_income, unique_sectors)

        elif ECout_year == '2025 Cumulative':
            economic_db = economic_db

###################CAPEX###########################
            # Filter the data for the year 2030 and cost type 'CAPEX'
            economic_db_2030_cap = economic_db[(economic_db['Year'] == 2025) & (economic_db['Cost type'] == 'CAPEX')]

            # Group by actor and sector and sum the cost
            df_summed_cap = economic_db_2030_cap.groupby(['Actor', 'Sector'], as_index=False)['Cumulative Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_cap.groupby('Sector'):
                total_value = group['Cumulative Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Cumulative Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Get the population value for the selected municipality and year
            selected_population = pop.loc[mun, 2025] ### need to divide with each years population because its a cumulative

            # Calculate per capita value by dividing 'Value' by the selected population
            df_summed_cap['Per Capita Value'] = df_summed_cap['Cumulative Value'] / selected_population

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_cap = px.bar(df_summed_cap, x='Actor', y='Per Capita Value', color='Sector', barmode='stack',
                         color_discrete_map=color_mapping)

            fig_cap.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Cumulative CAPEX expenditure 2025 per capita in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df = df_summed_cap.groupby('Actor', as_index=False)['Per Capita Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_cap['Sector'].unique())
            unique_actors = df_summed_cap['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Per capita 2025 Cumulative in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_cap[(df_summed_cap['Actor'] == actor) & (df_summed_cap['Sector'] == sector)]['Per Capita Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp1 = pd.DataFrame.from_dict(data_exp)

####################OPEX####################################

            # Filter the data for the year 2030 and cost type 'OPEX'
            economic_db_2030_op = economic_db[(economic_db['Year'] == 2025) & (economic_db['Cost type'] == 'OPEX')]

            # Group by actor and sector and sum the cost
            df_summed_op = economic_db_2030_op.groupby(['Actor', 'Sector'], as_index=False)['Cumulative Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_op.groupby('Sector'):
                total_value = group['Cumulative Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Cumulative Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_op
            df_summed_op = pd.concat([total_df, df_summed_op], ignore_index=True)

            # Get the population value for the selected municipality and year
            selected_population = pop.loc[mun, 2025] ### need to divide with each years population because its a cumulative

            # Calculate per capita value by dividing 'Value' by the selected population
            df_summed_op['Per Capita Value'] = df_summed_op['Cumulative Value'] / selected_population

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_op = px.bar(df_summed_op, x='Actor', y='Per Capita Value', color='Sector', barmode='stack',color_discrete_map=color_mapping)

            fig_op.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Cumulative OPEX expenditure 2025 per capita in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df = df_summed_op.groupby('Actor', as_index=False)['Per Capita Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_op['Sector'].unique())
            unique_actors = df_summed_op['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Per Capita cumulative 2025 in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_op[(df_summed_op['Actor'] == actor) & (df_summed_op['Sector'] == sector)]['Per Capita Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp = pd.DataFrame.from_dict(data_exp)

####################Svings and Income//#########################

            # Filter the data for the year 2030 and cost type 'CAPEX'
            economic_db_2030_si = economic_db[(economic_db['Year'] == 2025) & (economic_db['Cost type'].isin(['Savings','Income']))]

            # Group by actor, sector, and cost type and sum the values
            df_summed = economic_db_2030_si.groupby(['Actor', 'Sector', 'Cost type'], as_index=False)['Cumulative Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for (sector, cost_type), group in df_summed.groupby(['Sector', 'Cost type']):
                total_value = group['Cumulative Value'].sum()
                new_row = pd.DataFrame({
                    'Actor': ['Total'],
                    'Sector': [sector],
                    'Cost type': [cost_type],
                    'Cumulative Value': [total_value]
                })
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_si
            df_summed = pd.concat([total_df, df_summed], ignore_index=True)

            # Get the population value for the selected municipality and year
            selected_population = pop.loc[mun, 2025]  # Assuming 'pop' is a DataFrame containing population data

            # Calculate per capita value by dividing 'Cumulative Value' by the selected population
            df_summed['Per Capita Value'] = df_summed['Cumulative Value'] / selected_population

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create subplots with 1 row and 2 columns
            fig = sp.make_subplots(rows=1, cols=2, subplot_titles=("Savings", "Income"))

            # Filter data for Savings and add bar trace to subplot 1
            savings_data = df_summed[df_summed['Cost type'] == 'Savings']
            savings_trace = go.Bar(x=savings_data['Actor'],
                                   y=savings_data['Per Capita Value'],
                                   marker_color=savings_data['Sector'].map(color_mapping),
                                   name='Savings'
                                   )
            fig.add_trace(savings_trace, row=1, col=1)

            # Filter data for Income and add bar trace to subplot 2
            income_data = df_summed[df_summed['Cost type'] == 'Income']
            income_trace = go.Bar(
                x=income_data['Actor'],
                y=income_data['Per Capita Value'],
                marker_color=income_data['Sector'].map(color_mapping),
                name='Income'
            )
            fig.add_trace(income_trace, row=1, col=2)

            # Update layout for the entire figure
            fig.update_layout(
                title_text="Cumulative Savings and Income expenditure 2025 per capita in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
                showlegend=False  # Disable the legend as it's not needed for this layout
            )
            data_exp_df = df_summed.groupby('Actor', as_index=False)['Per Capita Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed['Sector'].unique())
            unique_actors = df_summed['Actor'].unique()

            # Separate data for 'Savings' and 'Income'
            df_savings = df_summed[df_summed['Cost type'] == 'Savings']
            df_income = df_summed[df_summed['Cost type'] == 'Income']

            # Function to create the data structure for export
            def create_data_export(df, unique_sectors):
                data_exp = {"Sectors - Per Capita cumulative 2025 in SEK": list(unique_sectors)}
                unique_actors = df['Actor'].unique()

                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        value = df[(df['Actor'] == actor) & (df['Sector'] == sector)]['Per Capita Value']
                        actor_values.append(value.iloc[0] if not value.empty else 0)
                    data_exp[actor] = actor_values

                return pd.DataFrame.from_dict(data_exp).to_dict('records')

            # Create the separate data structures
            data_savings = create_data_export(df_savings, unique_sectors)
            data_income = create_data_export(df_income, unique_sectors)

        elif ECout_year == '2027 Cumulative':
            economic_db = economic_db

            ###################CAPEX###########################
            # Filter the data for the year 2030 and cost type 'CAPEX'
            economic_db_2030_cap = economic_db[(economic_db['Year'] == 2027) & (economic_db['Cost type'] == 'CAPEX')]

            # Group by actor and sector and sum the cost
            df_summed_cap = economic_db_2030_cap.groupby(['Actor', 'Sector'], as_index=False)['Cumulative Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_cap.groupby('Sector'):
                total_value = group['Cumulative Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Cumulative Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_cap
            df_summed_cap = pd.concat([total_df, df_summed_cap], ignore_index=True)

            # Get the population value for the selected municipality and year
            selected_population = pop.loc[mun, 2027]  ### need to divide with each years population because its a cumulative

            # Calculate per capita value by dividing 'Value' by the selected population
            df_summed_cap['Per Capita Value'] = df_summed_cap['Cumulative Value'] / selected_population

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_cap = px.bar(df_summed_cap, x='Actor', y='Per Capita Value', color='Sector', barmode='stack',
                             color_discrete_map=color_mapping)

            fig_cap.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Cumulative CAPEX expenditure 2027 per capita in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df = df_summed_cap.groupby('Actor', as_index=False)['Per Capita Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_cap['Sector'].unique())
            unique_actors = df_summed_cap['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Per capita 2027 Cumulative in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_cap[(df_summed_cap['Actor'] == actor) & (df_summed_cap['Sector'] == sector)][
                        'Per Capita Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp1 = pd.DataFrame.from_dict(data_exp)

            ####################OPEX####################################

            # Filter the data for the year 2030 and cost type 'OPEX'
            economic_db_2030_op = economic_db[(economic_db['Year'] == 2027) & (economic_db['Cost type'] == 'OPEX')]

            # Group by actor and sector and sum the cost
            df_summed_op = economic_db_2030_op.groupby(['Actor', 'Sector'], as_index=False)['Cumulative Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_op.groupby('Sector'):
                total_value = group['Cumulative Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Cumulative Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_op
            df_summed_op = pd.concat([total_df, df_summed_op], ignore_index=True)

            # Get the population value for the selected municipality and year
            selected_population = pop.loc[mun, 2027]  ### need to divide with each years population because its a cumulative

            # Calculate per capita value by dividing 'Value' by the selected population
            df_summed_op['Per Capita Value'] = df_summed_op['Cumulative Value'] / selected_population

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_op = px.bar(df_summed_op, x='Actor', y='Per Capita Value', color='Sector', barmode='stack',
                            color_discrete_map=color_mapping)

            fig_op.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Cumulative OPEX expenditure 2027 per capita in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df = df_summed_op.groupby('Actor', as_index=False)['Per Capita Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_op['Sector'].unique())
            unique_actors = df_summed_op['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Per Capita cumulative 2027 in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_op[(df_summed_op['Actor'] == actor) & (df_summed_op['Sector'] == sector)][
                        'Per Capita Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp = pd.DataFrame.from_dict(data_exp)

            ####################Svings and Income//#########################

            # Filter the data for the year 2030 and cost type 'CAPEX'
            economic_db_2030_si = economic_db[(economic_db['Year'] == 2027) & (economic_db['Cost type'].isin(['Savings', 'Income']))]

            # Group by actor, sector, and cost type and sum the values
            df_summed = economic_db_2030_si.groupby(['Actor', 'Sector', 'Cost type'], as_index=False)['Cumulative Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for (sector, cost_type), group in df_summed.groupby(['Sector', 'Cost type']):
                total_value = group['Cumulative Value'].sum()
                new_row = pd.DataFrame({
                    'Actor': ['Total'],
                    'Sector': [sector],
                    'Cost type': [cost_type],
                    'Cumulative Value': [total_value]
                })
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_si
            df_summed = pd.concat([total_df, df_summed], ignore_index=True)

            # Get the population value for the selected municipality and year
            selected_population = pop.loc[mun, 2027]  # Assuming 'pop' is a DataFrame containing population data

            # Calculate per capita value by dividing 'Cumulative Value' by the selected population
            df_summed['Per Capita Value'] = df_summed['Cumulative Value'] / selected_population

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create subplots with 1 row and 2 columns
            fig = sp.make_subplots(rows=1, cols=2, subplot_titles=("Savings", "Income"))

            # Filter data for Savings and add bar trace to subplot 1
            savings_data = df_summed[df_summed['Cost type'] == 'Savings']
            savings_trace = go.Bar(x=savings_data['Actor'],
                                   y=savings_data['Per Capita Value'],
                                   marker_color=savings_data['Sector'].map(color_mapping),
                                   name='Savings'
                                   )
            fig.add_trace(savings_trace, row=1, col=1)

            # Filter data for Income and add bar trace to subplot 2
            income_data = df_summed[df_summed['Cost type'] == 'Income']
            income_trace = go.Bar(
                x=income_data['Actor'],
                y=income_data['Per Capita Value'],
                marker_color=income_data['Sector'].map(color_mapping),
                name='Income'
            )
            fig.add_trace(income_trace, row=1, col=2)

            # Update layout for the entire figure
            fig.update_layout(
                title_text="Cumulative Savings and Income expenditure 2027 per capita in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
                showlegend=False  # Disable the legend as it's not needed for this layout
            )
            data_exp_df = df_summed.groupby('Actor', as_index=False)['Per Capita Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed['Sector'].unique())
            unique_actors = df_summed['Actor'].unique()

            # Separate data for 'Savings' and 'Income'
            df_savings = df_summed[df_summed['Cost type'] == 'Savings']
            df_income = df_summed[df_summed['Cost type'] == 'Income']

            # Function to create the data structure for export
            def create_data_export(df, unique_sectors):
                data_exp = {"Sectors - Per Capita cumulative 2027 in SEK": list(unique_sectors)}
                unique_actors = df['Actor'].unique()

                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        value = df[(df['Actor'] == actor) & (df['Sector'] == sector)]['Per Capita Value']
                        actor_values.append(value.iloc[0] if not value.empty else 0)
                    data_exp[actor] = actor_values

                return pd.DataFrame.from_dict(data_exp).to_dict('records')

            # Create the separate data structures
            data_savings = create_data_export(df_savings, unique_sectors)
            data_income = create_data_export(df_income, unique_sectors)

        elif ECout_year == '2030 Cumulative':
            economic_db = economic_db

            ###################CAPEX###########################
            # Filter the data for the year 2030 and cost type 'CAPEX'
            economic_db_2030_cap = economic_db[(economic_db['Year'] == 2030) & (economic_db['Cost type'] == 'CAPEX')]

            # Group by actor and sector and sum the cost
            df_summed_cap = economic_db_2030_cap.groupby(['Actor', 'Sector'], as_index=False)['Cumulative Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_cap.groupby('Sector'):
                total_value = group['Cumulative Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Cumulative Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_cap
            df_summed_cap = pd.concat([total_df, df_summed_cap], ignore_index=True)

            # Get the population value for the selected municipality and year
            selected_population = pop.loc[mun, 2030]  ### need to divide with each years population because its a cumulative

            # Calculate per capita value by dividing 'Value' by the selected population
            df_summed_cap['Per Capita Value'] = df_summed_cap['Cumulative Value'] / selected_population

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_cap = px.bar(df_summed_cap, x='Actor', y='Per Capita Value', color='Sector', barmode='stack',
                             color_discrete_map=color_mapping)

            fig_cap.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Cumulative CAPEX expenditure 2030 per capita in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df = df_summed_cap.groupby('Actor', as_index=False)['Per Capita Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_cap['Sector'].unique())
            unique_actors = df_summed_cap['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Per capita 2030 Cumulative in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_cap[(df_summed_cap['Actor'] == actor) & (df_summed_cap['Sector'] == sector)]['Per Capita Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp1 = pd.DataFrame.from_dict(data_exp)

            ####################OPEX####################################

            # Filter the data for the year 2030 and cost type 'OPEX'
            economic_db_2030_op = economic_db[(economic_db['Year'] == 2030) & (economic_db['Cost type'] == 'OPEX')]

            # Group by actor and sector and sum the cost
            df_summed_op = economic_db_2030_op.groupby(['Actor', 'Sector'], as_index=False)['Cumulative Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_op.groupby('Sector'):
                total_value = group['Cumulative Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Cumulative Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_op
            df_summed_op = pd.concat([total_df, df_summed_op], ignore_index=True)

            # Get the population value for the selected municipality and year
            selected_population = pop.loc[mun, 2030]  ### need to divide with each years population because its a cumulative

            # Calculate per capita value by dividing 'Value' by the selected population
            df_summed_op['Per Capita Value'] = df_summed_op['Cumulative Value'] / selected_population

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_op = px.bar(df_summed_op, x='Actor', y='Per Capita Value', color='Sector', barmode='stack',
                            color_discrete_map=color_mapping)

            fig_op.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Cumulative OPEX expenditure 2030 per capita in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df = df_summed_op.groupby('Actor', as_index=False)['Per Capita Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_op['Sector'].unique())
            unique_actors = df_summed_op['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Per Capita cumulative 2030 in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_op[(df_summed_op['Actor'] == actor) & (df_summed_op['Sector'] == sector)][
                        'Per Capita Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp = pd.DataFrame.from_dict(data_exp)

            ####################Svings and Income//#########################

            # Filter the data for the year 2030 and cost type 'CAPEX'
            economic_db_2030_si = economic_db[(economic_db['Year'] == 2030) & (economic_db['Cost type'].isin(['Savings', 'Income']))]

            # Group by actor, sector, and cost type and sum the values
            df_summed = economic_db_2030_si.groupby(['Actor', 'Sector', 'Cost type'], as_index=False)['Cumulative Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for (sector, cost_type), group in df_summed.groupby(['Sector', 'Cost type']):
                total_value = group['Cumulative Value'].sum()
                new_row = pd.DataFrame({
                    'Actor': ['Total'],
                    'Sector': [sector],
                    'Cost type': [cost_type],
                    'Cumulative Value': [total_value]
                })
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_si
            df_summed = pd.concat([total_df, df_summed], ignore_index=True)

            # Get the population value for the selected municipality and year
            selected_population = pop.loc[mun, 2030]  # Assuming 'pop' is a DataFrame containing population data

            # Calculate per capita value by dividing 'Cumulative Value' by the selected population
            df_summed['Per Capita Value'] = df_summed['Cumulative Value'] / selected_population

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create subplots with 1 row and 2 columns
            fig = sp.make_subplots(rows=1, cols=2, subplot_titles=("Savings", "Income"))

            # Filter data for Savings and add bar trace to subplot 1
            savings_data = df_summed[df_summed['Cost type'] == 'Savings']
            savings_trace = go.Bar(x=savings_data['Actor'],
                                   y=savings_data['Per Capita Value'],
                                   marker_color=savings_data['Sector'].map(color_mapping),
                                   name='Savings'
                                   )
            fig.add_trace(savings_trace, row=1, col=1)

            # Filter data for Income and add bar trace to subplot 2
            income_data = df_summed[df_summed['Cost type'] == 'Income']
            income_trace = go.Bar(
                x=income_data['Actor'],
                y=income_data['Per Capita Value'],
                marker_color=income_data['Sector'].map(color_mapping),
                name='Income'
            )
            fig.add_trace(income_trace, row=1, col=2)

            # Update layout for the entire figure
            fig.update_layout(
                title_text="Cumulative Savings and Income expenditure 2030 per capita in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
                showlegend=False  # Disable the legend as it's not needed for this layout
            )
            data_exp_df = df_summed.groupby('Actor', as_index=False)['Per Capita Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed['Sector'].unique())
            unique_actors = df_summed['Actor'].unique()

            # Separate data for 'Savings' and 'Income'
            df_savings = df_summed[df_summed['Cost type'] == 'Savings']
            df_income = df_summed[df_summed['Cost type'] == 'Income']

            # Function to create the data structure for export
            def create_data_export(df, unique_sectors):
                data_exp = {"Sectors - Per Capita cumulative 2030 in SEK": list(unique_sectors)}
                unique_actors = df['Actor'].unique()

                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        value = df[(df['Actor'] == actor) & (df['Sector'] == sector)]['Per Capita Value']
                        actor_values.append(value.iloc[0] if not value.empty else 0)
                    data_exp[actor] = actor_values

                return pd.DataFrame.from_dict(data_exp).to_dict('records')

            # Create the separate data structures
            data_savings = create_data_export(df_savings, unique_sectors)
            data_income = create_data_export(df_income, unique_sectors)

    elif ECout == 'Total for the municipality':
        if ECout_year == '2025':
            economic_db = economic_db

########################CAPEX###################################
            # Filter the data for the year 2030 and cost type 'CAPEX'
            economic_db_2030_cap = economic_db[(economic_db['Year'] == 2025) & (economic_db['Cost type'] == 'CAPEX')]

            # Group by actor and sector and sum the cost
            df_summed_cap = economic_db_2030_cap.groupby(['Actor', 'Sector'], as_index=False)['Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_cap.groupby('Sector'):
                total_value = group['Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_cap
            df_summed_cap = pd.concat([total_df, df_summed_cap], ignore_index=True)

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_cap  = px.bar(df_summed_cap, x='Actor', y='Value', color='Sector', barmode='stack',
                         color_discrete_map=color_mapping)

            fig_cap.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="CAPEX expenditure 2025 in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df = df_summed_cap.groupby('Actor', as_index=False)['Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_cap['Sector'].unique())
            unique_actors = df_summed_cap['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Municipality 2025 in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_cap[(df_summed_cap['Actor'] == actor) & (df_summed_cap['Sector'] == sector)]['Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp1 = pd.DataFrame.from_dict(data_exp)

###################OPEX################################

            # Filter the data for the year 2030 and cost type 'opex'
            economic_db_2030_op = economic_db[(economic_db['Year'] == 2025) & (economic_db['Cost type'] == 'OPEX')]

            # Group by actor and sector and sum the cost
            df_summed_op = economic_db_2030_op.groupby(['Actor', 'Sector'], as_index=False)['Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_op.groupby('Sector'):
                total_value = group['Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_op
            df_summed_op = pd.concat([total_df, df_summed_op], ignore_index=True)

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_op = px.bar(df_summed_op, x='Actor', y='Value', color='Sector', barmode='stack',
                         color_discrete_map=color_mapping)

            fig_op.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="OPEX expenditure 2025 in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df = df_summed_op.groupby('Actor', as_index=False)['Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_op['Sector'].unique())
            unique_actors = df_summed_op['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Municipality 2025 in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_op[(df_summed_op['Actor'] == actor) & (df_summed_op['Sector'] == sector)]['Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp = pd.DataFrame.from_dict(data_exp)

#######################Savings and Income############################################

            # Filter the data for the year 2030 and cost types 'Savings' and 'Income'
            economic_db_2030 = economic_db[(economic_db['Year'] == 2025) & (economic_db['Cost type'].isin(['Savings', 'Income']))]

            # Group by actor, sector, and cost type and sum the values
            df_summed = economic_db_2030.groupby(['Actor', 'Sector', 'Cost type'], as_index=False)['Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for (sector, cost_type), group in df_summed.groupby(['Sector', 'Cost type']):
                total_value = group['Value'].sum()
                new_row = pd.DataFrame({
                    'Actor': ['Total'],
                    'Sector': [sector],
                    'Cost type': [cost_type],
                    'Value': [total_value]
                })
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_si
            df_summed = pd.concat([total_df, df_summed], ignore_index=True)

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create subplots with 1 row and 2 columns
            fig = sp.make_subplots(rows=1, cols=2, subplot_titles=("Savings", "Income"))

            # Filter data for Savings and add bar trace to subplot 1
            savings_data = df_summed[df_summed['Cost type'] == 'Savings']
            savings_trace = go.Bar(x=savings_data['Actor'],
                y=savings_data['Value'],
                marker_color=savings_data['Sector'].map(color_mapping),
                name='Savings'
            )
            fig.add_trace(savings_trace, row=1, col=1)

            # Filter data for Income and add bar trace to subplot 2
            income_data = df_summed[df_summed['Cost type'] == 'Income']
            income_trace = go.Bar(
                x=income_data['Actor'],
                y=income_data['Value'],
                marker_color=income_data['Sector'].map(color_mapping),
                name='Income'
            )
            fig.add_trace(income_trace, row=1, col=2)

            # Update layout for the entire figure
            fig.update_layout(
                title_text="Savings and Income expenditure 2025 in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
                showlegend=False  # Disable the legend as it's not needed for this layout
            )
            data_exp_df = df_summed.groupby('Actor', as_index=False)['Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed['Sector'].unique())
            unique_actors = df_summed['Actor'].unique()

            # Separate data for 'Savings' and 'Income'
            df_savings = df_summed[df_summed['Cost type'] == 'Savings']
            df_income = df_summed[df_summed['Cost type'] == 'Income']

            # Function to create the data structure for export
            def create_data_export(df, unique_sectors):
                data_exp = {"Sectors - Municipality 2025 in SEK": list(unique_sectors)}
                unique_actors = df['Actor'].unique()

                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        value = df[(df['Actor'] == actor) & (df['Sector'] == sector)]['Value']
                        actor_values.append(value.iloc[0] if not value.empty else 0)
                    data_exp[actor] = actor_values

                return pd.DataFrame.from_dict(data_exp).to_dict('records')

            # Create the separate data structures
            data_savings = create_data_export(df_savings, unique_sectors)
            data_income = create_data_export(df_income, unique_sectors)

        elif ECout_year == '2027':
            economic_db = economic_db
            ########################CAPEX###################################
            # Filter the data for the year 2030 and cost type 'CAPEX'
            economic_db_2030_cap = economic_db[(economic_db['Year'] == 2027) & (economic_db['Cost type'] == 'CAPEX')]

            # Group by actor and sector and sum the cost
            df_summed_cap = economic_db_2030_cap.groupby(['Actor', 'Sector'], as_index=False)['Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_cap.groupby('Sector'):
                total_value = group['Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_cap
            df_summed_cap = pd.concat([total_df, df_summed_cap], ignore_index=True)

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_cap = px.bar(df_summed_cap, x='Actor', y='Value', color='Sector', barmode='stack',
                             color_discrete_map=color_mapping)

            fig_cap.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="CAPEX expenditure 2027 in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df = df_summed_cap.groupby('Actor', as_index=False)['Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_cap['Sector'].unique())
            unique_actors = df_summed_cap['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Municipality 2027 in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_cap[(df_summed_cap['Actor'] == actor) & (df_summed_cap['Sector'] == sector)][
                        'Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp1 = pd.DataFrame.from_dict(data_exp)

            ###################OPEX################################

            # Filter the data for the year 2030 and cost type 'opex'
            economic_db_2030_op = economic_db[(economic_db['Year'] == 2027) & (economic_db['Cost type'] == 'OPEX')]

            # Group by actor and sector and sum the cost
            df_summed_op = economic_db_2030_op.groupby(['Actor', 'Sector'], as_index=False)['Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_op.groupby('Sector'):
                total_value = group['Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_op
            df_summed_op = pd.concat([total_df, df_summed_op], ignore_index=True)

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_op = px.bar(df_summed_op, x='Actor', y='Value', color='Sector', barmode='stack',
                            color_discrete_map=color_mapping)

            fig_op.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="OPEX expenditure 2027 in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df = df_summed_op.groupby('Actor', as_index=False)['Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_op['Sector'].unique())
            unique_actors = df_summed_op['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Municipality 2027 in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_op[(df_summed_op['Actor'] == actor) & (df_summed_op['Sector'] == sector)]['Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp = pd.DataFrame.from_dict(data_exp)

            #######################Savings and Income############################################

            # Filter the data for the year 2030 and cost types 'Savings' and 'Income'
            economic_db_2030 = economic_db[(economic_db['Year'] == 2027) & (economic_db['Cost type'].isin(['Savings', 'Income']))]

            # Group by actor, sector, and cost type and sum the values
            df_summed = economic_db_2030.groupby(['Actor', 'Sector', 'Cost type'], as_index=False)['Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for (sector, cost_type), group in df_summed.groupby(['Sector', 'Cost type']):
                total_value = group['Value'].sum()
                new_row = pd.DataFrame({
                    'Actor': ['Total'],
                    'Sector': [sector],
                    'Cost type': [cost_type],
                    'Value': [total_value]
                })
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_si
            df_summed = pd.concat([total_df, df_summed], ignore_index=True)

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create subplots with 1 row and 2 columns
            fig = sp.make_subplots(rows=1, cols=2, subplot_titles=("Savings", "Income"))

            # Filter data for Savings and add bar trace to subplot 1
            savings_data = df_summed[df_summed['Cost type'] == 'Savings']
            savings_trace = go.Bar(x=savings_data['Actor'],
                                   y=savings_data['Value'],
                                   marker_color=savings_data['Sector'].map(color_mapping),
                                   name='Savings'
                                   )
            fig.add_trace(savings_trace, row=1, col=1)

            # Filter data for Income and add bar trace to subplot 2
            income_data = df_summed[df_summed['Cost type'] == 'Income']
            income_trace = go.Bar(
                x=income_data['Actor'],
                y=income_data['Value'],
                marker_color=income_data['Sector'].map(color_mapping),
                name='Income'
            )
            fig.add_trace(income_trace, row=1, col=2)

            # Update layout for the entire figure
            fig.update_layout(
                title_text="Savings and Income expenditure 2027 in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
                showlegend=False  # Disable the legend as it's not needed for this layout
            )
            data_exp_df = df_summed.groupby('Actor', as_index=False)['Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed['Sector'].unique())
            unique_actors = df_summed['Actor'].unique()

            # Separate data for 'Savings' and 'Income'
            df_savings = df_summed[df_summed['Cost type'] == 'Savings']
            df_income = df_summed[df_summed['Cost type'] == 'Income']

            # Function to create the data structure for export
            def create_data_export(df, unique_sectors):
                data_exp = {"Sectors - Municipality 2027 in SEK": list(unique_sectors)}
                unique_actors = df['Actor'].unique()

                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        value = df[(df['Actor'] == actor) & (df['Sector'] == sector)]['Value']
                        actor_values.append(value.iloc[0] if not value.empty else 0)
                    data_exp[actor] = actor_values

                return pd.DataFrame.from_dict(data_exp).to_dict('records')

            # Create the separate data structures
            data_savings = create_data_export(df_savings, unique_sectors)
            data_income = create_data_export(df_income, unique_sectors)

        elif ECout_year == '2030':
            economic_db = economic_db
            ########################CAPEX###################################
            # Filter the data for the year 2030 and cost type 'CAPEX'
            economic_db_2030_cap = economic_db[(economic_db['Year'] == 2030) & (economic_db['Cost type'] == 'CAPEX')]

            # Group by actor and sector and sum the cost
            df_summed_cap = economic_db_2030_cap.groupby(['Actor', 'Sector'], as_index=False)['Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_cap.groupby('Sector'):
                total_value = group['Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_cap
            df_summed_cap = pd.concat([total_df, df_summed_cap], ignore_index=True)

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_cap = px.bar(df_summed_cap, x='Actor', y='Value', color='Sector', barmode='stack',
                             color_discrete_map=color_mapping)

            fig_cap.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="CAPEX expenditure 2030 in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df = df_summed_cap.groupby('Actor', as_index=False)['Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_cap['Sector'].unique())
            unique_actors = df_summed_cap['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Municipality 2030 in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_cap[(df_summed_cap['Actor'] == actor) & (df_summed_cap['Sector'] == sector)]['Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp1 = pd.DataFrame.from_dict(data_exp)

            ###################OPEX################################

            # Filter the data for the year 2030 and cost type 'opex'
            economic_db_2030_op = economic_db[(economic_db['Year'] == 2030) & (economic_db['Cost type'] == 'OPEX')]

            # Group by actor and sector and sum the cost
            df_summed_op = economic_db_2030_op.groupby(['Actor', 'Sector'], as_index=False)['Value'].sum()
            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_op.groupby('Sector'):
                total_value = group['Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_op
            df_summed_op = pd.concat([total_df, df_summed_op], ignore_index=True)

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_op = px.bar(df_summed_op, x='Actor', y='Value', color='Sector', barmode='stack',
                            color_discrete_map=color_mapping)

            fig_op.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="OPEX expenditure 2030 in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df = df_summed_op.groupby('Actor', as_index=False)['Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_op['Sector'].unique())
            unique_actors = df_summed_op['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Municipality 2030 in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_op[(df_summed_op['Actor'] == actor) & (df_summed_op['Sector'] == sector)]['Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp = pd.DataFrame.from_dict(data_exp)

            #######################Savings and Income############################################

            # Filter the data for the year 2030 and cost types 'Savings' and 'Income'
            economic_db_2030 = economic_db[(economic_db['Year'] == 2030) & (economic_db['Cost type'].isin(['Savings', 'Income']))]

            # Group by actor, sector, and cost type and sum the values
            df_summed = economic_db_2030.groupby(['Actor', 'Sector', 'Cost type'], as_index=False)['Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for (sector, cost_type), group in df_summed.groupby(['Sector', 'Cost type']):
                total_value = group['Value'].sum()
                new_row = pd.DataFrame({
                    'Actor': ['Total'],
                    'Sector': [sector],
                    'Cost type': [cost_type],
                    'Value': [total_value]
                })
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_si
            df_summed = pd.concat([total_df, df_summed], ignore_index=True)

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create subplots with 1 row and 2 columns
            fig = sp.make_subplots(rows=1, cols=2, subplot_titles=("Savings", "Income"))

            # Filter data for Savings and add bar trace to subplot 1
            savings_data = df_summed[df_summed['Cost type'] == 'Savings']
            savings_trace = go.Bar(x=savings_data['Actor'],
                                   y=savings_data['Value'],
                                   marker_color=savings_data['Sector'].map(color_mapping),
                                   name='Savings'
                                   )
            fig.add_trace(savings_trace, row=1, col=1)

            # Filter data for Income and add bar trace to subplot 2
            income_data = df_summed[df_summed['Cost type'] == 'Income']
            income_trace = go.Bar(
                x=income_data['Actor'],
                y=income_data['Value'],
                marker_color=income_data['Sector'].map(color_mapping),
                name='Income'
            )
            fig.add_trace(income_trace, row=1, col=2)

            # Update layout for the entire figure
            fig.update_layout(
                title_text="Savings and Income expenditure 2030 in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
                showlegend=False  # Disable the legend as it's not needed for this layout
            )
            data_exp_df = df_summed.groupby('Actor', as_index=False)['Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed['Sector'].unique())
            unique_actors = df_summed['Actor'].unique()

            # Separate data for 'Savings' and 'Income'
            df_savings = df_summed[df_summed['Cost type'] == 'Savings']
            df_income = df_summed[df_summed['Cost type'] == 'Income']

            # Function to create the data structure for export
            def create_data_export(df, unique_sectors):
                data_exp = {"Sectors - Municipality 2030 in SEK": list(unique_sectors)}
                unique_actors = df['Actor'].unique()

                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        value = df[(df['Actor'] == actor) & (df['Sector'] == sector)]['Value']
                        actor_values.append(value.iloc[0] if not value.empty else 0)
                    data_exp[actor] = actor_values

                return pd.DataFrame.from_dict(data_exp).to_dict('records')

            # Create the separate data structures
            data_savings = create_data_export(df_savings, unique_sectors)
            data_income = create_data_export(df_income, unique_sectors)

        elif ECout_year == '2025 Cumulative':
            economic_db = economic_db

            ########################CAPEX###################################
            # Filter the data for the year 2030 and cost type 'CAPEX'
            economic_db_2030_cap = economic_db[(economic_db['Year'] == 2025) & (economic_db['Cost type'] == 'CAPEX')]

            # Group by actor and sector and sum the cost
            df_summed_cap = economic_db_2030_cap.groupby(['Actor', 'Sector'], as_index=False)['Cumulative Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_cap.groupby('Sector'):
                total_value = group['Cumulative Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Cumulative Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_cap
            df_summed_cap = pd.concat([total_df, df_summed_cap], ignore_index=True)

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_cap = px.bar(df_summed_cap, x='Actor', y='Cumulative Value', color='Sector', barmode='stack',
                             color_discrete_map=color_mapping)

            fig_cap.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Cumulative CAPEX expenditure 2025 in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df = df_summed_cap.groupby('Actor', as_index=False)['Cumulative Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_cap['Sector'].unique())
            unique_actors = df_summed_cap['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Cumulative Municipality 2025 in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_cap[(df_summed_cap['Actor'] == actor) & (df_summed_cap['Sector'] == sector)]['Cumulative Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp1 = pd.DataFrame.from_dict(data_exp)

            ###################OPEX################################

            # Filter the data for the year 2030 and cost type 'opex'
            economic_db_2030_op = economic_db[(economic_db['Year'] == 2025) & (economic_db['Cost type'] == 'OPEX')]

            # Group by actor and sector and sum the cost
            df_summed_op = economic_db_2030_op.groupby(['Actor', 'Sector'], as_index=False)['Cumulative Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_op.groupby('Sector'):
                total_value = group['Cumulative Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Cumulative Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_op
            df_summed_op = pd.concat([total_df, df_summed_op], ignore_index=True)

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_op = px.bar(df_summed_op, x='Actor', y='Cumulative Value', color='Sector', barmode='stack',
                            color_discrete_map=color_mapping)

            fig_op.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Cumulative OPEX expenditure 2025 in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df = df_summed_op.groupby('Actor', as_index=False)['Cumulative Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_op['Sector'].unique())
            unique_actors = df_summed_op['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Cumulative Municipality 2025 in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_op[(df_summed_op['Actor'] == actor) & (df_summed_op['Sector'] == sector)]['Cumulative Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp = pd.DataFrame.from_dict(data_exp)

            #######################Savings and Income############################################

            # Filter the data for the year 2030 and cost types 'Savings' and 'Income'
            economic_db_2030 = economic_db[(economic_db['Year'] == 2025) & (economic_db['Cost type'].isin(['Savings', 'Income']))]

            # Group by actor, sector, and cost type and sum the values
            df_summed = economic_db_2030.groupby(['Actor', 'Sector', 'Cost type'], as_index=False)['Cumulative Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for (sector, cost_type), group in df_summed.groupby(['Sector', 'Cost type']):
                total_value = group['Cumulative Value'].sum()
                new_row = pd.DataFrame({
                    'Actor': ['Total'],
                    'Sector': [sector],
                    'Cost type': [cost_type],
                    'Cumulative Value': [total_value]
                })
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_si
            df_summed= pd.concat([total_df, df_summed], ignore_index=True)

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create subplots with 1 row and 2 columns
            fig = sp.make_subplots(rows=1, cols=2, subplot_titles=("Savings", "Income"))

            # Filter data for Savings and add bar trace to subplot 1
            savings_data = df_summed[df_summed['Cost type'] == 'Savings']
            savings_trace = go.Bar(x=savings_data['Actor'],
                                   y=savings_data['Cumulative Value'],
                                   marker_color=savings_data['Sector'].map(color_mapping),
                                   name='Savings'
                                   )
            fig.add_trace(savings_trace, row=1, col=1)

            # Filter data for Income and add bar trace to subplot 2
            income_data = df_summed[df_summed['Cost type'] == 'Income']
            income_trace = go.Bar(
                x=income_data['Actor'],
                y=income_data['Cumulative Value'],
                marker_color=income_data['Sector'].map(color_mapping),
                name='Income'
            )
            fig.add_trace(income_trace, row=1, col=2)

            # Update layout for the entire figure
            fig.update_layout(
                title_text=" Cumulative Savings and Income expenditure 2025 in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
                showlegend=False  # Disable the legend as it's not needed for this layout
            )
            data_exp_df = df_summed.groupby('Actor', as_index=False)['Cumulative Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed['Sector'].unique())
            unique_actors = df_summed['Actor'].unique()

            # Separate data for 'Savings' and 'Income'
            df_savings = df_summed[df_summed['Cost type'] == 'Savings']
            df_income = df_summed[df_summed['Cost type'] == 'Income']

            # Function to create the data structure for export
            def create_data_export(df, unique_sectors):
                data_exp = {"Sectors - Cumulative Municipality 2025 in SEK": list(unique_sectors)}
                unique_actors = df['Actor'].unique()

                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        value = df[(df['Actor'] == actor) & (df['Sector'] == sector)]['Cumulative Value']
                        actor_values.append(value.iloc[0] if not value.empty else 0)
                    data_exp[actor] = actor_values

                return pd.DataFrame.from_dict(data_exp).to_dict('records')

            # Create the separate data structures
            data_savings = create_data_export(df_savings, unique_sectors)
            data_income = create_data_export(df_income, unique_sectors)

        elif ECout_year == '2027 Cumulative':
            economic_db = economic_db
            ########################CAPEX###################################
            # Filter the data for the year 2030 and cost type 'CAPEX'
            economic_db_2030_cap = economic_db[(economic_db['Year'] == 2027) & (economic_db['Cost type'] == 'CAPEX')]

            # Group by actor and sector and sum the cost
            df_summed_cap = economic_db_2030_cap.groupby(['Actor', 'Sector'], as_index=False)['Cumulative Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_cap.groupby('Sector'):
                total_value = group['Cumulative Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Cumulative Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_cap
            df_summed_cap = pd.concat([total_df, df_summed_cap], ignore_index=True)


            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_cap = px.bar(df_summed_cap, x='Actor', y='Cumulative Value', color='Sector', barmode='stack',
                             color_discrete_map=color_mapping)

            fig_cap.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Cumulative CAPEX expenditure 2027 in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df = df_summed_cap.groupby('Actor', as_index=False)['Cumulative Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_cap['Sector'].unique())
            unique_actors = df_summed_cap['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Cumulative Municipality 2027 in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_cap[(df_summed_cap['Actor'] == actor) & (df_summed_cap['Sector'] == sector)]['Cumulative Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp1 = pd.DataFrame.from_dict(data_exp)

            ###################OPEX################################

            # Filter the data for the year 2030 and cost type 'opex'
            economic_db_2030_op = economic_db[(economic_db['Year'] == 2027) & (economic_db['Cost type'] == 'OPEX')]

            # Group by actor and sector and sum the cost
            df_summed_op = economic_db_2030_op.groupby(['Actor', 'Sector'], as_index=False)['Cumulative Value'].sum()
            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_op.groupby('Sector'):
                total_value = group['Cumulative Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Cumulative Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_op
            df_summed_op = pd.concat([total_df, df_summed_op], ignore_index=True)

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_op = px.bar(df_summed_op, x='Actor', y='Cumulative Value', color='Sector', barmode='stack',
                            color_discrete_map=color_mapping)

            fig_op.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Cumulative OPEX expenditure 2027 in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df = df_summed_op.groupby('Actor', as_index=False)['Cumulative Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_op['Sector'].unique())
            unique_actors = df_summed_op['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Cumulative Municipality 2027 in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_op[(df_summed_op['Actor'] == actor) & (df_summed_op['Sector'] == sector)]['Cumulative Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp = pd.DataFrame.from_dict(data_exp)

            #######################Savings and Income############################################

            # Filter the data for the year 2030 and cost types 'Savings' and 'Income'
            economic_db_2030 = economic_db[(economic_db['Year'] == 2027) & (economic_db['Cost type'].isin(['Savings', 'Income']))]

            # Group by actor, sector, and cost type and sum the values
            df_summed = economic_db_2030.groupby(['Actor', 'Sector', 'Cost type'], as_index=False)['Cumulative Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for (sector, cost_type), group in df_summed.groupby(['Sector', 'Cost type']):
                total_value = group['Cumulative Value'].sum()
                new_row = pd.DataFrame({
                    'Actor': ['Total'],
                    'Sector': [sector],
                    'Cost type': [cost_type],
                    'Cumulative Value': [total_value]
                })
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_si
            df_summed= pd.concat([total_df, df_summed], ignore_index=True)

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create subplots with 1 row and 2 columns
            fig = sp.make_subplots(rows=1, cols=2, subplot_titles=("Savings", "Income"))

            # Filter data for Savings and add bar trace to subplot 1
            savings_data = df_summed[df_summed['Cost type'] == 'Savings']
            savings_trace = go.Bar(x=savings_data['Actor'],
                                   y=savings_data['Cumulative Value'],
                                   marker_color=savings_data['Sector'].map(color_mapping),
                                   name='Savings'
                                   )
            fig.add_trace(savings_trace, row=1, col=1)

            # Filter data for Income and add bar trace to subplot 2
            income_data = df_summed[df_summed['Cost type'] == 'Income']
            income_trace = go.Bar(
                x=income_data['Actor'],
                y=income_data['Cumulative Value'],
                marker_color=income_data['Sector'].map(color_mapping),
                name='Income'
            )
            fig.add_trace(income_trace, row=1, col=2)

            # Update layout for the entire figure
            fig.update_layout(
                title_text=" Cumulative Savings and Income expenditure 2027 in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
                showlegend=False  # Disable the legend as it's not needed for this layout
            )
            data_exp_df = df_summed.groupby('Actor', as_index=False)['Cumulative Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed['Sector'].unique())
            unique_actors = df_summed['Actor'].unique()

            # Separate data for 'Savings' and 'Income'
            df_savings = df_summed[df_summed['Cost type'] == 'Savings']
            df_income = df_summed[df_summed['Cost type'] == 'Income']

            # Function to create the data structure for export
            def create_data_export(df, unique_sectors):
                data_exp = {"Sectors - Cumulative Municipality 2027 in SEK": list(unique_sectors)}
                unique_actors = df['Actor'].unique()

                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        value = df[(df['Actor'] == actor) & (df['Sector'] == sector)]['Cumulative Value']
                        actor_values.append(value.iloc[0] if not value.empty else 0)
                    data_exp[actor] = actor_values

                return pd.DataFrame.from_dict(data_exp).to_dict('records')

            # Create the separate data structures
            data_savings = create_data_export(df_savings, unique_sectors)
            data_income = create_data_export(df_income, unique_sectors)

        elif ECout_year == '2030 Cumulative':
            economic_db = economic_db
            ########################CAPEX###################################
            # Filter the data for the year 2030 and cost type 'CAPEX'
            economic_db_2030_cap = economic_db[(economic_db['Year'] == 2030) & (economic_db['Cost type'] == 'CAPEX')]

            # Group by actor and sector and sum the cost
            df_summed_cap = economic_db_2030_cap.groupby(['Actor', 'Sector'], as_index=False)['Cumulative Value'].sum()

            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_cap.groupby('Sector'):
                total_value = group['Cumulative Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Cumulative Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_cap
            df_summed_cap = pd.concat([total_df, df_summed_cap], ignore_index=True)

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_cap = px.bar(df_summed_cap, x='Actor', y='Cumulative Value', color='Sector', barmode='stack',
                             color_discrete_map=color_mapping)

            fig_cap.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Cumulative CAPEX expenditure 2030 in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df = df_summed_cap.groupby('Actor', as_index=False)['Cumulative Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_cap['Sector'].unique())
            unique_actors = df_summed_cap['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Cumulative Municipality 2030 in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_cap[(df_summed_cap['Actor'] == actor) & (df_summed_cap['Sector'] == sector)]['Cumulative Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp1 = pd.DataFrame.from_dict(data_exp)

            ###################OPEX################################

            # Filter the data for the year 2030 and cost type 'opex'
            economic_db_2030_op = economic_db[(economic_db['Year'] == 2030) & (economic_db['Cost type'] == 'OPEX')]

            # Group by actor and sector and sum the cost
            df_summed_op = economic_db_2030_op.groupby(['Actor', 'Sector'], as_index=False)['Cumulative Value'].sum()
            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for sector, group in df_summed_op.groupby('Sector'):
                total_value = group['Cumulative Value'].sum()
                new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Cumulative Value': [total_value]})
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_op
            df_summed_op = pd.concat([total_df, df_summed_op], ignore_index=True)

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create the stacked bar chart with specific colors for each sector
            fig_op = px.bar(df_summed_op, x='Actor', y='Cumulative Value', color='Sector', barmode='stack',
                            color_discrete_map=color_mapping)

            fig_op.update_layout(
                margin=dict(l=40, r=20, b=10, t=60),
                autosize=True,
                title_text="Cumulative OPEX expenditure 2030 in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
            )
            data_exp_df = df_summed_op.groupby('Actor', as_index=False)['Cumulative Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed_op['Sector'].unique())
            unique_actors = df_summed_op['Actor'].unique()

            # Initialize the dictionary with "Sectors" as the first key
            data_exp = {"Sectors - Cumulative Municipality 2030 in SEK": list(unique_sectors)}

            # Loop through each unique actor to populate the dictionary
            for actor in unique_actors:
                actor_values = []
                for sector in unique_sectors:
                    value = df_summed_op[(df_summed_op['Actor'] == actor) & (df_summed_op['Sector'] == sector)]['Cumulative Value']
                    actor_values.append(value.iloc[0] if not value.empty else 0)
                data_exp[actor] = actor_values

            # Create a DataFrame from this data
            df_exp = pd.DataFrame.from_dict(data_exp)

            #######################Savings and Income############################################

            # Filter the data for the year 2030 and cost types 'Savings' and 'Income'
            economic_db_2030 = economic_db[(economic_db['Year'] == 2030) & (economic_db['Cost type'].isin(['Savings', 'Income']))]

            # Group by actor, sector, and cost type and sum the values
            df_summed = economic_db_2030.groupby(['Actor', 'Sector', 'Cost type'], as_index=False)['Cumulative Value'].sum()
            # Create a separate DataFrame for the Total rows
            total_df = pd.DataFrame()

            for (sector, cost_type), group in df_summed.groupby(['Sector', 'Cost type']):
                total_value = group['Cumulative Value'].sum()
                new_row = pd.DataFrame({
                    'Actor': ['Total'],
                    'Sector': [sector],
                    'Cost type': [cost_type],
                    'Cumulative Value': [total_value]
                })
                total_df = pd.concat([total_df, new_row], ignore_index=True)

            # Concatenate the Total DataFrame with the original df_summed_si
            df_summed= pd.concat([total_df, df_summed], ignore_index=True)

            # Define a dictionary to map sectors to colors
            color_mapping = {
                "Agriculture": "#ef553b",
                "Consumption & material use": "#FECB52",
                "Energy": "#9467bd",
                "The Built environment": "#ff7f0e",
                "Transport": "#e377c2",
                "Industry": "#1f77b4",
                "Negative emission solutions": "#d62728"
            }

            # Create subplots with 1 row and 2 columns
            fig = sp.make_subplots(rows=1, cols=2, subplot_titles=("Savings", "Income"))

            # Filter data for Savings and add bar trace to subplot 1
            savings_data = df_summed[df_summed['Cost type'] == 'Savings']
            savings_trace = go.Bar(x=savings_data['Actor'],
                                   y=savings_data['Cumulative Value'],
                                   marker_color=savings_data['Sector'].map(color_mapping),
                                   name='Savings'
                                   )
            fig.add_trace(savings_trace, row=1, col=1)

            # Filter data for Income and add bar trace to subplot 2
            income_data = df_summed[df_summed['Cost type'] == 'Income']
            income_trace = go.Bar(
                x=income_data['Actor'],
                y=income_data['Cumulative Value'],
                marker_color=income_data['Sector'].map(color_mapping),
                name='Income'
            )
            fig.add_trace(income_trace, row=1, col=2)

            # Update layout for the entire figure
            fig.update_layout(
                title_text=" Cumulative Savings and Income expenditure 2030 in {} (SEK)".format(mun),
                title_font=dict(size=18, color="darkred"),
                yaxis=dict(
                    title='SEK',
                    showgrid=True,
                    gridcolor='lightgray',
                    gridwidth=0.5,
                ),
                showlegend=False  # Disable the legend as it's not needed for this layout
            )
            data_exp_df = df_summed.groupby('Actor', as_index=False)['Cumulative Value'].sum()
            # Get unique sectors and actors
            unique_sectors = sorted(df_summed['Sector'].unique())
            unique_actors = df_summed['Actor'].unique()

            # Separate data for 'Savings' and 'Income'
            df_savings = df_summed[df_summed['Cost type'] == 'Savings']
            df_income = df_summed[df_summed['Cost type'] == 'Income']

            # Function to create the data structure for export
            def create_data_export(df, unique_sectors):
                data_exp = {"Sectors - Cumulative Municipality 2030 in SEK": list(unique_sectors)}
                unique_actors = df['Actor'].unique()

                for actor in unique_actors:
                    actor_values = []
                    for sector in unique_sectors:
                        value = df[(df['Actor'] == actor) & (df['Sector'] == sector)]['Cumulative Value']
                        actor_values.append(value.iloc[0] if not value.empty else 0)
                    data_exp[actor] = actor_values

                return pd.DataFrame.from_dict(data_exp).to_dict('records')

            # Create the separate data structures
            data_savings = create_data_export(df_savings, unique_sectors)
            data_income = create_data_export(df_income, unique_sectors)

    if NPV == 'Total Cumulative NPV 2030':
        economic_db_NPV = economic_db_NPV

        # Filter the data for the year 2030
        economic_db_2030 = economic_db_NPV[economic_db_NPV['Year'] == 2030]

        # Ensure the 'Cost type' is one of the desired types
        cost_types = ['CAPEX', 'OPEX', 'Savings', 'Income']
        economic_db_2030 = economic_db_2030[economic_db_2030['Cost type'].isin(cost_types)]

        # Group by actor, sector, and cost type and sum the cost
        df_summed = economic_db_2030.groupby(['Actor', 'Sector'], as_index=False)['Cumulative NPV'].sum()

        # Create a separate DataFrame for the Total rows
        total_df = pd.DataFrame()

        for sector, group in df_summed.groupby('Sector'):
            total_value = group['Cumulative NPV'].sum()
            new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Cumulative NPV': [total_value]})
            total_df = pd.concat([total_df, new_row], ignore_index=True)

        # Concatenate the Total DataFrame with the original df_summed
        df_summed = pd.concat([total_df, df_summed], ignore_index=True)

        # Define a dictionary to map sectors to colors
        color_mapping = {
            "Agriculture": "#ef553b",
            "Consumption & material use": "#FECB52",
            "Energy": "#9467bd",
            "The Built environment": "#ff7f0e",
            "Transport": "#e377c2",
            "Industry": "#1f77b4",
            "Negative emission solutions": "#d62728"
        }

        # Create the stacked bar chart with specific colors for each sector
        fig_npv = px.bar(df_summed, x='Actor', y='Cumulative NPV', color='Sector', barmode='stack',
                         color_discrete_map=color_mapping)

        fig_npv.update_layout(
            margin=dict(l=40, r=20, b=10, t=60),
            autosize=True,
            title_text="Total Cumulative NPV 2030 in {} (SEK) (excluding Co-benefits)".format(mun),
            title_font=dict(size=18, color="darkred"),
            yaxis=dict(
                title='SEK',
                showgrid=True,
                gridcolor='lightgray',
                gridwidth=0.5,
            ),
        )
        # Data Transformation for Export/Download
        data_npv_df1 = df_summed.groupby('Actor', as_index=False)['Cumulative NPV'].sum()
        # Get unique sectors and actors
        unique_sectors_npv = sorted(df_summed['Sector'].unique())
        unique_actors_npv = df_summed['Actor'].unique()

        # Initialize the dictionary with "Sectors" as the first key
        data_npv = {"Sectors - Cumulative NPV 2030 in SEK": list(unique_sectors_npv)}

        # Loop through each unique actor to populate the dictionary
        for actor in unique_actors_npv:
            actor_values = []
            for sector in unique_sectors_npv:
                value = df_summed[(df_summed['Actor'] == actor) & (df_summed['Sector'] == sector)]['Cumulative NPV']
                actor_values.append(value.iloc[0] if not value.empty else 0)
            data_npv[actor] = actor_values

        # Create a DataFrame from this data
        df_npv_exp = pd.DataFrame.from_dict(data_npv)

    elif NPV == 'Annual average NPV (2021-2030)':
        economic_db_NPV = economic_db_NPV

        # Filter the data for the year 2030
        economic_db_2030 = economic_db_NPV[economic_db_NPV['Year'] == 2030]

        # Ensure the 'Cost type' is one of the desired types
        cost_types = ['CAPEX', 'OPEX', 'Savings', 'Income']
        economic_db_2030 = economic_db_2030[economic_db_2030['Cost type'].isin(cost_types)]

        # Group by actor, sector, and cost type and sum the cost
        df_summed = economic_db_2030.groupby(['Actor', 'Sector'], as_index=False)['Cumulative NPV'].sum()

        # Divide the 'Cumulative NPV' by 10 to get the annual average of NPV
        df_summed['Cumulative NPV'] = df_summed['Cumulative NPV'] / 10

        # Create a separate DataFrame for the Total rows
        total_df = pd.DataFrame()

        for sector, group in df_summed.groupby('Sector'):
            total_value = group['Cumulative NPV'].sum()
            new_row = pd.DataFrame({'Actor': ['Total'], 'Sector': [sector], 'Cumulative NPV': [total_value]})
            total_df = pd.concat([total_df, new_row], ignore_index=True)

        # Concatenate the Total DataFrame with the original df_summed
        df_summed = pd.concat([total_df, df_summed], ignore_index=True)

        # Define a dictionary to map sectors to colors
        color_mapping = {
            "Agriculture": "#ef553b",
            "Consumption & material use": "#FECB52",
            "Energy": "#9467bd",
            "The Built environment": "#ff7f0e",
            "Transport": "#e377c2",
            "Industry": "#1f77b4",
            "Negative emission solutions": "#d62728"
        }

        # Create the stacked bar chart with specific colors for each sector
        fig_npv = px.bar(df_summed, x='Actor', y='Cumulative NPV', color='Sector', barmode='stack',
                         color_discrete_map=color_mapping)

        fig_npv.update_layout(
            margin=dict(l=40, r=20, b=10, t=60),
            autosize=True,
            title_text="Annual average NPV in {} (SEK) (excluding Co-benefits)".format(mun),
            title_font=dict(size=18, color="darkred"),
            yaxis=dict(
                title='SEK',
                showgrid=True,
                gridcolor='lightgray',
                gridwidth=0.5,
            ),
        )
        # Data Transformation for Export/Download
        data_npv_df1 = df_summed.groupby('Actor', as_index=False)['Cumulative NPV'].sum()
        # Get unique sectors and actors
        unique_sectors_npv = sorted(df_summed['Sector'].unique())
        unique_actors_npv = df_summed['Actor'].unique()

        # Initialize the dictionary with "Sectors" as the first key
        data_npv = {"Sectors - Annual average NPV in SEK": list(unique_sectors_npv)}

        # Loop through each unique actor to populate the dictionary
        for actor in unique_actors_npv:
            actor_values = []
            for sector in unique_sectors_npv:
                value = df_summed[(df_summed['Actor'] == actor) & (df_summed['Sector'] == sector)]['Cumulative NPV']
                actor_values.append(value.iloc[0] if not value.empty else 0)
            data_npv[actor] = actor_values

        # Create a DataFrame from this data
        df_npv_exp = pd.DataFrame.from_dict(data_npv)

    return [fig_cap, fig_op, fig, fig_npv, df_exp1.to_dict('records'), df_exp.to_dict('records'),{"Savings": data_savings, "Income": data_income}, df_npv_exp.to_dict('records')]

@app.callback(
    Output("download-capex-tbe-text", "data"),
    [Input("btn-download-capex-tbe", "n_clicks"), Input("dd-capex-value", "data")],
    [State("municipality-dropdown", "value")],
    prevent_initial_call=True)
def download_capex_button(n_clicks, value, mun):
    ctx = dash.callback_context
    button_id = ctx.triggered[0]["prop_id"].split(".")[0]

    if n_clicks is not None and button_id == "btn-download-capex-tbe":
        # Create DataFrame from the received data
        df = pd.DataFrame.from_dict(value)

        # If your DataFrame is transposed, you can transpose it back
        # df = df.transpose()

        return dcc.send_data_frame(df.to_csv,
                                   filename=f'CAPEX-tbe-{mun}.csv',
                                   header=True,
                                   index=False)

    elif n_clicks in [0, None]:
        raise PreventUpdate

    elif button_id != "btn-download-capex-tbe":
        raise PreventUpdate

@app.callback(
    Output("download-opex-tbe-text", "data"),
    [Input("btn-download-opex-tbe", "n_clicks"), Input("dd-opex-value", "data")],
    [State("municipality-dropdown", "value")],
    prevent_initial_call=True)
def download_capex_button(n_clicks, value, mun):
    ctx = dash.callback_context
    button_id = ctx.triggered[0]["prop_id"].split(".")[0]

    if n_clicks is not None and button_id == "btn-download-opex-tbe":
        # Create DataFrame from the received data
        df = pd.DataFrame.from_dict(value)

        # If your DataFrame is transposed, you can transpose it back
        # df = df.transpose()

        return dcc.send_data_frame(df.to_csv,
                                   filename=f'opex-tbe-{mun}.csv',
                                   header=True,
                                   index=False)

    elif n_clicks in [0, None]:
        raise PreventUpdate

    elif button_id != "btn-download-opex-tbe":
        raise PreventUpdate

@app.callback(
    Output("download-si-tbe-text", "data"),
    [Input("btn-download-si-tbe", "n_clicks"), Input("dd-si-value", "data")],
    [State("municipality-dropdown", "value")],
    prevent_initial_call=True)
def download_capex_button(n_clicks, value, mun):
    ctx = dash.callback_context
    button_id = ctx.triggered[0]["prop_id"].split(".")[0]

    if n_clicks is not None and button_id == "btn-download-si-tbe":

        # Create an in-memory bytes buffer
        output = io.BytesIO()

        # Create an Excel writer with this buffer
        writer = pd.ExcelWriter(output, engine='xlsxwriter')

        # Convert Savings and Income data to DataFrames and write to the Excel writer
        df_savings = pd.DataFrame.from_dict(value['Savings'])
        df_savings.to_excel(writer, sheet_name='Savings', index=False)

        df_income = pd.DataFrame.from_dict(value['Income'])
        df_income.to_excel(writer, sheet_name='Income', index=False)

        writer.close()

        # Seek to the beginning of the stream
        output.seek(0)

        return dcc.send_bytes(output.getvalue(),
                              filename=f'SI-tbe-{mun}.xlsx',
                              mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')

    elif n_clicks in [0, None]:
        raise PreventUpdate

    elif button_id != "btn-download-si-tbe":
        raise PreventUpdate

@app.callback(
    Output("download-NPV-tbe-text", "data"),  # Adjusted for NPV
    [Input("btn-download-NPV-tbe", "n_clicks"), Input("dd-NPV-value", "data")],  # Adjusted for NPV
    [State("municipality-dropdown", "value")],
    prevent_initial_call=True)
def download_npv_button(n_clicks, value, mun):  # Adjusted function name for NPV
    ctx = dash.callback_context
    button_id = ctx.triggered[0]["prop_id"].split(".")[0]

    if n_clicks is not None and button_id == "btn-download-NPV-tbe":  # Adjusted for NPV
        # Create DataFrame from the received data
        df = pd.DataFrame.from_dict(value)

        # If your DataFrame is transposed, you can transpose it back
        # df = df.transpose()

        return dcc.send_data_frame(df.to_csv,
                                   filename=f'NPV-{mun}.csv',  # Adjusted filename for NPV
                                   header=True,
                                   index=False)

    elif n_clicks in [0, None]:
        raise PreventUpdate

    elif button_id != "btn-download-NPV-tbe":  # Adjusted for NPV
        raise PreventUpdate


@app.callback(
    Output("download-total-tbe-text", "data"),
    [Input("btn-download-total-tbe", "n_clicks"),
     Input("dd-emissions-value2", "data"),
     Input("dd-ci-value", "data"),
     Input("dd-capex-value", "data"),
     Input("dd-opex-value", "data"),
     Input("dd-si-value", "data"),
     Input("dd-NPV-value", "data")] +
    [Input(f"slider-{i}", "value") for i in range(27, 58)] + [Input("slider-541", "value")],
    [State("scenario-dropdown-list-2", "value"),
     State("municipality-dropdown", "value")],
    prevent_initial_call=True
)
def consolidated_download (n_clicks, emissions_value, ci_value, capex_value, opex_value, si_value, npv_value, *args):
    ctx = dash.callback_context
    button_id = ctx.triggered[0]["prop_id"].split(".")[0]
    if button_id != "btn-download-total-tbe":
        raise PreventUpdate

    slider_values = args[:-2]
    scenario, mun = args[-2:]

    # Ensure emissions_value is not None or empty
    if not emissions_value:
        raise PreventUpdate

    # Convert emissions_value to DataFrame
    df_emissions_slider = pd.DataFrame(emissions_value).transpose()

    # Now, you can use df_emissions_slider
    index_range = range(1, len(df_emissions_slider.iloc[:, 0].to_list()) + 1)
    slider_names = {
        "slider-27": "Agriculture",
        "slider-28": "Consumption and Material use",
        "slider-29": "Electric bus",
        "slider-30": "HVO bus",
        "slider-31": "Current bus fleet",
        "slider-32": "Air travel",
        "slider-33": "Electric cars",
        "slider-34": "Active transport",
        "slider-35": "Shift to Public transport from cars",
        "slider-36": "Current car fleet",
        "slider-37": "Plug in hybrid cars",
        "slider-38": "Hydrogen cars",
        "slider-39": "Heavy trucks biogas",
        "slider-40": "Heavy trucks electric",
        "slider-41": "Light trucks biogas",
        "slider-42": "Light trucks electric",
        "slider-43": "CCS waste",
        "slider-44": "electricity from wind",
        "slider-45": "electricity from rooftop solar",
        "slider-46": "electricity from centralised solar",
        "slider-47": "Existing energy production mix",
        "slider-48": "DH heat pumps",
        "slider-49": "Reduced indoor temp. 20C",
        "slider-50": "EE measures (S&N)",
        "slider-51": "BAT appliances",
        "slider-52": "No heat measure",
        "slider-53": "Industry CCS",
        "slider-54": "Hydrogen production for Industry",
        "slider-55": "Bio-CCS or DACCS",
        "slider-56": "Rewetting",
        "slider-57": "Carbon credit",
        "slider-541": "Work machinery"
    }

    df_sliders = pd.DataFrame({
        'Measures': [slider_names.get(f"slider-{i}", f"slider-{i}") for i in list(range(27, 58)) + [541]],
        'Value %': slider_values
    })

    df0 = pd.DataFrame(df_emissions_slider.iloc[:, 0].to_list(), columns=["Sector"], index=index_range)
    df1 = pd.DataFrame(df_emissions_slider.iloc[:, 1].to_list(),
                       columns=[f'Forecasted {year}' for year in range(2021, 2031)], index=index_range)
    df2 = pd.DataFrame(df_emissions_slider.iloc[:, 2].to_list(),
                       columns=[f'Action plan {year}' for year in range(2021, 2031)], index=index_range)
    df_emissions = pd.concat([df0, df1, df2], axis=1)

    # Co-benefits (ci) data extraction
    df_ci = pd.DataFrame.from_dict(ci_value)

    # CAPEX data extraction
    df_capex = pd.DataFrame.from_dict(capex_value)

    # OPEX data extraction
    df_opex = pd.DataFrame.from_dict(opex_value)

    # Savings and Income data extraction
    df_si_savings = pd.DataFrame.from_dict(si_value['Savings'])
    df_si_income = pd.DataFrame.from_dict(si_value['Income'])

    # NPV data extraction
    df_npv = pd.DataFrame.from_dict(npv_value)

    # Save all DataFrames to an Excel file with multiple sheets
    output = io.BytesIO()
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
        df_sliders.to_excel(writer, sheet_name="Implemented measures", index=False)
        df_emissions.to_excel(writer, sheet_name="Emissions Data", index=False)
        df_ci.to_excel(writer, sheet_name="Co-benefits", index=False)
        df_capex.to_excel(writer, sheet_name="CAPEX", index=False)
        df_opex.to_excel(writer, sheet_name="OPEX", index=False)
        df_si_savings.to_excel(writer, sheet_name="Savings", index=False)
        df_si_income.to_excel(writer, sheet_name="Income", index=False)
        df_npv.to_excel(writer, sheet_name="NPV", index=False)

    output.seek(0)
    return dcc.send_bytes(output.getvalue(),
                          filename=f'Consolidated-VC-dashboard-outputs-{mun}-{scenario}.xlsx',
                          mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')


@app.callback(
    [
        Output("collapse-1", "is_open"),
        Output("clothing-collapse", "is_open"),
        Output("housing-collapse", "is_open"),
        Output("transport-collapse", "is_open"),
        Output("air-collapse", "is_open"),
        Output("recreation-collapse", "is_open"),
        Output("rh-collapse", "is_open"),
        Output("vehicles-collapse", "is_open"),
        Output("electricity-collapse", "is_open"),
        Output("dh-collapse", "is_open"),
        Output("hh-collapse", "is_open"),
    ],
    [
        Input("food-collapse", "n_clicks"),
        Input("clothing-collapse-button", "n_clicks"),
        Input("housing-collapse-button", "n_clicks"),
        Input("transport-collapse-button", "n_clicks"),
        Input("air-collapse-button", "n_clicks"),
        Input("recreation-collapse-button", "n_clicks"),
        Input("rh-collapse-button", "n_clicks"),
        Input("vehicles-collapse-button", "n_clicks"),
        Input("electricity-collapse-button", "n_clicks"),
        Input("dh-collapse-button", "n_clicks"),
        Input("hh-collapse-button", "n_clicks")
    ],
    [State("collapse-1", "is_open"),
    State("clothing-collapse", "is_open"),
    State("housing-collapse", "is_open"),
    State("transport-collapse", "is_open"),
    State("air-collapse", "is_open"),
    State("recreation-collapse", "is_open"),
    State("rh-collapse", "is_open"),
    State("vehicles-collapse", "is_open"),
    State("electricity-collapse", "is_open"),
    State("dh-collapse", "is_open"),
    State("hh-collapse", "is_open"),
    ]
)
def cbe_toggle_collapses(b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11):
    ctx = dash.callback_context

    button_id=ctx.triggered[0]["prop_id"].split(".")[0]

    if button_id == "food-collapse":
        if b1:
            return [not is_open1, False, False, False, False, False, False, False, False, False, False]
        return [is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11]
    if button_id == "clothing-collapse-button":
        if b2:
            return [False, not is_open2, False, False, False, False, False, False, False, False, False]
        return [is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11]
    if button_id == "housing-collapse-button":
        if b3:
            return [False, False, not is_open3, False, False, False, False, False, False, False, False]
        return [is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11]
    if button_id == "transport-collapse-button":
        if b4:
            return [False, False, False, not is_open4, False, False, False, False, False, False, False]
        return [is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11]
    if button_id == "air-collapse-button":
        if b5:
            return [False, False, False, False, not is_open5, False, False, False, False, False, False]
        return [is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11]
    if button_id == "recreation-collapse-button":
        if b6:
            return [False, False, False, False, False, not is_open6, False, False, False, False, False]
        return [is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11]
    if button_id == "rh-collapse-button":
        if b7:
            return [False, False, False, False, False, False, not is_open7, False, False, False, False]
        return [is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11]
    if button_id == "vehicles-collapse-button":
        if b8:
            return [False, False, False, False, False, False, False, not is_open8, False, False, False]
        return [is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11]
    if button_id == "electricity-collapse-button":
        if b9:
            return [False, False, False, False, False, False, False, False, not is_open9, False, False]
        return [is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11]
    if button_id == "dh-collapse-button":
        if b10:
            return [False, False, False, False, False, False, False, False, False, not is_open10, False]
        return [is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11]
    if button_id == "hh-collapse-button":
        if b11:
            return [False, False, False, False, False, False, False, False, False, False, not is_open11]
        return [is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11]

@app.callback(
    [
        Output("transport-service-collapse", "is_open"),
        Output("air-transport-collapse", "is_open"),
        Output("vehicles-cars-collapse", "is_open"),
        Output("ccsw-collapse", "is_open"),
        Output("heavy-collapse", "is_open"),
        Output("LT-collapse", "is_open"),
        Output("buildingren-collapse", "is_open"),
        Output("Energy-collapse", "is_open"),
        Output("industry-collapse", "is_open"),
        Output("NET-collapse", "is_open"),
        Output("DH1-collapse", "is_open"),
        Output("Agriculture-collapse", "is_open"),
        Output("CMU-collapse", "is_open")
    ],
    [
        Input("transport-service-collapse-button", "n_clicks"),
        Input("air-transport-collapse-button", "n_clicks"),
        Input("vehicles-cars-collapse-button", "n_clicks"),
        Input("ccsw-collapse-button", "n_clicks"),
        Input("heavy-collapse-button", "n_clicks"),
        Input("LT-collapse-button", "n_clicks"),
        Input("buildingren-collapse-button", "n_clicks"),
        Input("Energy-collapse-button", "n_clicks"),
        Input("industry-collapse-button", "n_clicks"),
        Input("NET-collapse-button", "n_clicks"),
        Input("DH1-collapse-button", "n_clicks"),
        Input("Agriculture-collapse-button", "n_clicks"),
        Input("CMU-collapse-button", "n_clicks")
    ],
    [
        State("transport-service-collapse", "is_open"),
        State("air-transport-collapse", "is_open"),
        State("vehicles-cars-collapse", "is_open"),
        State("ccsw-collapse", "is_open"),
        State("heavy-collapse", "is_open"),
        State("LT-collapse", "is_open"),
        State("buildingren-collapse", "is_open"),
        State("Energy-collapse", "is_open"),
        State("industry-collapse", "is_open"),
        State("NET-collapse", "is_open"),
        State("DH1-collapse", "is_open"),
        State("Agriculture-collapse", "is_open"),
        State("CMU-collapse", "is_open")
    ]
)
def tbe_toggle_collapses(b1, b2, b3, b4, b5, b6, b7, b8, b9,b10,b11,b12,b13, is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11, is_open12, is_open13):
    ctx = dash.callback_context

    button_id=ctx.triggered[0]["prop_id"].split(".")[0]

    if button_id == "transport-service-collapse-button":
        if b1:
            return not is_open1, False, False, False, False, False, False, False, False, False, False, False, False
        return is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11, is_open12, is_open13
    if button_id == "air-transport-collapse-button":
        if b2:
            return False, not is_open2, False, False, False, False, False, False, False, False, False, False, False
        return is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11, is_open12, is_open13
    if button_id == "vehicles-cars-collapse-button":
        if b3:
            return False, False, not is_open3, False, False, False, False, False, False, False, False, False, False
        return is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11, is_open12, is_open13
    if button_id == "ccsw-collapse-button":
        
        if b4:
            return False, False, False, not is_open4, False, False, False, False, False, False, False, False, False
        return is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11, is_open12, is_open13
    if button_id == "heavy-collapse-button":
        if b5:
            return False, False, False, False, not is_open5, False, False, False, False, False, False, False, False
        return is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11, is_open12, is_open13
    if button_id == "LT-collapse-button":
        if b6:
            return False, False, False, False, False,not is_open6, False, False, False, False, False, False, False
        return is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11, is_open12, is_open13
    if button_id == "buildingren-collapse-button":
        if b7:
            return False, False, False, False, False, False, not is_open7, False, False, False, False, False, False
        return is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11, is_open12, is_open13
    if button_id == "Energy-collapse-button":
        if b8:
            return False, False, False, False, False, False,False,  not is_open8, False, False, False, False, False
        return is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11, is_open12, is_open13
    if button_id == "industry-collapse-button":
        if b9:
            return False, False, False, False, False, False,False, False, not is_open9, False, False, False, False
        return is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11, is_open12, is_open13
    if button_id == "NET-collapse-button":
        if b10:
            return False, False, False, False, False, False,False, False, False, not is_open10, False, False, False
        return is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11, is_open12, is_open13
    if button_id == "DH1-collapse-button":
        if b11:
            return False, False, False, False, False, False,False, False, False, False, not is_open11, False, False
        return is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11, is_open12, is_open13
    if button_id == "Agriculture-collapse-button":
        if b12:
            return False, False, False, False, False, False,False, False, False, False, False,not is_open12, False
        return is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11, is_open12, is_open13
    if button_id == "CMU-collapse-button":
        if b13:
            return False, False, False, False, False, False,False, False, False, False, False, False,not is_open13
        return is_open1, is_open2, is_open3, is_open4, is_open5, is_open6, is_open7, is_open8, is_open9, is_open10, is_open11, is_open12, is_open13
    
@app.callback(
    [
        Output("transport-service-collapse2", "is_open"),
        Output("air-transport-collapse2", "is_open"),
        Output("vehicles-cars-collapse2", "is_open"),
        Output("el-collapse2", "is_open"),
        Output("house-heating-collapse2", "is_open"),
        Output("heavy-collapse2", "is_open")
    ],
    [
        Input("transport-service-collapse-button2", "n_clicks"),
        Input("air-transport-collapse-button2", "n_clicks"),
        Input("vehicles-cars-collapse-button2", "n_clicks"),
        Input("el-collapse-button2", "n_clicks"),
        Input("house-heating-collapse-button2", "n_clicks"),
        Input("heavy-collapse-button2", "n_clicks")
    ],
    [
        State("transport-service-collapse2", "is_open"),
        State("air-transport-collapse2", "is_open"),
        State("vehicles-cars-collapse2", "is_open"),
        State("el-collapse2", "is_open"),
        State("house-heating-collapse2", "is_open"),
        State("heavy-collapse2", "is_open")
    ]
)
def tbe_toggle_collapses2(b1, b2, b3, b4, b5, b6, is_open1, is_open2, is_open3, is_open4, is_open5, is_open6):
    ctx = dash.callback_context

    button_id=ctx.triggered[0]["prop_id"].split(".")[0]

    if button_id == "transport-service-collapse-button2":
        if b1:
            return not is_open1, False, False, False, False, False
        return is_open1, is_open2, is_open3, is_open4, is_open5, is_open6
    if button_id == "air-transport-collapse-button2":
        if b2:
            return False, not is_open2, False, False, False, False
        return is_open1, is_open2, is_open3, is_open4, is_open5, is_open6
    if button_id == "vehicles-cars-collapse-button2":
        if b3:
            return False, False, not is_open3, False, False, False
        return is_open1, is_open2, is_open3, is_open4, is_open5, is_open6
    if button_id == "el-collapse-button2":
        if b4:
            return False, False, False, not is_open4, False, False
        return is_open1, is_open2, is_open3, is_open4, is_open5, is_open6
    if button_id == "house-heating-collapse-button2":
        if b5:
            return False, False, False, False, not is_open5, False
        return is_open1, is_open2, is_open3, is_open4, is_open5, is_open6
    if button_id == "heavy-collapse-button2":
        if b6:
            return False, False, False, False, False, not is_open6
        return is_open1, is_open2, is_open3, is_open4, is_open5, is_open6

@app.callback(
    Output("glossary-modal", "is_open"),
    [Input("glossary-button", "n_clicks")],
    [State("glossary-modal", "is_open")]
)
def glossary_modal(n, is_open):
    if n:
        return not is_open

@app.callback(
    Output("methodology-modal", "is_open"),
    [Input("methodology-button", "n_clicks")],
    [State("methodology-modal", "is_open")]
)
def methodology_modal(n, is_open):
    if n:
        return not is_open

@app.callback(
    Output("info-modal", "is_open"),
    [Input("modal-opener", "n_clicks"), Input("modal-closer", "n_clicks")],
    [State("info-modal", "is_open")],
)
def toggle_modal(n1, n2, is_open):
    if n1 or n2:
        return not is_open
    return is_open

@app.callback(
    Output("municipality-dropdown", "options"),
    Output("VC-NZC-value", "data"),
    [Input("region-dropdown", "value")],
)
def dropdowns_interact(value):
    if value is None:
        return list(municipalities),0
    elif value == "Austria":
        return ["Klagenfurt"],0
    elif value == "Croatia":
        return ["Zagreb"],0
    elif value == "Cyprus":
        return ["Limassol"],0
    elif value == "Czech Republic":
        return ["Liberec"],0
    elif value == "Estonia":
        return ["Tartu"],0
    elif value == "Luxembourg":
        return ["Differdange"],0
    elif value == "Malta":
        return ["Gozo"],0
    elif value == "Iceland":
        return ["Reykjavík"],0
    elif value == "Montenegro":
        return ["Podgorica"],0
    elif value == "Israel":
        return ["Eilat"],0
    elif value == "Bosnia and Herzegovina":
        return ["Sarajevo"],0
    elif value == "Albania":
        return ["Elbasan"],0
    elif value == "Sweden":
        return list(regions_län.loc[value, "Municipality"]),1
    else:
        return list(regions_län.loc[value, "Municipality"]),0
    
@app.callback(
    Output("TBE_assumption-modal1", "is_open"),
    [Input("TBE_assumption-button", "n_clicks")],
    [State("TBE_assumption-modal1", "is_open")]
)
def TBEassumption_modal(n, is_open):
    if n:
        return not is_open
    else:
        return is_open
    
@app.callback(
     Output("download-assumptions-tbe1-text", "data"),
     Input("btn-download-assumptions-tbe1", "n_clicks"), 
     prevent_initial_call=True
)
def print_button_TBE1(n_clicks):
    data = [
    ["Factor", "Value", "Unit", "Comment", "Sources"],
    ["Diesel price per 10KM", "13", "SEK in 2022", "Cars", "Mobility Sweden"],
    ["Petrol price per 10KM", "15.2", "SEK in 2022", "Cars", "Mobility Sweden"],
    ["Electric price per 10KM", "5.5", "SEK in 2022", "Cars", "Mobility Sweden"],
    ["Hydrogen price per 10KM", "9", "SEK in 2022", "Cars", "https://vatgas.se/fakta/faq/"],
    ["Average driving distance per year of a car 10KM", "1,112", "10KM", "Cars", "Statistics Sweden"],
    ["Plug in hybrid emissions vs diesel or petrol car", "30%", "", "Cars", "https://bransch.trafikverket.se/contentassets/7ce1527807fa44ff9aa195ab440d5184/pm-vagtrafikens-utslapp-220207.pdf"],
    ["Share of petrol over (petrol and diesel cars)", "61%", "", "Cars", ""],
    ["OPEX trucks biogas extra cost compared to diesel", "0.13", "SEK/Km", "Trucks", "Swedish Biogas Association (2017)"],
    ["OPEX trucks biogas extra cost compared to diesel", "0.50", "SEK/Km", "Trucks", "Sweco (2019)"],
    ["OPEX trucks biogas extra cost compared to diesel", "0.30", "SEK/Km", "Trucks", "IVL Swedish Environmental Research Institute (2015)"],
    ["OPEX trucks biogas extra cost compared to diesel", "0.55", "SEK/Km", "Trucks", "Vattenfall AB (2016)"],
    ["OPEX trucks biogas extra cost compared to diesel", "0.35", "SEK/Km", "Trucks", "Vattenfall AB (2016)"],
    ["OPEX trucks biogas extra cost compared to diesel", "3.65", "SEK/mil", "Trucks", ""],
    ["Consumptiom per KM", "3.72", "2015", "Bus", "http://www.ecotraffic.se/media/10613/rapport_7078_-_kortversion_av_bussrapport_version_6.pdf"],
    ["OPEX Diesel consumption per 10 Km", "2.40", "Liter/mil", "Trucks", "https://www.volvotrucks.se/sv-se/news/magazine-online/2019/sep/Business-Story-Spain.html"],
    ["Diesel price per liter", "21.00", "SEK/liter", "Trucks", "https://dieselpriset.se/"],
    ["OPEX Diesel consumption per 10 Km", "50.40", "SEK/mil", "Trucks", ""],
    ["Congestion tax revenue in 2020", "2400000000", "SEK/år", "", "https://www.riksdagen.se/sv/dokument-lagar/dokument/motion/_H9023266"],
    ["Waste share of EH and DH emissions", "73%", "2021", "", "https://www.naturvardsverket.se/data-och-statistik/klimat/vaxthusgaser-utslapp-fran-el-och-fjarrvarme/"],
    ["Electricity used in housing and services", "58%", "2019", "", "https://www.scb.se/hitta-statistik/sverige-i-siffror/miljo/elektricitet-i-sverige/"],
    ["Electricity used in industry", "37%", "2019", "", "https://www.scb.se/hitta-statistik/sverige-i-siffror/miljo/elektricitet-i-sverige/"],
    ["Emission factor from heat production Malmö", "122", "g/KWH", "", "ME model uses Eon"],
    ["Emission factor from electricity production Malmö", "48", "g/KWH", "", "ME model uses Eon"],
    ["Average ETS price in 2022", "80", "euros", "", "https://www.umweltbundesamt.de/en/press/pressinformation/emissions-trading-rings-up-record-revenues-more"],
    ["Price electricity Sweden 2022", "1.07", "SEK/KWh", "", "https://www.elbruk.se/elpris-historik-2022"],
    ["From petrol to plug in hybrid - remaining emissions", "28.00%", "", "", ""],
    ["From diesel to plug in hybrid - remaining emissions", "39.00%", "", "", ""],
    ["Lifetime of a car", "16", "years", "", ""],
    ["Wind power production in Sweden in 2022", "27.1", "TWh", "", "https://www.ekonomifakta.se/fakta/energi/energibalans-i-sverige/elproduktion/"],
    ["GW to GWh conversion Wind", "2,747", "GWh/GW", "", ""],
    ["Wind power estimate by 2030 need capacity", "29.6", "GW", "Assuming we need to triple production", ""],
    ["Solar power production in Sweden in 2022", "1.1", "TWh", "", "https://www.ekonomifakta.se/fakta/energi/energibalans-i-sverige/elproduktion/"],
    ["GW to GWh conversion solar", "986.1495845", "GWh/GW", "", ""],
    ["Solar power estimate by 2030 need capacity", "3.3", "GW", "Assuming we need to triple production", ""],
    ["Bus emissions left from switching to HVO/RME/biogas fuel", "10%", "", "", "https://www.volvocars.com/se/edit/artikel/allt-om-hvo100"],
    ["Electric cars share of Swedish market", "35%", "2022", "Based on newly registered vehicles in Sweden", "https://www.transportstyrelsen.se/sv/vagtrafik/statistik/Statistik-over-koldioxidutslapp/statistik-over-koldioxidutslapp-2022/"],
    ["Plug in hybrid share of Swedish market", "23%", "2022", "", "https://www.transportstyrelsen.se/sv/vagtrafik/statistik/Statistik-over-koldioxidutslapp/statistik-over-koldioxidutslapp-2022/"],
    ["HVO use in buses today", "38%", "Sweden 2019", "", "https://energikontorsydost.se/l/kunskapsbank/56548?"],
    ["Share of Electricity and DH emissions from electricity", "40%", "Sweden", "", ""],
    ["Share of charging station for hybrid vs BEV need", "50%", "Sweden", "", "https://theicct.org/publication/europe-ldv-review-of-afir-proposal-how-much-power-output-needed-for-public-charging-infrastructure-in-the-eu-mar22/"],
    ["Share of district heating covered by heat pumps from air", "33%", "", "Mock value", "Research tbd, user can change this assumption if they want"],
    ["Share of district heating covered by heat pumps from water", "33%", "", "Mock value", "Research tbd, user can change this assumption if they want"],
    ["Share of district heating covered by heat pumps from geothermal", "33%", "", "Mock value", "Research tbd, user can change this assumption if they want"],
    ["Air heat pump emissions saving", "100%", "", "", "https://värmepumpen.se/en/byta-varmepump/#1551341900387-c6b9fb75-2364"],
    ["Air heat pump emissions saving", "100%", "", "", "https://värmepumpen.se/en/byta-varmepump/#1551341900387-c6b9fb75-2364"],
    ["Air heat pump emissions saving", "100%", "", "", "https://värmepumpen.se/en/byta-varmepump/#1551341900387-c6b9fb75-2364"],
    ["Impact from BAT appliances on energy savings", "21%", "", "Mock value", "(Savvidou and Nykvist, 2020)"],
    ["Impact from reduced temperature to 20 degrees on energy savings", "16%", "", "City-specific!", "(Savvidou and Nykvist, 2020)"],
    ["Impact from Savvidou Nykvist measures on energy savings", "16%", "", "City-specific!", "(Savvidou and Nykvist, 2020)"],
    ["CCS captures share of emissions", "90%", "", "", "https://climate.mit.edu/ask-mit/how-efficient-carbon-capture-and-storage"],
    ["Share of Carbon Credits counted towards negative emissions in net zero target", "100%", "", "", ""],
    ["Share of bio-CCS counted towards negative emissions in net zero target", "100%", "", "", ""],
    ["Share of rewetting counted towards negative emissions in net zero target", "100%", "", "", ""],
    ["Share of agricultural emissions related to methane", "53%", "", "", "https://www.naturvardsverket.se/data-och-statistik/klimat/vaxthusgaser-utslapp-fran-jordbruk/"],
    ["Share of city landfill site waste coming from the same city", "100%", "", "", ""],
    ["Share of new electric cars causing early replacement of fossil fueled cars", "0%", "", "", ""],
    ["Emissions from biogas heavy vehicle compared to diesel", "19%", "", "", "https://www.volvotrucks.com/content/dam/volvo-trucks/markets/global/our-values/environmental-care/our-trucks/Alternative_fuels_The_way_forward.pdf"],
    ["Share of emissions reduced by hydrogen industry", "100%", "", "", ""],
    ["Fossil-free share of electricity mix used in city", "96%", "", "", "https://www.scb.se/hitta-statistik/sverige-i-siffror/miljo/elektricitet-i-sverige/"]
]
    df = pd.DataFrame(data[1:], columns=data[0])
    if n_clicks is not None:
        return dcc.send_data_frame(df.to_csv, filename='TBE-assumptions.csv', header=True, index=False)
    elif n_clicks in [0, None]:
        raise PreventUpdate       
        
@app.callback(
    Output("CBE_assumption-modal1", "is_open"),
    [Input("CBE_assumption-button", "n_clicks")],
    [State("CBE_assumption-modal1", "is_open")]
)
def CBEassumption_modal(n, is_open):
    if n:
        return not is_open
    
@app.callback(
     Output("download-assumptions-cbe-text", "data"),
     Input("btn-download-assumptions-cbe", "n_clicks"), 
     prevent_initial_call=True
)
def print_button_CBE(n_clicks):
    data = [
    ["Factor", "Value", "Unit", "Comment", "Sources"],
    ["Diesel price per 10KM", "13", "SEK in 2022", "Cars", "Mobility Sweden"],
    ["Petrol price per 10KM", "15.2", "SEK in 2022", "Cars", "Mobility Sweden"],
    ["Electric price per 10KM", "5.5", "SEK in 2022", "Cars", "Mobility Sweden"],
    ["Hydrogen price per 10KM", "9", "SEK in 2022", "Cars", "https://vatgas.se/fakta/faq/"],
    ["Average driving distance per year of a car 10KM", "1,112", "10KM", "Cars", "Statistics Sweden"],
    ["Plug in hybrid emissions vs diesel or petrol car", "30%", "", "Cars", "https://bransch.trafikverket.se/contentassets/7ce1527807fa44ff9aa195ab440d5184/pm-vagtrafikens-utslapp-220207.pdf"],
    ["Share of petrol over (petrol and diesel cars)", "61%", "", "Cars", ""],
    ["OPEX trucks biogas extra cost compared to diesel", "0.13", "SEK/Km", "Trucks", "Swedish Biogas Association (2017)"],
    ["OPEX trucks biogas extra cost compared to diesel", "0.50", "SEK/Km", "Trucks", "Sweco (2019)"],
    ["OPEX trucks biogas extra cost compared to diesel", "0.30", "SEK/Km", "Trucks", "IVL Swedish Environmental Research Institute (2015)"],
    ["OPEX trucks biogas extra cost compared to diesel", "0.55", "SEK/Km", "Trucks", "Vattenfall AB (2016)"],
    ["OPEX trucks biogas extra cost compared to diesel", "0.35", "SEK/Km", "Trucks", "Vattenfall AB (2016)"],
    ["OPEX trucks biogas extra cost compared to diesel", "3.65", "SEK/mil", "Trucks", ""],
    ["Consumptiom per KM", "3.72", "2015", "Bus", "http://www.ecotraffic.se/media/10613/rapport_7078_-_kortversion_av_bussrapport_version_6.pdf"],
    ["OPEX Diesel consumption per 10 Km", "2.40", "Liter/mil", "Trucks", "https://www.volvotrucks.se/sv-se/news/magazine-online/2019/sep/Business-Story-Spain.html"],
    ["Diesel price per liter", "21.00", "SEK/liter", "Trucks", "https://dieselpriset.se/"],
    ["OPEX Diesel consumption per 10 Km", "50.40", "SEK/mil", "Trucks", ""],
    ["Congestion tax revenue in 2020", "2400000000", "SEK/år", "", "https://www.riksdagen.se/sv/dokument-lagar/dokument/motion/_H9023266"],
    ["Waste share of EH and DH emissions", "73%", "2021", "", "https://www.naturvardsverket.se/data-och-statistik/klimat/vaxthusgaser-utslapp-fran-el-och-fjarrvarme/"],
    ["Electricity used in housing and services", "58%", "2019", "", "https://www.scb.se/hitta-statistik/sverige-i-siffror/miljo/elektricitet-i-sverige/"],
    ["Electricity used in industry", "37%", "2019", "", "https://www.scb.se/hitta-statistik/sverige-i-siffror/miljo/elektricitet-i-sverige/"],
    ["Emission factor from heat production Malmö", "122", "g/KWH", "", "ME model uses Eon"],
    ["Emission factor from electricity production Malmö", "48", "g/KWH", "", "ME model uses Eon"],
    ["Average ETS price in 2022", "80", "euros", "", "https://www.umweltbundesamt.de/en/press/pressinformation/emissions-trading-rings-up-record-revenues-more"],
    ["Price electricity Sweden 2022", "1.07", "SEK/KWh", "", "https://www.elbruk.se/elpris-historik-2022"],
    ["From petrol to plug in hybrid - remaining emissions", "28.00%", "", "", ""],
    ["From diesel to plug in hybrid - remaining emissions", "39.00%", "", "", ""],
    ["Lifetime of a car", "16", "years", "", ""],
    ["Wind power production in Sweden in 2022", "27.1", "TWh", "", "https://www.ekonomifakta.se/fakta/energi/energibalans-i-sverige/elproduktion/"],
    ["GW to GWh conversion Wind", "2,747", "GWh/GW", "", ""],
    ["Wind power estimate by 2030 need capacity", "29.6", "GW", "Assuming we need to triple production", ""],
    ["Solar power production in Sweden in 2022", "1.1", "TWh", "", "https://www.ekonomifakta.se/fakta/energi/energibalans-i-sverige/elproduktion/"],
    ["GW to GWh conversion solar", "986.1495845", "GWh/GW", "", ""],
    ["Solar power estimate by 2030 need capacity", "3.3", "GW", "Assuming we need to triple production", ""],
    ["Bus emissions left from switching to HVO/RME/biogas fuel", "10%", "", "", "https://www.volvocars.com/se/edit/artikel/allt-om-hvo100"],
    ["Electric cars share of Swedish market", "35%", "2022", "Based on newly registered vehicles in Sweden", "https://www.transportstyrelsen.se/sv/vagtrafik/statistik/Statistik-over-koldioxidutslapp/statistik-over-koldioxidutslapp-2022/"],
    ["Plug in hybrid share of Swedish market", "23%", "2022", "", "https://www.transportstyrelsen.se/sv/vagtrafik/statistik/Statistik-over-koldioxidutslapp/statistik-over-koldioxidutslapp-2022/"],
    ["HVO use in buses today", "38%", "Sweden 2019", "", "https://energikontorsydost.se/l/kunskapsbank/56548?"],
    ["Share of Electricity and DH emissions from electricity", "40%", "Sweden", "", ""],
    ["Share of charging station for hybrid vs BEV need", "50%", "Sweden", "", "https://theicct.org/publication/europe-ldv-review-of-afir-proposal-how-much-power-output-needed-for-public-charging-infrastructure-in-the-eu-mar22/"],
    ["Share of district heating covered by heat pumps from air", "33%", "", "Mock value", "Research tbd, user can change this assumption if they want"],
    ["Share of district heating covered by heat pumps from water", "33%", "", "Mock value", "Research tbd, user can change this assumption if they want"],
    ["Share of district heating covered by heat pumps from geothermal", "33%", "", "Mock value", "Research tbd, user can change this assumption if they want"],
    ["Air heat pump emissions saving", "100%", "", "", "https://värmepumpen.se/en/byta-varmepump/#1551341900387-c6b9fb75-2364"],
    ["Air heat pump emissions saving", "100%", "", "", "https://värmepumpen.se/en/byta-varmepump/#1551341900387-c6b9fb75-2364"],
    ["Air heat pump emissions saving", "100%", "", "", "https://värmepumpen.se/en/byta-varmepump/#1551341900387-c6b9fb75-2364"],
    ["Impact from BAT appliances on energy savings", "21%", "", "Mock value", "(Savvidou and Nykvist, 2020)"],
    ["Impact from reduced temperature to 20 degrees on energy savings", "16%", "", "City-specific!", "(Savvidou and Nykvist, 2020)"],
    ["Impact from Savvidou Nykvist measures on energy savings", "16%", "", "City-specific!", "(Savvidou and Nykvist, 2020)"],
    ["CCS captures share of emissions", "90%", "", "", "https://climate.mit.edu/ask-mit/how-efficient-carbon-capture-and-storage"],
    ["Share of Carbon Credits counted towards negative emissions in net zero target", "100%", "", "", ""],
    ["Share of bio-CCS counted towards negative emissions in net zero target", "100%", "", "", ""],
    ["Share of rewetting counted towards negative emissions in net zero target", "100%", "", "", ""],
    ["Share of agricultural emissions related to methane", "53%", "", "", "https://www.naturvardsverket.se/data-och-statistik/klimat/vaxthusgaser-utslapp-fran-jordbruk/"],
    ["Share of city landfill site waste coming from the same city", "100%", "", "", ""],
    ["Share of new electric cars causing early replacement of fossil fueled cars", "0%", "", "", ""],
    ["Emissions from biogas heavy vehicle compared to diesel", "19%", "", "", "https://www.volvotrucks.com/content/dam/volvo-trucks/markets/global/our-values/environmental-care/our-trucks/Alternative_fuels_The_way_forward.pdf"],
    ["Share of emissions reduced by hydrogen industry", "100%", "", "", ""],
    ["Fossil-free share of electricity mix used in city", "96%", "", "", "https://www.scb.se/hitta-statistik/sverige-i-siffror/miljo/elektricitet-i-sverige/"]
]
    df = pd.DataFrame(data[1:], columns=data[0])
    if n_clicks is not None:
        return dcc.send_data_frame(df.to_csv, filename='CBE-assumptions.csv', header=True, index=False)
    elif n_clicks in [0, None]:
        raise PreventUpdate  
        
@app.callback(
    Output("TBE_assumption-modal3", "is_open"),
    [Input("TBE_assumption-button2", "n_clicks")],
    [State("TBE_assumption-modal3", "is_open")]
)
def TBEassumption_modal3(n, is_open):
    if n:
        return not is_open
    else:
        return is_open  
    
@app.callback(
    Output("assumptioncollapse-1", "is_open"),
    [Input("assumption-collapse", "n_clicks")],
    [State("assumptioncollapse-1", "is_open")]
)
def Assumption_changes1(n, is_open):
    if n:
        return not is_open
    else:
        return is_open
    
@app.callback(
    Output("assumptioncollapse-2", "is_open"),
    [Input("assumption-collapse2", "n_clicks")],
    [State("assumptioncollapse-2", "is_open")]
)
def Assumption_changes2(n, is_open):
    if n:
        return not is_open
    else:
        return is_open
    
@app.callback(
    Output("assumptioncollapse-3", "is_open"),
    [Input("assumption-collapse3", "n_clicks")],
    [State("assumptioncollapse-3", "is_open")]
)
def Assumption_changes3(n, is_open):
    if n:
        return not is_open
    else:
        return is_open

@app.callback(
    Output("Transport-collapse-TBE", "is_open"),
    [Input("Transport-collapse-TBE-button", "n_clicks")],
    [State("Transport-collapse-TBE", "is_open")]
)
def Transport_tbe(n, is_open):
    if n:
        return not is_open
    else:
        return is_open
    
@app.callback(
    Output("Energy-collapse-TBE", "is_open"),
    [Input("Energy-TBE-button", "n_clicks")],
    [State("Energy-collapse-TBE", "is_open")]
)
def Energy_tbe(n, is_open):
    if n:
        return not is_open
    else:
        return is_open
    
###user guide download     
def user_guide():
    file_path = '2023-10-08 User guide.docx'

    if os.path.isfile(file_path):
        with open(file_path, 'rb') as file:
            file_content = file.read()

        encoded_file = base64.b64encode(file_content).decode('utf-8')
        href = f'data:application/vnd.openxmlformats-officedocument.wordprocessingml.document;base64,{encoded_file}'
        return href
    else:
        return ''

### excel database template download    
def download_mock_excel():
    file_path = 'Database template.xlsx'

    if os.path.isfile(file_path):
        with open(file_path, 'rb') as file:
            file_content = file.read()

        encoded_file = base64.b64encode(file_content).decode('utf-8')
        href = f'data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,{encoded_file}'
        return href
    else:
        return ''
   
#save input buttons tbe 1
def parse_contents(contents, filename):
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    if 'csv' in filename:
        # Assume that the user uploaded a CSV file
        return pd.read_csv(
            io.StringIO(decoded.decode('utf-8')))
    elif 'xls' in filename:
        # Assume that the user uploaded an excel file
        return pd.read_excel(io.BytesIO(decoded))


@app.callback(
    Output('data-saved-status', 'data'),
    [Input('btn-save-own-data-tbe1', 'n_clicks')],
    Input('municipality-dropdown', 'value'),
    Input("region-dropdown", "value"),
    Input('full-name-input', 'value'),
    Input('organization-input', 'value'),
    *[Input({'type': 'User source', 'index': i}, 'value') for i in range(len(Your_data))],
    *[Input({'type': 'user-assumptions', 'index': i}, 'value') for i in range(len(Your_data))]
)
def update_output1(n_clicks, city, country, name, orga, *sources_and_assumptions):
    ctx = dash.callback_context
    button_id = ctx.triggered[0]["prop_id"].split(".")[0]

    num_factors = len(Your_data)
    sources = sources_and_assumptions[:num_factors]
    assumptions = sources_and_assumptions[num_factors:]

    data = [
        {
            'User assumptions': [assumptions[i] for i in range(num_factors)],
            'User source': [sources[i] for i in range(num_factors)]
        }
    ]
    df = pd.DataFrame(data)

    # Create a single row for name, organization, and assumptions
    row_data = {
        'Full name': name,
        'Organization': orga,
        'country': country,
        'city': city,
        **df.to_dict('records')[0]  # Taking the data from the first row of the original DataFrame
    }

    row_count = 1  # We are creating a single row

    df_row = pd.DataFrame([row_data])

    if n_clicks and orga and name and city and country and button_id == "btn-save-own-data-tbe1":
        try:
            existing_data = pd.read_excel('User-input-swedish-data.xlsx')
            updated_data = pd.concat([existing_data, df_row], ignore_index=True, sort=False)
            updated_data.to_excel('User-input-swedish-data.xlsx', index=False)
        except FileNotFoundError:
            df_row.to_excel('User-input-swedish-data.xlsx', index=False)
        return 1
    else:
        return 0

@app.callback(Output('data-saved-status-tbe2', 'data'),
              [Input('btn-save-own-data-tbe2', 'n_clicks')],
              Input('municipality-dropdown', 'value'),
              Input("region-dropdown", "value"),
              Input('full-name-input-tbe2', 'value'),
              Input('organization-input-tbe2', 'value'),
              [Input({'type': 'source-user-tbe2', 'index': i}, 'value') for i in range(len(Your_data))],
              [Input({'type': 'user-assumptions-tbe2', 'index': i}, 'value') for i in range(len(Your_data))]
)
def update_output2(n_clicks, city, country, name, orga, source1, source2, source3, source4,  assum1, assum2, assum3, assum4):
    ctx = dash.callback_context
    button_id=ctx.triggered[0]["prop_id"].split(".")[0]
    assumptions=[source1, source2, source3, source4]
    sources=[str(assum1), str(assum2), str(assum3), str(assum4)]
    data=[{'Sector': row['Sector'], 'Existing assumptions': row['Existing assumptions'],
           'Source': row['Source'], 'User assumptions': assumptions[i],
           'Source': sources[i]} for i, row in enumerate(Your_data)]
    df = pd.DataFrame({'Input': [data]})
    row = df.shape[0]
    d = {'country': [np.repeat(country, row)], 'city': [np.repeat(city, row)]}
    d1 = {'Full name': [np.repeat(name, row)], 'Organization': [np.repeat(orga, row)]}
    df1 = pd.DataFrame(data=d)
    df3 = pd.DataFrame(data=d1)
    df=df.reset_index(drop=True)
    df2 = pd.concat([df, df1, df3], axis=1)
    if n_clicks and orga and name and (button_id == "btn-save-own-data-tbe2") and city and country:
        try:
            existing_data = pd.read_excel('User-input-data.xlsx')
            updated_data = pd.concat([existing_data, df2], ignore_index=True, sort= False)            
            updated_data.to_excel('User-input-data.xlsx', index=False)
        except FileNotFoundError:
            df2.to_excel('User-input-data.xlsx', index=False)
        return 1
    else:
       return 0

#save input buttons
@app.callback(
    Output("popover_tbe1a", "is_open"),
    [Input("btn-save-own-data-tbe1", "n_clicks")],
    [Input('data-saved-status', 'data')],
    [State("popover_tbe1a", "is_open")]
)
def toggle_popover1(n, stat, is_open1):
    ctx = dash.callback_context
    button_id = ctx.triggered[0]["prop_id"].split(".")[0]

    if n and (button_id == "btn-save-own-data-tbe1"):
        return not is_open1

    return is_open1

@app.callback(
    Output("popover_tbe2a", "is_open"),
    Output("popover_tbe2b", "is_open"),
    [Input("btn-save-own-data-tbe2", "n_clicks")],
    [Input('data-saved-status-tbe2', 'data')],
    [State("popover_tbe2a", "is_open")],
    [State("popover_tbe2b", "is_open")],
)
def toggle_popover2(n, stat, is_open1, is_open2):
    ctx = dash.callback_context
    button_id=ctx.triggered[0]["prop_id"].split(".")[0]    
    if n and stat==1 and (button_id == "btn-save-own-data-tbe2"):
        return not is_open1, is_open2
    if n and stat==0 and (button_id == "btn-save-own-data-tbe2"):
        return is_open1, not is_open2
    return is_open1, is_open2

@app.callback(
    [Output("VC_div", "is_open"), Output("NZC_div", "is_open")],
    Input("VC-NZC-value", "data"), 
    [State("VC_div", "is_open"), State("NZC_div", "is_open")]
)
def VC_NZC_collapse(value, is_open1, is_open2):
    if value == 0:
        return [False, True]
    elif value == 1:
         return [True, False]         
    return [is_open1, is_open2]

@app.callback(
    Output('tabs-example-content-1', 'children'),
    [Input('tabs-example-1', 'value')]
)
def render_content(tab):
    if tab == 'tab-1':
        collapse_2()
    if tab == "tab-2":
        collapse_3()

@app.callback(
    Output('tabs-example-content-2', 'children'),
    [Input('tabs-example-2', 'value')]
)
def render_content1(tab):
    if tab == "tab-3":
        collapse_4()

@app.callback([Output('slider-29', 'value'), Output('slider-30', 'value'),
               Output('slider-39', 'value'), Output('slider-40', 'value'),
               Output('slider-41', 'value'), Output('slider-42', 'value'),
               Output('slider-44', 'value'), Output('slider-45', 'value'), Output('slider-46', 'value'),
               Output('slider-53', 'value'), Output('slider-54', 'value'),
               Output('slider-55', 'value'), Output('slider-56', 'value'), Output('slider-57', 'value'),
               Output('slider-49', 'value'), Output('slider-50', 'value'), Output('slider-51', 'value'),
               Output('slider-33', 'value'), Output('slider-34', 'value'), Output('slider-35', 'value'),
               Output('slider-37', 'value'), Output('slider-38', 'value')],
              [Input('slider-29', 'value'), Input('slider-30', 'value'),
               Input('slider-39', 'value'), Input('slider-40', 'value'),
               Input('slider-41', 'value'), Input('slider-42', 'value'),
               Input('slider-44', 'value'), Input('slider-45', 'value'),Input('slider-46', 'value'),
               Input('slider-53', 'value'), Input('slider-54', 'value'),
               Input('slider-55', 'value'), Input('slider-56', 'value'),Input('slider-57', 'value'),
               Input('slider-49', 'value'), Input('slider-50', 'value'),Input('slider-51', 'value'),
               Input('slider-33', 'value'), Input('slider-34', 'value'),Input('slider-35', 'value'),
               Input('slider-37', 'value'), Input('slider-38', 'value')])


def slider_adjust1(slider_bus1, slider_bus2, slider_htrucks1, slider_htrucks2, slider_ltrucks1,
                   slider_ltrucks2, slider_elec1, slider_elec2, slider_elec3,
                   slider_indus1,slider_indus2, slider_negem1, slider_negem2, slider_negem3,slider_be1, slider_be2,
                   slider_be3,slider_car1, slider_car2, slider_car3,slider_car4, slider_car5):
    ctx = dash.callback_context
    trigger_id = ctx.triggered[0]["prop_id"].split(".")[0]
    var_lis = [slider_bus1, slider_bus2, slider_htrucks1, slider_htrucks2, slider_ltrucks1,
                       slider_ltrucks2, slider_elec1, slider_elec2, slider_elec3,
                       slider_indus1,slider_indus2, slider_negem1, slider_negem2, slider_negem3,slider_be1, slider_be2,
                       slider_be3,slider_car1, slider_car2, slider_car3,slider_car4, slider_car5]

    for count, i in enumerate(var_lis):
        if i is None:
            var_lis[count] = 0
    if (var_lis[0] + var_lis[1]) > 100 and trigger_id == "slider-29":
        new_slide_val = 100 - var_lis[0]
        return [dash.no_update, new_slide_val, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

    elif (var_lis[0] + var_lis[1]) > 100 and trigger_id == "slider-30":
        new_slide_val = 100 - var_lis[1]
        return [new_slide_val, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

    elif (var_lis[2] + var_lis[3]) > 100 and trigger_id == "slider-39":

        new_slide_val = 100 - var_lis[2]

        return [dash.no_update, dash.no_update, dash.no_update, new_slide_val, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

    elif (var_lis[2] + var_lis[3]) > 100 and trigger_id == "slider-40":
        new_slide_val = 100 - var_lis[3]

        return [dash.no_update, dash.no_update, new_slide_val, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

    elif (var_lis[4] + var_lis[5]) > 100 and trigger_id == "slider-41":

        new_slide_val = 100 - var_lis[4]

        return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                new_slide_val, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

    elif (var_lis[4] + var_lis[5]) > 100 and trigger_id == "slider-42":

        new_slide_val = 100 - var_lis[5]

        return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, new_slide_val,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

    elif (var_lis[6] + var_lis[7] + var_lis[8]) > 100 and trigger_id == "slider-44":
        if var_lis[7] > 0 and var_lis[8] > 0:
            new_slide_val = (100 - var_lis[6]) / 2
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, new_slide_val, new_slide_val, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

        elif var_lis[7] > 0 and var_lis[8] == 0:
            new_slide_val = (100 - var_lis[6])

            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, new_slide_val, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

        elif var_lis[7] == 0 and var_lis[8] > 0:
            new_slide_val = (100 - var_lis[6])

            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, new_slide_val, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

    elif (var_lis[6] + var_lis[7] + var_lis[8]) > 100 and trigger_id == "slider-45":
        if var_lis[6] > 0 and var_lis[8] > 0:
            new_slide_val = (100 - var_lis[7]) / 2

            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, new_slide_val, dash.no_update, new_slide_val, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

        elif var_lis[6] > 0 and var_lis[8] == 0:
            new_slide_val = (100 - var_lis[7])

            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, new_slide_val, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

        elif var_lis[6] == 0 and var_lis[8] > 0:
            new_slide_val = (100 - var_lis[7])

            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, new_slide_val, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

    elif (var_lis[6] + var_lis[7] + var_lis[8]) > 100 and trigger_id == "slider-46":
        if var_lis[6] > 0 and var_lis[7] > 0:
            new_slide_val = (100 - var_lis[8]) / 2
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, new_slide_val, new_slide_val, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

        elif var_lis[6] > 0 and var_lis[7] == 0:
            new_slide_val = (100 - var_lis[8])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, new_slide_val, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

        elif var_lis[6] == 0 and var_lis[7] > 0:
            new_slide_val = (100 - var_lis[8])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, new_slide_val, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

    elif (var_lis[9] + var_lis[10]) > 100 and trigger_id == "slider-53":
        new_slide_val = 100 - var_lis[9]
        return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                new_slide_val, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

    elif (var_lis[9] + var_lis[10]) > 100 and trigger_id == "slider-54":
        new_slide_val = 100 - var_lis[10]

        return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, new_slide_val,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

    elif (var_lis[11] + var_lis[12] + var_lis[13]) > 100 and trigger_id == "slider-55":
        if var_lis[12] > 0 and var_lis[13] > 0:
            new_slide_val = (100 - var_lis[11]) / 2
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, new_slide_val, new_slide_val, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

        elif var_lis[12] > 0 and var_lis[13] == 0:
            new_slide_val = (100 - var_lis[11])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, new_slide_val, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

        elif var_lis[12] == 0 and var_lis[13] > 0:
            new_slide_val = (100 - var_lis[11])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, new_slide_val, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

    elif (var_lis[11] + var_lis[12] + var_lis[13]) > 100 and trigger_id == "slider-56":
        if var_lis[11] > 0 and var_lis[13] > 0:
            new_slide_val = (100 - var_lis[12]) / 2

            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, new_slide_val, dash.no_update, new_slide_val, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

        elif var_lis[11] > 0 and var_lis[13] == 0:
            new_slide_val = (100 - var_lis[12])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, new_slide_val, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

        elif var_lis[11] == 0 and var_lis[13] > 0:
            new_slide_val = (100 - var_lis[12])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, new_slide_val, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

    elif (var_lis[11] + var_lis[12] + var_lis[13]) > 100 and trigger_id == "slider-57":
        if var_lis[11] > 0 and var_lis[12] > 0:
            new_slide_val = (100 - var_lis[13]) / 2
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, new_slide_val, new_slide_val, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

        elif var_lis[11] > 0 and var_lis[12] == 0:
            new_slide_val = (100 - var_lis[13])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, new_slide_val, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

        elif var_lis[11] == 0 and var_lis[12] > 0:
            new_slide_val = (100 - var_lis[13])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, new_slide_val, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

    elif (var_lis[14] + var_lis[15] + var_lis[16]) > 100 and trigger_id == "slider-49":
        if var_lis[15] > 0 and var_lis[16] > 0:
            new_slide_val = (100 - var_lis[14]) / 2
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, new_slide_val, new_slide_val, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

        elif var_lis[15] > 0 and var_lis[16] == 0:
            new_slide_val = (100 - var_lis[14])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, new_slide_val, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

        elif var_lis[15] == 0 and var_lis[16] > 0:
            new_slide_val = (100 - var_lis[14])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, new_slide_val, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

    elif (var_lis[14] + var_lis[15] + var_lis[16]) > 100 and trigger_id == "slider-50":
        if var_lis[14] > 0 and var_lis[16] > 0:
            new_slide_val = (100 - var_lis[15]) / 2

            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, new_slide_val, dash.no_update, new_slide_val, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

        elif var_lis[14] > 0 and var_lis[16] == 0:
            new_slide_val = (100 - var_lis[15])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, new_slide_val, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

        elif var_lis[14] == 0 and var_lis[16] > 0:
            new_slide_val = (100 - var_lis[15])

            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, new_slide_val, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

    elif (var_lis[14] + var_lis[15] + var_lis[16]) > 100 and trigger_id == "slider-51":
        if var_lis[14] > 0 and var_lis[15] > 0:
            new_slide_val = (100 - var_lis[16]) / 2

            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, new_slide_val, new_slide_val, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

        elif var_lis[14] > 0 and var_lis[15] == 0:
            new_slide_val = (100 - var_lis[16])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, new_slide_val, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

        elif var_lis[14] == 0 and var_lis[15] > 0:
            new_slide_val = (100 - var_lis[16])

            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, new_slide_val, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

 

    elif (var_lis[17] + var_lis[18] + var_lis[19] + var_lis[20] + var_lis[21]) > 100 and trigger_id == "slider-33":
        if var_lis[18] == 0 and var_lis[19] == 0 and var_lis[20] == 0 and var_lis[21] > 0:
            new_slide_val = (100 - var_lis[17])

            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, new_slide_val]

        elif var_lis[18] == 0 and var_lis[19] == 0 and var_lis[20] > 0 and var_lis[21] == 0:
            new_slide_val = (100 - var_lis[17])

            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, new_slide_val, dash.no_update]

        elif var_lis[18] == 0 and var_lis[19] > 0 and var_lis[20] == 0 and var_lis[21] == 0:
            new_slide_val = (100 - var_lis[17])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,dash.no_update, dash.no_update, new_slide_val, dash.no_update, dash.no_update]

        elif var_lis[18] > 0 and var_lis[19] == 0 and var_lis[20] == 0 and var_lis[21] == 0:
            new_slide_val = (100 - var_lis[17])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,dash.no_update, new_slide_val, new_slide_val, new_slide_val, new_slide_val]

        else:
            new_slide_val = (100 - var_lis[17]) / 4
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,dash.no_update, new_slide_val, new_slide_val, new_slide_val, new_slide_val]

    elif (var_lis[17] + var_lis[18] + var_lis[19] + var_lis[20] + var_lis[21]) > 100 and trigger_id == "slider-34":
        if var_lis[17] == 0 and var_lis[19] == 0 and var_lis[20] == 0 and var_lis[21] > 0:
            new_slide_val = (100 - var_lis[18])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, new_slide_val]

        elif var_lis[17] == 0 and var_lis[19] == 0 and var_lis[20] > 0 and var_lis[21] == 0:
            new_slide_val = (100 - var_lis[18])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, new_slide_val, dash.no_update]

        elif var_lis[17] == 0 and var_lis[19] > 0 and var_lis[20] == 0 and var_lis[21] == 0:
            new_slide_val = (100 - var_lis[18])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,dash.no_update, dash.no_update, new_slide_val, dash.no_update, dash.no_update]

        elif var_lis[17] > 0 and var_lis[19] == 0 and var_lis[20] == 0 and var_lis[21] == 0:
            new_slide_val = (100 - var_lis[18])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,new_slide_val, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

        else:
            new_slide_val = (100 - var_lis[18]) / 4
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,dash.no_update, new_slide_val, new_slide_val, new_slide_val, new_slide_val]


    elif (var_lis[17] + var_lis[18] + var_lis[19] + var_lis[20] + var_lis[21]) > 100 and trigger_id == "slider-35":
        if var_lis[17] == 0 and var_lis[18] == 0 and var_lis[20] == 0 and var_lis[21] > 0:
            new_slide_val = (100 - var_lis[19])

            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, new_slide_val]

        elif var_lis[17] == 0 and var_lis[18] == 0 and var_lis[20] > 0 and var_lis[21] == 0:
            new_slide_val = (100 - var_lis[19])

            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, new_slide_val, dash.no_update]

        elif var_lis[17] == 0 and var_lis[18] > 0 and var_lis[20] == 0 and var_lis[21] == 0:
            new_slide_val = (100 - var_lis[19])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,dash.no_update, new_slide_val, dash.no_update, dash.no_update, dash.no_update]
       
        elif var_lis[17] > 0 and var_lis[18] == 0 and var_lis[20] == 0 and var_lis[21] == 0:
            new_slide_val = (100 - var_lis[19])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, new_slide_val, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

        else:
            new_slide_val = (100 - var_lis[19]) / 4
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,new_slide_val, new_slide_val, dash.no_update, new_slide_val, new_slide_val]


    elif (var_lis[17] + var_lis[18] + var_lis[19] + var_lis[20] + var_lis[21]) > 100 and trigger_id == "slider-37":
        if var_lis[17] == 0 and var_lis[18] == 0 and var_lis[19] == 0 and var_lis[21] > 0:
            new_slide_val = (100 - var_lis[20])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, new_slide_val]

        elif var_lis[17] == 0 and var_lis[18] == 0 and var_lis[19] > 0 and var_lis[21] == 0:
            new_slide_val = (100 - var_lis[20])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, new_slide_val, dash.no_update, dash.no_update]

        elif var_lis[17] == 0 and var_lis[18] > 0 and var_lis[19] == 0 and var_lis[21] == 0:
            new_slide_val = (100 - var_lis[20])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, new_slide_val, dash.no_update, dash.no_update, dash.no_update]

        elif var_lis[17] > 0 and var_lis[18] == 0 and var_lis[19] == 0 and var_lis[21] == 0:
            new_slide_val = (100 - var_lis[20])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,new_slide_val, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

        else:
            new_slide_val = (100 - var_lis[20]) / 4
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,new_slide_val, new_slide_val, new_slide_val, dash.no_update, new_slide_val]

 

    elif (var_lis[17] + var_lis[18] + var_lis[19] + var_lis[20] + var_lis[21]) > 100 and trigger_id == "slider-38":
        if var_lis[17] == 0 and var_lis[18] == 0 and var_lis[19] == 0 and var_lis[20] > 0:
            new_slide_val = (100 - var_lis[21])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, new_slide_val, dash.no_update]

        elif var_lis[17] == 0 and var_lis[18] == 0 and var_lis[19] > 0 and var_lis[20] == 0:
            new_slide_val = (100 - var_lis[21])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,dash.no_update, dash.no_update, new_slide_val, dash.no_update, dash.no_update]

        elif var_lis[17] == 0 and var_lis[18] > 0 and var_lis[19] == 0 and var_lis[20] == 0:
            new_slide_val = (100 - var_lis[21])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,dash.no_update, new_slide_val, dash.no_update, dash.no_update, dash.no_update]

        elif var_lis[17] > 0 and var_lis[18] == 0 and var_lis[19] == 0 and var_lis[20] == 0:
            new_slide_val = (100 - var_lis[21])
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,new_slide_val, dash.no_update, dash.no_update, dash.no_update, dash.no_update]

        else:
            new_slide_val = (100 - var_lis[21]) / 4
            return [dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update,dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,
                dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update,new_slide_val, new_slide_val, new_slide_val, new_slide_val, dash.no_update]
    
def VC_dropdown():
    return(dcc.Tabs(id='tabs-example-1', value = "tab-2", children=[
    dcc.Tab(id="tab-2", label="Territorial-based-emissions", value='tab-2',
            children=[dbc.Row([dbc.Col([scenario_dropdown2()], width=12)], className= "scenario-row"),collapse_3()]),
    dcc.Tab(id="tab-1", label="Consumption-based emissions (households only)", value="tab-1", 
            children=[dbc.Row([dbc.Col([scenario_dropdown1()], width=12)], className= "scenario-row"),collapse_2()])]),
    html.Div(id='tabs-example-content-1'))
#def NZC_dropdown():
    #return(dcc.Tabs(id='tabs-example-2', value = "tab-3", children=[
    #dcc.Tab(id="tab-3", label="Territorial-based-emissions", value="tab-3",
            #children=[dbc.Row([ dbc.Col([scenario_dropdown3()], width=12)], className= "scenario-row"), collapse_4()]),]),
    #html.Div(id='tabs-example-content-2'))

app.layout = html.Div([
    build_banner(), collapse(), 
    dbc.Row([
        dbc.Collapse(VC_dropdown(), id="VC_div", is_open=True)]),
    dcc.Store(id="VC-NZC-value")])

if __name__ == '__main__':
    app.run_server(debug=False)

#dbc.Collapse(NZC_dropdown(), id="NZC_div", is_open=True),